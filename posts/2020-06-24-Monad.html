<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>lionhairdino - 모나드로 가기 전</title>
        <meta name="description" content="Haskell,하스켈,해스클">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <meta property="og:type" content="website">
        <meta property="og:title" content="lionhairdino">
        <meta property="og:description" content="Haskell,하스켈,해스클">
        <meta property="og:url" content="https://lionhairdino.github.io">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">lionhairdino</a>
            </div>
            <div id="navigation">
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
        </div>

        <div id="content">
            <h1>모나드로 가기 전</h1>

            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on June 24, 2020
    
</div>

<p>기본 모나드 정의에 관한 포스트가 아닙니다. 모나드 설명은 검색으로 수 천개는 접할 수 있습니다. 여기서는 학습하면서 가졌던 나름의 이해와 의문에 대해 적었습니다. 다른 포스트와 달리, <em>훨씬 더 검증이 필요한 내용</em>들입니다. 지금 이 포스트는 학습 노트 성격이지만, 현재 비슷한 진도에서 고민하고 있는 분들과 생각을 나누기 위해 먼저 올려 놓습니다.</p>
<h3 id="카테고리-이론과-하스켈의-닮은-점">카테고리 이론과 하스켈의 닮은 점</h3>
<p>람다 대수에서 모든 대상을 함수로 보고 대수 체계를 만들어 가 듯이 오로지 카테고리들끼리의 관계만으로 대수 체계를 만들어가는, 쉽지 않은 수학 이론입니다. 모나드, 펑크터의 어원etimology이 이 곳이구나 정도만 알고 지나가도 되지만, 이 곳에서 온 용어와 개념들이 많기 때문에 결국에는 입문정도는 해놔야 합니다.</p>
<p>오브젝트가 갖고 있는 어떤 속성도 관심없고, 한 구조안에 있는 오브젝트들끼리의 관계만 의미를 두는 이론입니다. (오브젝트는 그냥 관계의 출발점과 끝점을 표시하는 점으로만 보면 됩니다.) 하스켈은 함수를 품고 품어서 프로그램을 완성하므로, 합성이라는 개념과 많이 닮아 있습니다. 하스켈의 한 데이터 구조를 대상으로 하는 함수들은 합성 능력이 있어야 쓸모가 있습니다.</p>
<p>모나드는 합성을 위한 패턴입니다.</p>
<h3 id="모노이드">모노이드</h3>
<ul>
<li>항등원unit이 있고</li>
<li>Binary 함수가 있고,</li>
<li>결합 법칙을 따르는 구조를</li>
</ul>
<p>모노이드라고 합니다.</p>
<ul>
<li>이항 함수[1]의 반복 적용으로 모든 원소 표현이 가능하다는 속성이 실용에서 어떤 역할을 할까요? total 함수임을 보장합니다.</li>
<li>결합 법칙을 따르지 않는다면 어떻게 될까요?<br />
결합 법칙을 따른다면, 실행 순서에 상관 없다는 얘기입니다. 하지만 실용 세계에서는 퍼포먼스 차이가 있으니, 권장되는 순서는 있습니다. 결합 법칙을 따른다면, 순서를 바꿔도 결과가 같다는 걸 보장하니, 퍼포먼스가 좋은 순서로 마음놓고 바꿀 수 있습니다.</li>
<li>항등원이 없으면, 실용 코드에서는 분기문 없이 아무일도 안하는 프로세스를 돌릴 수 없습니다. 가끔 무조건 돌고, 때에 따라 아무일도 안하는 게 필요합니다. 1 + 0 을 하면 1이 됩니다. 1에서 1로 가는 모피즘입니다. isomorphism이 존재한다는 말과 같습니다.</li>
</ul>
<p>Binary 함수가 있어 모노이드가 되는 걸까요? 모노이드가 되려면 Binary 함수가 있어야 하는걸까요? 같은 말이긴 한데, 이해하기 위해 길을 찾을 때는 다른 길입니다. 어떤 구조를 모노이드로 만들어 버리는 것과, 이미 구조가 있어 모노이드라 부르는 것인지 두 말은 시점이 좀 다릅니다. 전 모노이드의 속성을 얻기 위해 Binary 함수를 만드는 쪽으로 이해했습니다. 펑크터로 만들려면 fmap 을 만들고, 모나드로 만들려면 join, return 성격의 Natural transformation을 만드는 겁니다.</p>
<p>펑크터로 만들면, 펑크터로 리프팅 되기 전에 쓰이던 함수들을 그대로 가져다 쓸 수 있고, 모나드로 만들면 펑크터들을 컴포지션 할 수 있습니다.</p>
<p><em>왜 카테고리로 만들려고 할까요?</em> 컴포지션 때문입니다. 컴포지션 능력을 갖게 하기 위해 카테고리로 만듭니다. 엔도펑크터 카테고리로 만들면 엔도펑크터들끼리 컴포지션 할 수 있습니다.</p>
<h3 id="엔도펑크터">엔도펑크터</h3>
<p>소스 카테고리와 결과 카테고리가 같은 펑크터를 엔도펑크터라 합니다. Hask 카테고리에서 만나는 펑크터들은 결과가 Hask를 벗어나지 않기 때문에 모두 엔도펑크터입니다. a -&gt; m b 타입은 함수일까요, 펑크터일까요, Natural Transformation 일까요? 세 개다 맞습니다. a 타입에서 m b 타입으로 가는 함수로 볼 수 있고, a 카테고리의 구조를 유지하면서 m b 카테고리로 연결하는 펑크터로 볼 수도 있고, a 앞에 Id 펑크터가 생략됐다고 보고(Id a -&gt; m b) Id 펑크터에서 m 펑크터로 가는 Natural Transformation으로 볼 수도 있습니다.</p>
<p>Some 타입을 정의하고, Some 타입의 컴포지션을 정의하면 Some 카테고리로 볼 수도 있습니다. Maybe 카테고리, List 카테고리… 등 타입 하나가 컴포지션만 잘 정의되어 있으면 하나의 카테고리로 볼 수도 있습니다.</p>
<p>어떻게 됐든, 펑크터를 적용해서 자기 카테고리로 다시 돌아오는 걸 엔도펑크터라 합니다.</p>
<h3 id="엔도펑크터의-모노이드">엔도펑크터의 모노이드</h3>
<p>엔도펑크터의 모노이달 카테고리(모노이드 성격의 카테고리, 오브젝트가 하나만 있는 카테고리)로 만들려면 join, return이 필요한 구조를 모나드라 부릅니다. 다시 말해, 모나드는 엔도펑크터 카테고리의 모노이드입니다.<br />
“A monad is just a monoid in the category of endofunctor”</p>
<p>모든 모노이드가 모나드는 아니지만, 모든 모나드는 모노이드입니다.</p>
<h3 id="컴포지션-하려면-하나의-카테고리에-있어야-한다.">컴포지션 하려면 하나의 카테고리에 있어야 한다.</h3>
<p>문서들이 “왜 이 개념이 필요한지” 목표를 명확히 써주면 좋을텐데, 대부분 카테고리 입문용 문서들이 왜 그렇게 하는지 이유를 쉽게 알려주지 않습니다. “이런 이런 모양이 펑크터야, 모노이드야, 모나드야” 라는 자료는 많지만, 왜 펑크터, 모노이드, 모나드로 만드는지 친절하게 목표를 풀어 주는 자료는 많지 않습니다.</p>
<p>join 성격의 Natural Transformation이 있다면, 펑크터를 연결 할 수 있습니다. 다시 말해 컴포지션 할 수 있습니다.</p>
<p>a -&gt; m b 함수를 컴포지션 하려면 join이 필요합니다. 다른 타입의 컴포지션과 달리 왜그리 중요한 역할을 하게 됐을까요?</p>
<h3 id="왜-a---m-b-타입-함수가-특별할까">왜 a -&gt; m b 타입 함수가 특별할까?</h3>
<p>m a -&gt; m b 타입[2]으로 함수를 만들면 복잡한 개념 없이 품고 품게composition 할 수 있지 않을까 생각이 듭니다. 하지만, m 컨텍스트에서 m 컨텍스트로 가면 품는 동안 반드시 m 컨텍스트가 발현된다는 보장이 없습니다. fmap이 동작하거나, 패턴 매칭이 나와야지만 Side effect가 나옵니다. m a 와 a -&gt; m b 함수를 받으면 m a 에서 m 을 벗겨내는 작업이 있어야만 a -&gt; m b 함수를 적용할 수 있습니다. 다시 말해, <em>컨텍스트가 반드시 발현</em>됩니다.</p>
<h3 id="kleighsly-카테고리">Kleighsly 카테고리</h3>
<p>a -&gt; b 와 b -&gt; c 함수는 (.)으로 composition 할 수 있습니다.<br />
a -&gt; m b 와 b -&gt; m c 함수는 (&gt;=&gt;) 으로 composition 할 수 있습니다.</p>
<p>bind 를 (&gt;=&gt;)로 표현할 수도 있고, join 과 fmap 으로도 표현할 수 있습니다. 셋 중에 한 가지 방식만 정의되면, 모나드 역할을 할 수 있습니다.</p>
<h3 id="비순수-작업에-관여하는-부분만-떼어내-보면-모나드가-아니라-펑크터의-속성입니다.">비순수 작업에 관여하는 부분만 떼어내 보면 모나드가 아니라 펑크터의 속성입니다.</h3>
<p>Maybe의 컨텍스트인 “Nothing일 수도 있어” 라는 컨텍스트를 처리하는 건 펑크터의 fmap이 맡습니다. fmap에서 Nothing이냐, Just이냐에 따라 분기가 일어납니다. 이렇게 분기가 일어난 결과를 <em>다음 작업과 연결하는 작업을 담당하는게 모나드</em>입니다. 모나드의 bind 구현을 보면 join이 fmap을 품은 형태입니다. fmap 으로 Side effect 를 발현시키고 나온 결과물을 다음 액션과 연결하기 위해(타입을 맞추기 위해) join을 씌우는 모양입니다.</p>
<h3 id="상태를-넘기는-영리한-방법이야">상태를 넘기는 영리한 방법이야?</h3>
<p>특정 모나드의 동작만 놓고, 이렇게 동작하는게 모나드야라고 설명한 말입니다. 사람이 앉아서 밥을 먹는 걸 봤다고, 앉아서 밥을 먹는 건 사람이야 라고 얘기하면 사람이 뭔지 알기 어렵습니다. “상태를 넘기는 걸 모나드 패턴으로 구현할 수도 있어”가 모나드 입문자에게는 더 맞는 표현이라 생각합니다.</p>
<h3 id="모나드가-왜-수많은-난제들을-해결할까">모나드가 왜 수많은 난제들을 해결할까?</h3>
<p>함수가 함수를 품을때마다 반드시 fmap이 한 번씩 동작합니다. 체이닝할 때 매 번 뭔가 작업을 반복적으로 해야 한다면 딱 어울리는 패턴입니다.</p>
<p>Maybe는 컴포지션할 때마다 매 번 “Nothing 인지 검사하고”<br />
Status는 컴포지션할 때마다 매 번 “상태값을 액션에 넣어줘야 하고”<br />
Writer는 컴포지션할 때마다 매 번 “로그 ‘같은’ 값들을 계속 누적하고”<br />
IO는 컴포지션할 때마다 매 번 “Status처럼 런타임 상태값을 계속 끌고 다녀야 하고”<br />
…</p>
<p>그리고 또 한가지,<br />
카테고리 이론 쪽에선 의도한게 아닐 것 같은데요, 모나드의 굉장히 중요한 성격이 있습니다. 하스켈은 Lazy한 함수들이 순차적으로 실행된다는 보장이 없습니다. 하지만 함수들이 품고 품은 상태로 엮인 상태에서, 현재 함수를 실행하려면 반드시 이전 단계 함수의 결과값이 꼭 필요한 상태가 되게 하면, 자연스럽게 함수들 사이에 실행 순서가 생깁니다. 모나드 패턴으로 엮을 때 이 효과가 자연스럽게 생깁니다.</p>
<p>정리하면, 함수를 컴포지션할 때마다 항상 처리해야 하는 작업이 있다거나, 실행 순서가 지켜져야 하는 작업이라면, 모나드가 딱입니다.</p>
<p>초창기 하스켈에는 모나드가 없었다고 하는데, 그 때는 IO 같은 작업을 어떻게 해결했을까 궁금하긴 합니다.</p>
<h3 id="컨텍스트">컨텍스트</h3>
<p>문장과 문장 사이, 행간으로 번역하기도 하고, 맥락이라고 번역하기도 하는데, 무언가 명시적으로 언급하진 않았지만 현재 작업을 할 때 영향을 미치는 환경, 상황 같은 걸 말합니다. 코딩에서는 어떤 모양으로 컨텍스트가 나타날까요? 같은 성격의 작업을 할 때마다 항상 반복해서 실행되는 코드가 바로 컨텍스트입니다.[3]</p>
<p>“컨텍스트를 이용해서 Side effect가 있는 함수와 같은 결과를 만들어낸다”라고 말해야지, “컨텍스트는 side effect를 의미한다”라고 하면 틀린 말입니다.</p>
<hr />
<p>[1] 가끔 Binary 함수를 이진 함수라 번역한 걸 만나는데, 이항 함수가 더 어울립니다. 두 개의 매개 변수를 가진 함수를 말합니다. unary는 단항, nullary는 매개 변수가 없는, “매개 변수가 몇 개인가?” = “arity가 몇이야?”</p>
<p>[2] 특별히 이 타입의 함수들이 모나드에 쓰일 때 “action”이라 부릅니다.</p>
<p>[3] 컨텍스트가 동작하도록 약속되어 있는 타입을 embellish 타입, 또는 fancy 타입이라고 부기도 합니다.</p>

<div id="disqus_thread"></div>
<script>

var disqus_config = function () {
this.page.url = 'https://lionhairdino.github.io/posts/2020-06-24-Monad.html';
this.page.identifier = 'posts/2020-06-24-Monad.markdown';
};
(function() {
var d = document, s = d.createElement('script');
s.src = 'https://lionhairdino.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
