<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>lionhairdino - 모나드 문턱에서</title>
        <meta name="description" content="Haskell,하스켈,해스클">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <meta property="og:type" content="website">
        <meta property="og:title" content="lionhairdino">
        <meta property="og:description" content="Haskell,하스켈,해스클">
        <meta property="og:url" content="https://lionhairdino.github.io">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">lionhairdino</a>
            </div>
            <div id="navigation">
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
        </div>

        <div id="content">
            <h1>모나드 문턱에서</h1>

            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on June 24, 2020
    
</div>

<p>모나드 기본 정의에 관한 포스트가 아닙니다. 모나드 설명은 검색으로 수 천개는 접할 수 있습니다. 이들 문서를 한 번 쯤은 봤고, 모나드를 어떻게 정의하는지가 아니라, 왜 모나드로 만드는지가 궁금한 분들에게 적당한 포스트입니다. 제 나름의 이해와 의문에 대해 적었습니다. 다른 포스트와 달리, <em>훨씬 더 검증이 필요한 내용</em>들입니다. 올리려면 좀 더 정리가 필요하지만, 현재 비슷한 진도에서 고민하고 있는 분들과 생각을 나누기 위해 먼저 올려 놓습니다.</p>
<h3 id="어원">어원</h3>
<p>unity, 산술 단위. 라틴어 monas, 그리스어 monas 에서 왔습니다. unit 이나 alone 을 뜻하던 단어였습니다.<br />
<a href="https://www.etymonline.com/word/monad" class="uri">https://www.etymonline.com/word/monad</a></p>
<h3 id="카테고리-이론과-하스켈의-닮은-점">카테고리 이론과 하스켈의 닮은 점</h3>
<p>람다 대수에서 모든 대상을 함수로 보고 대수 체계를 만들어 가 듯이 오로지 카테고리들끼리의 관계만으로 대수 체계를 만들어가는, 쉽지 않은 수학 이론입니다. 모나드, 펑크터의 어원etimology이 이 곳이구나 정도만 알고 지나가도 되지만, 이 곳에서 온 용어와 개념들이 많기 때문에 결국에는 입문정도는 해놔야 합니다.</p>
<p>오브젝트가 갖고 있는 어떤 속성도 관심없고, 한 구조안에 있는 오브젝트들끼리의 관계만 의미를 두는 이론입니다. (오브젝트는 그냥 관계의 출발점과 끝점을 표시하는 점으로만 보면 됩니다.) 하스켈은 함수를 품고 품어서 프로그램을 완성하므로, 모피즘 합성이라는 개념과 많이 닮아 있습니다. 하스켈의 한 데이터 구조를 대상으로 하는 함수들은 합성 능력이 있어야 쓸모가 있습니다.</p>
<p>모나드는 합성을 위한 패턴입니다.</p>
<h3 id="왜-모노이드로-만들까">왜 모노이드로 만들까?</h3>
<ul>
<li>항등원unit이 있고</li>
<li>binary 함수가 있고,</li>
<li>결합 법칙을 따르는 구조를</li>
</ul>
<p>모노이드라고 합니다.</p>
<ul>
<li>binary 함수[1]의 반복 적용으로 모든 원소 표현이 가능하다는 속성이 실용에서 어떤 역할을 할까요? total 함수임을 보장합니다. 또 한 이 구조에 있는 어떤 모피즘도 binary 함수를 몇 번 적용하면 얻을 수 있습니다. 컴포지션이 된다는 얘기입니다. “모노이드” 구조다라고 하면, 다른 함수를 정의하지 않아도 이미 <em>“컴포지션이 가능한 모피즘이 준비되어 있구나”</em>라는 뜻입니다.</li>
<li>결합 법칙을 따르지 않는다면 어떻게 될까요?<br />
결합 법칙을 따른다면, 실행 순서에 상관 없다는 얘기입니다. 하지만 실용 세계에서는 퍼포먼스 차이가 있으니, 권장되는 순서는 있습니다. 결합 법칙을 따른다면, 순서를 바꿔도 결과가 같다는 걸 보장하니, 퍼포먼스가 좋은 순서로 마음놓고 바꿀 수 있습니다.</li>
<li>항등원이 없으면, 실용 코드에서는 분기문 없이 아무일도 안하는 프로세스를 돌릴 수 없습니다. 가끔 무조건 돌고, 때에 따라 아무일도 안하는 게 (루프 마무리 같은 경우) 필요합니다. 1 + 0 을 하면 1이 됩니다. 1에서 1로 가는 모피즘입니다. 항등원이 있다는 말은 isomorphism이 존재한다는 말과 같습니다. 카테고리가 되려면 isomorphism이 있어야만 합니다.</li>
</ul>
<p>Binary 함수가 있어 모노이드가 되는 걸까요? 모노이드가 되려면 Binary 함수를 추가해야 하는걸까요? 같은 말이긴 한데, 이해하기 위해 길을 찾을 때는 다른 길입니다. 모노이드가 아닌 어떤 구조를 모노이드로 만들어 버리는 것과, 이미 구조가 있어 모노이드라 부르는 것, 두 말은 시점이 좀 다릅니다. 저는 모노이드의 속성을 얻기 위해 Binary 함수를 추가 하는 쪽으로 이해했습니다. 펑크터로 만들려면 fmap을 추가하고, 펑크터를 모나드로 만들려면 join, return 성격의 Natural transformation을 추가하는 겁니다.</p>
<p>펑크터로 만들면, 펑크터로 리프팅 되기 전에 쓰이던 함수들을 그대로 가져다 쓸 수 있고, 모나드로 만들면 펑크터들을 컴포지션 할 수 있습니다.</p>
<p><em>왜 카테고리로 만들려고 할까요?</em> 카테고리의 정의는 a-&gt;b , b-&gt;c 이면 반드시 a-&gt;c로 가는 함수가 존재합니다.카테고리란 말은 컴포지션을 할 수 있다라는 말입니다. 그런데, 오브젝트가 여러 개라면 그들 사이의 모피즘(함수)을 모두 정의해야 카테고리가 됩니다. 하지만 모노이달 카테고리로 만들면, 모피즘 하나만으로 모든 모피즘이 표현 가능하다는게 보장되므로 쉽게 카테고리가 됩니다. 하스켈의 모나드는 카테고리로 만들려고 하는게 아니라 모노이달 카테고리로 만들려고 하는 겁니다. 모노이달 카테고리가 되면 몇 번을 컴포지션하든 상관 없는 구조가 됩니다.</p>
<p>물론 다른 검증된 카테고리의 수학적 이론들을 적용할 수 있게 되겠지만, 프로그래머에게 제일 와닿는 특징은 컴포지션입니다.</p>
<h3 id="natural-transformation">Natural Transformation</h3>
<p>카테고리와 카테고리 매핑이 펑크터 (소스 카테고리의 모피즘을 다른 카테고리의 모피즘과 매핑하는 걸 펑크터<br />
펑크터와 펑크터 매핑은 Natural Transformation</p>
<h3 id="엔도펑크터-endofunctor">엔도펑크터 endofunctor</h3>
<p>~의 카테고리<br />
오브젝트가 Set 이고 모피즘이 집합간 함수인 카테고리를 “category of set” 이라 합니다. 하스켈 세계를 지칭하는 Hask 카테고리는 오브젝트가 타입이고 타입간 함수가 모피즘인 카테고리입니다. 엔도펑크터의 카테고리는 오브젝트가 엔도펑크터이고 모피즘이 Natural Transformation인 카테고리입니다.</p>
<p>소스 카테고리와 결과 카테고리가 같은 펑크터를 엔도펑크터라 합니다. Hask 카테고리(하스켈)에서 만나는 펑크터들은 결과가 Hask를 벗어나지 않기 때문에 모두 엔도펑크터입니다.</p>
<p>[1,2] 는 리스트 펑크터입니다. Functor의 리스트 인스턴스에 있는 fmap으로 (+5)를 적용하면</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">fmap</span> (<span class="op">+</span><span class="dv">5</span>) [<span class="dv">1</span>,<span class="dv">2</span>] <span class="ot">=</span> [<span class="dv">6</span>,<span class="dv">7</span>] </span></code></pre></div>
<p>결과는 다시 리스트 펑크터입니다. 리스트를 카테고리로 볼 수도 있고, Hask 안의 한 오브젝트로 볼 수도 있습니다. Hask -&gt; Hask 로 보든 List -&gt; List 로 보든, 어떻게 보든 자기 카테고리로 다시 돌아오니 엔도펑크터입니다. 카테고리 이론이 아니라, 하스켈에서는 fmap을 가진 타입을 펑크터라 하는데, Hask를 벗어나는 경우는 없으니, 하스켈에서 만나는 펑크터는 모두 엔도펑크터라 불러도 됩니다.</p>
<p>Some 타입을 정의하고, Some 타입의 컴포지션을 잘 정의하면 Some 카테고리로 볼 수도 있습니다. Maybe 카테고리, List 카테고리… 등 타입 하나가 컴포지션만 잘 정의되어 있으면 하나의 카테고리로 볼 수도 있습니다.</p>
<p>카테고리 안의 일부 오브젝트가 새로운 카테고리를 형성하기도 하고, 한 카테고리에 속한 오브젝트가 다른 카테고리에 속하는 것도 가능합니다. 카테고리는 조건이 몇 개 없는 굉장히 추상적인 구조입니다.</p>
<p>a -&gt; m b 타입은 함수일까요, 펑크터일까요, Natural Transformation 일까요? 세 개 다 맞습니다. a 타입에서 m b 타입으로 가는 함수로 볼 수 있고, a 카테고리의 구조를 유지하면서 m b 카테고리로 연결하는 펑크터로 볼 수도 있고, a 앞에 Id 펑크터가 생략됐다고 보고(Id a -&gt; m b) Id 펑크터에서 m 펑크터로 가는 Natural Transformation으로 볼 수도 있습니다.</p>
<p>카테고리와 카테고리를 매핑하는 함수를 펑크터라 부르기도 하고, 펑크터를 오브젝트로 해서 형성된 펑크터 카테고리를 그냥 펑크터라 부르기도 합니다. 하스켈에서는 fmap 만으론 오브젝트를 다른 커테고리의 오브젝트와 매핑하지 못하기 때문에 생성자를 추가해서, 이 생성자와 fmap이 있는 타입을 펑크터 타입이라 부릅니다. 그런데 이 것도 자료에 따라 그냥 펑크터라 부릅니다. 이런 혼란이 이해를 꽤 더디게 만들긴 합니다.</p>
<p>모나드를 얘기할 때는 a -&gt; m b 는 엔도펑크터로 봅니다. m은 fmap을 가지고 있는 펑크터 타입입니다.</p>
<h3 id="엔도펑크터의-모노이드">엔도펑크터의 모노이드</h3>
<p>엄밀히 용어를 따지면, 모노이드는 집합 쪽 용어이고, 이와 대응되는 카테고리 쪽 용어는 모노이달 카테고리입니다. 하지만 프로그래머 쪽 자료들에서는 엄밀하게 구분해서 쓰는 것 같지 않습니다.</p>
<p>func1 :: a -&gt; m b func2 :: b -&gt; m c … a , b, c 는 폴리모픽을 뜻하므로 대표 타입으로 a -&gt; m b 로 표기하겠습니다.</p>
<p>이런 함수들이 있을 때, 함수 하나 하나를 오브젝트로 보는 게 아니라 a -&gt; m b 를 오브젝트로 삼아 모노이달 카테고리를 만들어 봅시다.</p>
<p>오브젝트는 단 하나 a -&gt; m b 만 있습니다.<br />
오브젝트간 매핑을 하는 모피즘으로 a -&gt; m b 와 a -&gt; m b 를 받아 a -&gt; m b 를 돌려주는 binary가 있어야 합니다.<br />
항등원은 오브젝트가 하나니 a -&gt; m b 가 항등원입니다.<br />
결합법칙도 오브젝트가 하나니 결합을 어떻게 하든 결과는 a -&gt; m b 입니다.<br />
모노이달이다 보니, binary 함수만 신경쓰면 됩니다. binary 함수만 잘 정의하면 모노이달 카테고리가 되고, 모노이달 카테고리가 되면 binary 함수(모피즘)를 몇 번이고 합성할 수 있다는 얘기입니다.</p>
<p>“엔도펑크터의 모노이달 카테고리”(모노이드 성격의 카테고리, 오브젝트가 하나만 있는 카테고리)로 만들기 위해 join, return을 추가하면, 모피즘인 binary 함수를 만들 수 있습니다. join과 return이 없으면 모노이드 구조가 아니지만, 추가하면 모노이드 구조가 되는 걸 모나드라 합니다. 엔도펑크터 + return + join 이 있는 “구조”를 모나드라 합니다. 결국, 모나드는 엔도펑크터의 모노이달 카테고리입니다.</p>
<p>“A monad is just a monoid in the category of endofunctor”</p>
<p>모든 모노이드가 모나드는 아니지만, 모든 모나드는 모노이드입니다. 다시 말해, join, return이 없이 모노이드가 되는 구조는 모나드가 아닙니다.</p>
<p>컴포지션을 하기 위해, 모노이드 구조를 만드는게 목적입니다. 엔도펑크터 카테고리를 모노이드로 만들려고 join, return을 추가합니다.</p>
<p>하스켈에서 모나드 정의는 fmap, return, bind (이 건 join이나 Kleighsly arrow로 표현되기도 합니다.)가 정의되어 있는 타입입니다.</p>
<h3 id="연속으로-컴포지션-하려면-모노이달-카테고리에-있어야-한다.">연속으로 컴포지션 하려면 모노이달 카테고리에 있어야 한다.</h3>
<p>문서들이 “왜 이 개념이 필요한지” 목표를 명확히 써주면 좋을텐데, 대부분 카테고리 입문용 문서들이 <em>왜 그렇게 하는지</em> 이유를 쉽게 알려주지 않습니다. “이런 이런 모양이 펑크터야, 모노이드야, 모나드야” 라는 자료는 많지만, 왜 펑크터, 모노이드, 모나드로 만드는지 친절하게 목표를 풀어 주는 자료는 많지 않습니다.</p>
<p>join, return 성격의 Natural Transformation이 있다면, 엔도펑크터를 체이닝(연속 연결)할 수 있습니다. 다시 말해 모나드로 만들면 컴포지션 할 수 있습니다.</p>
<p>수학 용어를 걷어내면,<br />
a -&gt; m b 함수를 컴포지션 하려면 join이 필요합니다.<br />
다른 타입의 컴포지션과 달리 왜그리 중요한 역할을 하게 됐을까요?</p>
<h3 id="왜-a---m-b-타입-함수가-특별할까">왜 a -&gt; m b 타입 함수가 특별할까?</h3>
<p>m a -&gt; m b 타입[2]으로 함수를 만들면 복잡한 개념 없이 품고 품게composition 할 수 있지 않을까 생각이 듭니다. 하지만, m 컨텍스트에서 m 컨텍스트로 가면 품는 동안 반드시 m 컨텍스트가 발현된다는 보장이 없습니다. fmap이 동작하거나, 패턴 매칭이 나와야지만 Side effect가 드러납니다. m a 와 a -&gt; m b 함수를 받고, m a 에서 m 을 벗겨내는 작업을 해야만 a -&gt; m b 함수를 적용할 수 있습니다. 다시 말해, <em>컨텍스트가 반드시 발현</em>됩니다.</p>
<h3 id="컨텍스트">컨텍스트</h3>
<p>문장과 문장 사이, 행간으로 번역하기도 하고, 맥락이라고 번역하기도 하는데, 무언가 명시적으로 언급하진 않았지만 현재 작업을 할 때 영향을 미치는 환경, 상황 같은 걸 말합니다. 코딩에서는 어떤 모양으로 컨텍스트가 나타날까요? 같은 성격의 작업을 할 때마다 항상 반복해서 실행되는 코드가 바로 컨텍스트입니다.[3] 바인드 안에서 fmap을 불러 항상 컨텍스트 작업을 합니다.</p>
<p>“컨텍스트를 이용해서 Side effect가 있는 함수와 <em>같은 결과</em>를 만들어낸다”라고 말해야지, “컨텍스트는 side effect를 의미한다”라고 하면 틀린 말입니다.</p>
<h3 id="kleighsly-카테고리">Kleighsly 카테고리</h3>
<p>a -&gt; b 와 b -&gt; c 함수는 (.)으로 composition 할 수 있습니다.<br />
a -&gt; m b 와 b -&gt; m c 함수는 (&gt;=&gt;) 으로 composition 할 수 있습니다.</p>
<p>bind 를 (&gt;=&gt;)로 표현할 수도 있고, join 과 fmap 으로도 표현할 수 있습니다. 셋 중에 한 가지 방식만 정의되면, 모나드 역할을 할 수 있습니다.</p>
<h3 id="비순수-작업에-관여하는-부분만-떼어내-보면-모나드가-아니라-펑크터의-속성입니다.">비순수 작업에 관여하는 부분만 떼어내 보면 모나드가 아니라 펑크터의 속성입니다.</h3>
<p>Maybe의 컨텍스트인 “Nothing일 수도 있어” 라는 컨텍스트를 처리하는 건 펑크터의 fmap이 맡습니다. fmap에서 Nothing이냐, Just냐에 따라 분기가 일어납니다. 이렇게 분기가 일어난 결과를 <em>다음 작업과 연결하는 작업을 담당하는게 모나드</em>입니다. 모나드의 bind 구현을 보면 join이 fmap을 품은 형태입니다. fmap으로 Side effect를 발현시키고 나온 결과물을 다음 액션과 연결하기 위해(타입을 맞추기 위해) join을 씌우는 모양입니다.</p>
<h3 id="상태를-넘기는-영리한-방법이야">상태를 넘기는 영리한 방법이야?</h3>
<p>특정 모나드의 동작만 놓고, 이렇게 동작하는게 모나드야라고 설명한 말입니다. 사람이 앉아서 밥을 먹는 걸 봤다고, 앉아서 밥을 먹는 건 사람이야 라고 얘기하면 사람이 뭔지 알기 어렵습니다. “상태를 넘기는 걸 모나드 패턴으로 구현할 수도 있어”가 더 맞는 표현이라 생각합니다. 모나드를 특정 문제를 위한 패턴으로만 접근하면 꽤 멀리 돌아서 모나드에 도착할지도 모릅니다.</p>
<h3 id="모나드가-왜-수많은-난제들을-해결할까">모나드가 왜 수많은 난제들을 해결할까?</h3>
<p>함수가 함수를 품을때마다 반드시 fmap이 한 번씩 동작합니다. 체이닝할 때 매 번 뭔가 작업을 반복적으로 해야 한다면 딱 어울리는 패턴입니다.</p>
<p>Maybe는 컴포지션할 때마다 매 번 “Nothing 인지 검사하고”<br />
Status는 컴포지션할 때마다 매 번 “상태값을 액션에 넣어줘야 하고”<br />
Writer는 컴포지션할 때마다 매 번 “로그 ‘같은’ 값들을 계속 누적하고”<br />
IO는 컴포지션할 때마다 매 번 “Status처럼 런타임 상태값을 계속 끌고 다녀야 하고”<br />
…<br />
(거의 대부분 “순수 함수는 매개 변수로만 소통할 수 있다”라는 제약 때문에 등장한 난제들입니다.)</p>
<p>그리고 또 한가지,<br />
카테고리 이론 쪽에선 의도한게 아닐 것 같은데요, 모나드의 굉장히 중요한 성격이 있습니다. 하스켈은 Lazy한 함수들이 순차적으로 실행된다는 보장이 없습니다. 하지만 함수들이 품고 품은 상태로 엮인 상태에서, 현재 함수를 실행하려면 반드시 이전 단계 함수의 결과값이 꼭 필요한 상태가 되게 하면, 자연스럽게 함수들 사이에 실행 순서가 생깁니다. 모나드 패턴으로 엮을 때 이 효과가 자연스럽게 생깁니다. 수학에서 개념을 가져왔지만, 수학 개념에 없는 특징들도 나타납니다.</p>
<p>정리하면, 함수를 컴포지션할 때마다 항상 처리해야 하는 작업이 있다거나, 실행 순서가 지켜져야 하는 작업이라면, 모나드가 딱입니다.</p>
<p>초창기 하스켈에는 모나드가 없었다고 하는데, 그 때는 IO 같은 작업을 어떻게 해결했을까 궁금하긴 합니다.</p>
<h3 id="자신을-품고-있는-함수상위-함수의-매개-변수-값은-접근-할-수-있다.-closure">자신을 품고 있는 함수(상위 함수)의 매개 변수 값은 접근 할 수 있다. Closure</h3>
<p>람다 대수를 보면</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>𝜆x<span class="op">.</span>(𝜆y<span class="op">.</span>xy)</span></code></pre></div>
<p>𝜆y를 매개 변수로 갖고 있는 함수에서 𝜆x에 접근 할 수 있습니다. 𝜆x.( … ) 인 함수는 당연히 𝜆x를 … 에서 쓸 수 있어야 하니 당연한 결과입니다. 하스켈도 \x -&gt; (\y -&gt; x + y) 가 가능합니다. 매개 변수 이외에는 외부와 소통할 수 없는 함수형 프로그래밍에서의 함수에게는, 이 특징이 매우 유용하게 쓰입니다. 품고 품게 해서 엮은 함수들의 가장 바깥쪽에서 넣어 주는 인자값은, 그 함수 뭉치에서 전역값 같은 역할을 합니다.</p>
<h3 id="엮어-놓은-액션함수-뭉치-실행run">엮어 놓은 액션(함수) 뭉치 실행(run)</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>monadChain <span class="ot">=</span> runReader (<span class="kw">do</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>   <span class="op">...</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>   <span class="op">...</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>   ) env</span></code></pre></div>
<p>(…(…(…))) 이렇게 엮어 놓은 함수 뭉치는 블랙박스로 바라보면 (…) 하나의 함수일 뿐입니다.</p>
<p>do 이하 구문들은 여러 개의 bind로 품고 품게 되어 있는 함수 뭉치입니다. 아직 실행되지 않은, 언젠가 실행될 하나의 함수입니다. 이 뭉치의 가장 바깥쪽 함수에 env 를 넣어주면서, 그제서야 함수 뭉치의 실행이 “시작”됩니다. 그래서 모나드들이 레코드 필드 접근자의 이름을 run~ 이라고 짓는 경우가 많습니다.</p>
<hr />
<p>[1] 가끔 Binary 함수를 이진 함수라 번역한 걸 만나는데, 이항 함수가 더 어울립니다. 두 개의 매개 변수를 가진 함수를 말합니다. unary는 단항, nullary는 매개 변수가 없는, “매개 변수가 몇 개인가?” = “arity가 몇이야?”</p>
<p>[2] 특별히 이 타입의 함수들이 모나드에 쓰일 때 “action”이라 부릅니다.</p>
<p>[3] 컨텍스트가 동작하도록 약속되어 있는 타입을 embellish 타입, 또는 fancy 타입이라고 부르기도 합니다.</p>

<div id="disqus_thread"></div>
<script>

var disqus_config = function () {
this.page.url = 'https://lionhairdino.github.io/posts/2020-06-24-Monad.html';
this.page.identifier = 'posts/2020-06-24-Monad.markdown';
};
(function() {
var d = document, s = d.createElement('script');
s.src = 'https://lionhairdino.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
