<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">

<head>
  <script>
    (function () {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark') {
        document.documentElement.classList.add('dark-mode');
      }
    })();

    function loadUtterances() {
      const savedTheme = localStorage.getItem('theme');
      const themeValue = savedTheme === 'dark' ? 'github-dark' : 'github-light';

      console.log("theme");
      console.log(themeValue);
      const script = document.createElement('script');
      script.src = 'https://utteranc.es/client.js';
      script.setAttribute('repo', 'lionhairdino/lionhairdino.github.io');
      script.setAttribute('issue-term', 'url');
      script.setAttribute('theme', themeValue);
      script.setAttribute('crossorigin', 'anonymous');
      script.async = true;
      document.body.appendChild(script);
    };

    function updateUtterancesTheme() {
      const savedTheme = localStorage.getItem('theme');
      const themeValue = savedTheme === 'dark' ? 'github-dark' : 'github-light';

      // Utterances iframe에 메시지 전송
      const utterances = document.querySelector('.utterances iframe');
      if (utterances) {
        utterances.contentWindow.postMessage(
          {type: 'set-theme', theme: themeValue},
          'https://utteranc.es'
        );
      }
    }

  </script>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>lionhairdino - 닉스로 하스켈 프로젝트 빌드 (스케치 중)</title>
  
  <meta name="description" content="닉스로 하스켈 프로젝트 빌드하기" />
  <meta property="og:description" content="닉스로 하스켈 프로젝트 빌드하기" />
  
  <link rel="stylesheet" type="text/css" href="../css/default.css" />
  <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
  <link rel="shortcut icon" href="../favicon.ico" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
  <link rel="manifest" href="../site.webmanifest" />
  <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
  <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
  <meta name="msapplication-TileColor" content="#ff7500" />
  <meta name="theme-color" content="#ffffff" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="닉스로 하스켈 프로젝트 빌드 (스케치 중)" />
  <meta property="og:site_name" content="Lionhairdino" />
  <meta property="og:url" content="https://lionhairdino.github.io/posts/2025-03-07-haskell_nix.html" />
  
  <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />
  
  
  <meta name="keywords" content="Nix, 닉스, haskell, 하스켈">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-E9WZ6VXGHP');
  </script>
  <script src="../script/copycode.js"></script>

  <script src="../script/darkmode.js"></script>
  <script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
  <meta name="fediverse:creator" content="@lionhairdino@mastodon.social" />
  <link rel="alternate" type="application/rss+xml" title="상상 하스켈 - Lionhairdino" href="rss.xml" />
</head>

<body>
  <div id="header">
    <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
      <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
    </div>
    <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
      <a href="../">lionhairdino</a>
      <a href="../about.html">about</a>
      <!--<a href="/archive.html">archive</a>-->
    </div>
    <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
      <div style="display:inline-block;vertical-align: top;padding-top: 5px"></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:18px;border:none" src="../images/bluesky.svg"></a>
      </div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://discordapp.com/users/lionhairdino#7687"><img style="width:20px;border:none" src="../images/discord.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://x.com/lionhairdino"><img style="width:15px;border:none" src="../images/X.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://linkedin.com/in/lionhairdino-l-baaa54244"><img style="width:20px;border:none" src="../images/linkedin.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://github.com/lionhairdino"><img style="width:20px;border:none" src="../images/github.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://www.threads.net/@linohairdino"><img style="width:20px;border:none" src="../images/threads.svg"></a></div>
    </div>
    <div>
      <div style="display:inline-block;width:180px;">
        <div class="gcse-searchbox-only"></div>
        <div><button id="theme-toggle">
            <script>
              const savedTheme = localStorage.getItem('theme');
              if (savedTheme === 'dark')
                document.write("☉");
              else
                document.write("☾");
            </script>
          </button></div>
      </div>
    </div>
    <div>
      여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다. 여기 글을 처음 읽는 분은, 먼저 <a href="../warning.html">주의문</a>을 꼭 읽어보세요.
    </div>
  </div>
  <div class="js-toc-content">
    <h1>닉스로 하스켈 프로젝트 빌드 (스케치 중)</h1>
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on March  7, 2025
    
</div>

<h2 id="nixpkgs에-있는-하스켈-언어-프레임-워크">nixpkgs에 있는 하스켈 언어 프레임 워크</h2>
<p><a href="https://github.com/NixOS/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md">하스켈 언어 프레임 워크</a></p>
<p>빠르게 보기</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>&gt; nix-env -i cabal2nix cabal-install</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>&gt; cabal2nix . &gt; default.nix</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>&gt; cabal2nix --shell . &gt; shell.nix</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>&gt; nix-shell --command 'cabal configure'</span></code></pre></div>
<p><strong>cabal2nix</strong>
프로젝트 <code>.cabal</code> 파일에서 의존성 정보를 가져오고, <code>nixpkgs</code> <code>haskellPackages</code> 컬렉션에서 원하는 것들을 가져오며 의존성을 풀어갑니다.</p>
<h3 id="nixpkgs-바로-아래-있는-툴">nixpkgs 바로 아래 있는 툴</h3>
<p>하스켈만을 위한 툴 <code>ghc</code>,<code>cabal-install</code>, <code>stack</code>, <code>hpack</code>, <code>niv</code>, <code>cachix</code>, …<br />
위 툴들은 특별히 설치하지 않아도 <code>nixpkgs</code> 탑레벨에서 제공 된다.</p>
<h3 id="pkgs.haskell.lib-아래-있는-라이브러리">pkgs.haskell.lib 아래 있는 라이브러리</h3>
<ul>
<li><p><strong>callCabal2nix name src args</strong><br />
<code>cabal2nix</code>를 써서 <code>src</code> 소스 <code>derivation</code>으로부터 <code>name</code> 이름의 패키지를 생성한다. <code>haskellPackages.callPackage</code>에 추가적으로 넘길 인자가 있으면 <code>args</code>를 쓴다.</p></li>
<li><p><strong>callCabal2nixWithOptions name src opts args</strong><br />
<code>opts</code>가 문자열이면 <code>cabal2nix</code>의 특별 명령줄 인자로 쓰인다.<br />
<code>extraCabal2nixOptions</code><br />
<code>srcModfier</code></p></li>
<li><p><strong>overrideCabal f drv</strong><br />
기존 하스켈 패키지의 cabal 정의에 새로운 속성을 추가할 때 쓴다. 결과적으로 수정된 새로운 패키지를 생성한다.</p></li>
<li><p><strong>callHackageDirect</strong><br />
닉스에서 하스켈 패키지를 직접 가져오는 함수. 특별히 뭐를 하지 않고, 그냥 Hackage에서 다운로드 해서, 닉스 빌드 시스템에 통합시킨다. Hackage에 있는 정확한 버전을 고정. 하스켈에서 하지 않고, 닉스단에서 지정하는 방식이라 nix-stroe에 저장되니, 재다운로드를 덜 하게 된다.</p></li>
<li><p><strong>doJailbreak</strong></p></li>
<li><p><strong>dontCheck</strong>
테스트를 통과하지 못해 빌드를 실패할 경우, 테스트를 건너 띄게 할 수 있다.</p></li>
<li><p><strong>jailbreakUnbreak</strong>
<code>cabal</code> 버전 제약만 제거한다.</p></li>
</ul>
<p>아래는 Reflex 공식 홈에 있는 <a href="https://reflex-frp.org/tutorial">예시</a>를 빌드하는 <code>haskell.nix</code>입니다.<br />
※ 2025.3 master 브랜치가 아니라, <a href="https://github.com/obsidiansystems/calculator-tutorial/tree/enhance/ob-9.0.1">enhance/ob-9.0.1 브랜치</a>를 가져와서 빌드 성공했다.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">obelisk</span> <span class="op">?</span> <span class="bu">import</span> <span class="ss">./.obelisk/impl</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">system</span> <span class="op">=</span> <span class="bu">builtins</span>.currentSystem<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">iosSdkVersion</span> <span class="op">=</span> <span class="st">&quot;10.2&quot;</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> obelisk<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>project <span class="ss">./.</span> <span class="op">({</span> <span class="va">pkgs</span><span class="op">,</span> <span class="va">hackGet</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span>:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> pkgs.haskell.lib<span class="op">;</span> <span class="op">{</span> <span class="co"># 하스켈 프로젝트를 빌드할 때 쓰는 라이브러리</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 아래, packages, overrides 같은 속성들은 Nixpkgs에 정의된 하스켈 관련 스펙이다.</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="va">android</span>.<span class="va">applicationId</span> <span class="op">=</span> <span class="st">&quot;systems.obsidian.obelisk.examples.minimal&quot;</span><span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="va">android</span>.<span class="va">displayName</span> <span class="op">=</span> <span class="st">&quot;Obelisk Minimal Example&quot;</span><span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="va">ios</span>.<span class="va">bundleIdentifier</span> <span class="op">=</span> <span class="st">&quot;systems.obsidian.obelisk.examples.minimal&quot;</span><span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="va">ios</span>.<span class="va">bundleName</span> <span class="op">=</span> <span class="st">&quot;Obelisk Minimal Example&quot;</span><span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="va">__closureCompilerOptimizationLevel</span> <span class="op">=</span> <span class="cn">null</span><span class="op">;</span> <span class="co"># 클로저 컴파일러가 뭐지?</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 구글에서 만든 JS 컴파일러라 한다. 최적화 수준을 지정. null이면 안한다는 뜻</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 아마도 Reflex 코드를 GHCJS가 뽑아내면 그 다음 이게 돌지 않을까?</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 프로젝트에서 사용할 Nixpkgs에 없는 하스켈 패키지를 추가할 때</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 주로 pkgs.haskellPackages.callCabal2nix와 같이 cabal파일을 이용하여 패키지를 불러오는</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 함수를 사용한다. Cabal 패키지 설정을 Nix 표현식으로 변환하여 Nix가 하스켈 프로젝트의</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 의존성을 관리하도록 한다. .cabal 파일에서 의존성, 빌드 옵션, 소스 파일들을 분석해서</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Nix 표현식을 생성, Nix가 패키지를 빌드한다.</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>  <span class="va">packages</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="va">mmark</span> <span class="op">=</span> hackGet <span class="ss">./dep/mmark</span><span class="op">;</span> <span class="co"># 소스 코드를 지정한 곳(로컬, 인터넷 주소...)에서 가져 온다.</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>          <span class="co"># hackGet : 원래 있던 건 아니고, obelisk에서 추가 했다. </span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>          <span class="co"># 하스켈 패키지를 가져오는데 쓴다.</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 위는 nixpkg에 없는 패키지를 추가하고,</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 아래는 nixpkg에 있는 패키지를 덮어 씌운다.</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 그런데 위아래 모두 mmark를 가지고 있다. </span><span class="al">TODO</span><span class="co">: overrides에만 있으면 되는 것 아닌가?</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 주로 pkgs.haskell.lib.overrideCabal과 같은 함수를 사용하여 cabal 패키지 설정을 오버라이드</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>  <span class="va">overrides</span> <span class="op">=</span> <span class="va">self</span><span class="op">:</span> <span class="va">super</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span class="va">temporary</span> <span class="op">=</span> dontCheck super.temporary<span class="op">;</span> <span class="co"># dontCheck : 테스트 단계에서 checkPhase를 비활성화</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="va">email-validate</span> <span class="op">=</span> dontCheck super.email<span class="op">-</span>validate<span class="op">;</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="va">mmark</span> <span class="op">=</span> doJailbreak <span class="op">(</span>dontCheck <span class="op">(</span><span class="kw">if</span> <span class="op">(</span>self.ghc.isGhcjs <span class="kw">or</span> <span class="cn">false</span><span class="op">)</span> </span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>                                    <span class="kw">then</span> dontHaddock super.mmark <span class="kw">else</span> super.mmark<span class="op">));</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">## doJailbreak : 하스켈 패키지 의존성 제약을 무시, 버전 범위 지정을 무시</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    <span class="va">modern-uri</span> <span class="op">=</span> doJailbreak <span class="op">(</span>dontCheck <span class="op">(</span>self.callHackageDirect <span class="op">{</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">pkg</span> <span class="op">=</span> <span class="st">&quot;modern-uri&quot;</span><span class="op">;</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">ver</span> <span class="op">=</span> <span class="st">&quot;0.3.4.4&quot;</span><span class="op">;</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>        <span class="va">sha256</span> <span class="op">=</span> <span class="st">&quot;19qwfrida77mxix4v41qyvanfxy8qljg4fxz9ccxlcjdbks5v6pa&quot;</span><span class="op">;</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="op">{}));</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span class="va">lucid</span> <span class="op">=</span> dontCheck <span class="op">(</span>self.callHackageDirect <span class="op">{</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        <span class="va">pkg</span> <span class="op">=</span> <span class="st">&quot;lucid&quot;</span><span class="op">;</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        <span class="va">ver</span> <span class="op">=</span> <span class="st">&quot;2.11.1&quot;</span><span class="op">;</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        <span class="va">sha256</span> <span class="op">=</span> <span class="st">&quot;035idsv283s6484wyb8yndzw4rbyivvz6b3cwxan2cf0xd3s78dk&quot;</span><span class="op">;</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="op">{});</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    <span class="va">markdown-unlit</span> <span class="op">=</span> self.callHackageDirect <span class="op">{</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>      <span class="va">pkg</span> <span class="op">=</span> <span class="st">&quot;markdown-unlit&quot;</span><span class="op">;</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>        <span class="va">ver</span> <span class="op">=</span> <span class="st">&quot;0.5.1&quot;</span><span class="op">;</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>        <span class="va">sha256</span> <span class="op">=</span> <span class="st">&quot;194g4f12xpvdp9yr16ngxx6w9kmpvilkivvag3drpc8cv15csp8l&quot;</span><span class="op">;</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="op">{};</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># super.frontend는 원래의 frontend 패키지 정의</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># overrideCabal 기존 cabal 패키지의 속성을 수정할 때 사용하는 닉스 함수</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># drv : 기존 패키지(super.frontend)의 속성</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># drv.buildTools 속성을 수정하여 새로운 빌드 추가</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 닉스가 빌드할 때 buildTools에 있는 것들을 PATH에 추가한다.</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 실제 실행시키는 곳은 Setup.hs 또는 *.cabal 설정에서 실행시킨다.</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (drv: {   }) 기존 패키지 속성을 변경하는 람다 함수. </span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 기존 derivation에 buildTools란 속성을 바꾸고 있다.</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    <span class="va">frontend</span> <span class="op">=</span> overrideCabal super.frontend <span class="op">(</span><span class="va">drv</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>      <span class="va">buildTools</span> <span class="op">=</span> <span class="op">(</span>drv.buildTools <span class="kw">or</span> <span class="op">[])</span> <span class="op">++</span> <span class="op">[</span> self.buildHaskellPackages.markdown-unlit <span class="op">];</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span></code></pre></div>
<p>※ <code>with obelisk;</code>라 하면, 다음 한 표현식 스코프안으로 <code>obelisk</code>가 가진 것들을 가져 온다.</p>
<h2 id="super-simple-haskell-development-with-nix">Super-Simple Haskell Development with Nix</h2>
<p><a href="https://github.com/mhwombat/nix-for-numbskulls/blob/78bcc186f79931c0e4a1e445e2f6b1f12f6d46be/Haskell/ss-haskell-dev.md">원문</a>
많은 튜토리얼들이 niv, binary cache, flakes, Stack 등의 빌드툴을 쓰라하는데, 빌드 툴을 최소화 해보자.<br />
<code>default.nix</code>를 아래와 같이 작성한다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{</span> <span class="op">};</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  pkgs.haskellPackages.개발중인패키지<span class="op">(</span>현재 폴더명과 같게<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">root</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">source-overrides</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>      <span class="va">grid</span> <span class="op">=</span> <span class="ss">../grid</span><span class="op">;</span> <span class="co"># haskellPackages에 있는 grid 오버라이드</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>※ TODO <code>./</code>와 <code>./.</code>는 둘 다 현재 디렉토리를 뜻하고, 대부분의 경우 차이가 없다고 하는데? 아직 어떤 차이점이 있는지 모른다.<br />
</p>
<p><code>default.nix</code> 파일에, 쉘에 들어갔을 때 쓸 패키지들의 버전을 지정할 수도 있고, <code>cabal.project</code>에 지정할 수도 있다. <code>cabal.project</code>를 안 쓰고, <code>default.nix</code>에 버전을 지정하면, 간단히 쉘을 빠져 나왔다 다시 들어가면 된다.</p>
<ul>
<li><code>nix-build</code>를 실행</li>
<li><code>nix-shell</code>을 실행. 모든 의존성이 유효한 상태의 쉘에 들어가고, <code>cabal</code> 명령어들을 쓸 수 있다.</li>
</ul>
<h3 id="실행-가능한-하스켈-스크립트-만들기">실행 가능한 하스켈 스크립트 만들기</h3>
<p>하스켈 소스 파일에 아래 내용을 제일 처음에 추가한다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#! /usr/bin/env nix-shell</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#! nix-shell -p &quot;haskellPackages.ghcWithPackages (p: [p.pandoc])&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#! nix-shell -i runghc</span></span></code></pre></div>
<p>※ <code>ghcWithPackages</code> GHC와 특정 패키지를 함께 제공하는 유틸리티다.<br />
(멀티 ghc 버전 지원, pure/impure nix-shell 지원, 멀티 패키지가 유효한 상태의 쉘에 들어간다?)<br />
※ 아마도 지금은 <code>gw</code>라 이름을 바꾼 것 같다.</p>
<p>Nix에는 두 가지 <code>nix-shell</code> 모드가 있다.<br />
- pure : <code>nix-shell --pure</code><br />
Nix에서 제공하는 패키지만 사용하고, 시스템 환경 변수나 글로벌 설정을 쓰지 않는다.
- impure : <code>nix-shell --impure</code><br />
시스템 환경 변수도 접근 가능<br />
예를 들어 <code>/usr/bin/ghc</code>가 있다면, 그 것도 사용 가능<br />
그래서, 재현성은 더 떨어질 수도 있다.</p>
<h2 id="practical-nix-flakes">Practical Nix Flakes</h2>
<p>Flake가 활성화된 닉스를 “flake-y” 닉스라 부르기도 한다.<br />
<a href="https://serokell.io/blog/practical-nix-flakes">세로켈 블로그 - 실용 닉스 플레이크</a><br />
최소한의 Nix언어 문법과, 간단한 Flake 설명 후에 하스켈 패키지 설치하는 방법에 대해 얘기한다.</p>
<p>세로켈 깃헙 저장소에서 제공하는, <code>cabal2nix</code>를 쓰는 템플릿을 이용해, 기본적인 flake 파일을 생성한다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>nix flake init -t github:serokell/templates#haskell-cabal2nix</span></code></pre></div>
<p>※ haskell-flake를 쓸 때는 srid 계정에 있는 템플릿을 쓴다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>nix flake init -t github:srid/haskell-flake</span></code></pre></div>
<p><strong>nix shell</strong> 실행이 가능한 패키지들을 <code>$PATH</code>에 등록</p>
<p>가능한 URI 모양</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>github:owner/repo/[revision or branch]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>gitlab:owner/repo/[revision or branch]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>https://example.com/path/to/tarball.tar.gz</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>git+https://example.com/path/to/repo.git</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>git+ssh://example.com/path/to/repo.git</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>file:///path/to/directory</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>/path/to/directory</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>./path/to/relative/directory</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>flake-registry-value</span></code></pre></div>
<p>어디에 설치 됐는지 궁금할 때</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>&gt; command -v hello</span></code></pre></div>
<p>hello 빌드에 필요한 모든 환경 설정이 같이 올라오게 하려면, <strong>nix develop</strong></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>&gt; nix develop nixpkgs#hello</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>&gt; unpackPhase -- 소스 풀고</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>&gt; cd hello-2.12.1</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>&gt; configurePhase -- configure 스크립트를 돌리고</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>&gt; buildPhase -- 빌드</span></code></pre></div>
<p><strong>nix profile</strong> nix-env의 대체</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>&gt; nix profile install nixpkgs#hello</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>&gt; nix profile list</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>&gt; nix profile update hello</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>&gt; nix profile remove hello</span></code></pre></div>
<p><strong>nix flake</strong></p>
<p><code>flake</code> URI를 받아 <code>flake</code>의 출력을 트리 구조로 그려 준다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>&gt; nix flake show github:nixos/nixpkgs</span></code></pre></div>
<p><code>nix flake clone</code> flake 소스를 로컬 디렉토리에 복사한다. <code>git clone</code>과 비슷.</p>
<p><code>nix flake lock</code> (이전 <code>nix flake update</code>)</p>
<h2 id="haskell.nix">haskell.nix</h2>
<p><a href="https://input-output-hk.github.io/haskell.nix/index.html">haskell.nix</a> Cabal 프로젝트나 Stack 프로젝트를 Nix 코드로 자동 번역한다. Nixpkgs의 haskellPackages를 쓰지 않는, 독립적인 패키지 관리시스템으로 <code>cabal-install</code>이나 <code>stack</code>과의 호환성에 중점을 두고 설계되었다.<br />
※ 이 동네 특징인 것 같은데, 설정 파일 이름도 <code>haskell.nix</code>고, 이 <code>haskell.nix</code> 파일을 읽어 해석하는 Nix 모듈 이름도 <code>haskell.nix</code>라 부른다.</p>
<blockquote>
<p>Cyclic dependencies</p>
<p>nixpkgs에 있는 하스켈 빌더는 패키지 레벨로 패키지를 드러낸다. 패키지들이 테스트와 라이브러리로 서로 의존하고 있는 상태면 닉스가 해결하지 못하는 순환cyclic 의존성이 생긴다. By exposing the components to nix as separate derivations this will only occur if you have mutually dependent components.</p>
</blockquote>
<div class="sourceCode" id="cb12"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>                                             .-------------.     .-------------.</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>.- nix-tools ------.                         | haskell.nix |  .- | hackage.nix |</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>| .--------------. |   .----------------.    '-------------'  |  '-------------'</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>| | stack-to-nix |---&gt; | stack-pkgs.nix |-.         |         |         |</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>| '--------------' |   '----------------' |         v         |         v</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>| .-------------.  |   .----------.       '--&gt; .----------. &lt;-'  .--------------.</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>| | plan-to-nix |----&gt; | plan.nix |------.---&gt; | pkgs.nix | &lt;--- | stackage.nix |</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>| '-------------'  |   '----------'      |     '----------'      '--------------'</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>| .--------------. |   .--------------.  |          |</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>| | cabal-to-nix |---&gt; | $package.nix |--'          v</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>| '--------------' |   '--------------'       .-------------.</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>'------------------'                          | default.nix |</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>                                              '-------------'</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>                                                    |</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>                                                    v</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>                                              .-------------.</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>                                              | release.nix |</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>                                              '-------------'</span></code></pre></div>
<p><strong>nix-tools</strong>는 다음 하스켈 패키지들을 가지고 있다.<br />
<strong>cabal-to-nix</strong>: 조건부 표현식을 유지retain?하며 <code>.cabal</code>을 <code>.nix</code>로 변환하는 트랜스포머.<br />
※ 조건부 표현식 유지? - nix로 옮길 때 cabal에서 쓰던 조건부 표현식들이 사리지지 않는다는 뜻<br />
<strong>stack-to-nix</strong>: <code>stack.yaml</code>을 <code>.nix</code>로 변환하는 트랜스포머. <code>stack.yaml</code>에 있는 표현식을 읽어 <code>haskell.nix</code>에 적합한 <code>pkgs.nix</code> 파일을 만든다.<br />
<strong>plan-to-nix</strong>: <code>plan.json</code>을 <code>.nix</code>로 변환하는 트랜스포머. <code>plan.json</code>을 읽어 <code>pkgs.nix</code> 파일을 만든다.</p>
<ul>
<li><code>haskell.nix</code> 하스켈 인프라를 위한 런타임 시스템이다.</li>
<li><code>hackage.nix</code> hackage에 있는 모든 cabal 표현식을 닉스 표현식으로 제공한다. hackage에 있는 패키지셋과 동기화하기 위해 주기적으로 업데이트 된다.</li>
<li><code>stackage.nix</code> 모든 stackage 스냅샷을 닉스 표현식으로 제공한다. haskage.nix에 의존</li>
</ul>
<p><strong>Niv</strong><br />
닉스 프로젝트 의존성을 트래킹하는 명령줄 도구다. flake를 쓰려면 안봐도 된다고 한다. 일단 패스.</p>
<p><code>stack.yaml</code>과 <code>cabal.project</code> 기반 프로젝트와 작동한다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Niv 소스를 읽어들인다.</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">sources</span> <span class="op">=</span> <span class="bu">import</span> <span class="ss">./nix/sources.nix</span> <span class="op">{};</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ./nix/sources.nix 파일이 없으면, 다음을 실행</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">#   niv init</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">#   niv add input-output-hk/haskell.nix -n haskellNix</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Niv로 고정한 haskell.nix commit을 가져 온다.</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span class="va">haskellNix</span> <span class="op">=</span> <span class="bu">import</span> sources.haskellNix <span class="op">{};</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># haskellNix가 없으면 다음을 실행</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">#   niv add input-output-hk/haskell.nix -n haskellNix</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># nixpkgs를 불러오고 haskell.nix 에서 제공하는 nixpkgsArgs 전달한다.</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># haskell.nix provides access to the nixpkgs pins which are used by our CI,</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># hence you will be more likely to get cache hits when using these.</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># But you can also just use your own, e.g. '&lt;nixpkgs&gt;'.</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    haskellNix.sources.nixpkgs<span class="op">-</span>unstable</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># These arguments passed to nixpkgs, include some patches and also</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># the haskell.nix functionality itself as an overlay.</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    haskellNix.nixpkgsArgs<span class="op">;</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span> pkgs.haskell<span class="op">-</span>nix.project <span class="op">{</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 'cleanGit' cleans a source directory based on the files known by git</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>  <span class="va">src</span> <span class="op">=</span> pkgs.haskell<span class="op">-</span>nix.haskellLib.cleanGit <span class="op">{</span></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;haskell-nix-project&quot;</span><span class="op">;</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    <span class="va">src</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 사용할 GHC 버전 지정.</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>  <span class="va">compiler-nix-name</span> <span class="op">=</span> <span class="st">&quot;ghc925&quot;</span><span class="op">;</span> <span class="co"># `stack.yaml`기반 프로젝트에선 필요 없다.</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="flake-y-nix-에서-haskell.nix-사용하는-방법">flake-y nix 에서 haskell.nix 사용하는 방법</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>nix flake init --template templates#haskell-nix --impure</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a># `--impure` is required by `builtins.currentSystem`</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>nix develop</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>cabal build</span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>nix flake show</span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>nix build .#hello:exe:hello</span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>nix run .#hello:exe:hello</span></code></pre></div>
<h3 id="hix">Hix</h3>
<p>기존 하스켈 프로젝트에 <code>haskell.nix</code> 지원을 추가하는 간편한 방법을 제공하는 명령줄 도구<br />
<code>hix init</code> 명령은 <code>flake.nix</code>와 <code>nix/hix.nix</code>파일을 추가한다. 이렇게 하면, 프로젝트를 보통의 nix 도구들로 작업할 수 있게 된다.<br />
</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>cabal unpack hello</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>cd hello-1.0.0.2</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>nix run &quot;github:input-output-hk/haskell.nix#hix&quot; -- init</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>nix develop</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>cabal build</span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>nix flake show</span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>nix build .#hello:exe:hello</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>nix run .#hello:exe:hello</span></code></pre></div>
<p>다른 Hix 특징들을 쓰려면 Hix를 설치한다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>nix-env -iA hix -f https://github.com/input-output-hk/haskell.nix/tarball/master</span></code></pre></div>
<p>최신 버전을 쓰려면</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>hix update</span></code></pre></div>
<p><code>hix develop</code>, <code>hix flake</code>, <code>hix build</code>, <code>hix run</code> 등, <code>nix</code>를 쓰듯 쓰는 게 인상적이다. 분명 nix flake에 익숙하다면 장점이 될 것 같다.</p>
<p>이들 명령은 <code>flake.nix</code>를 쓰지 않고, 닉스 버전과 동일하게 작동한다는데, 무슨 말이지? hix는 flake를 쓰는 것 아니었나?
프로젝트 루트에 <code>flake.nix</code> 파일을 만들지 않아도, <code>flake.nix</code> 파일이 있을 때 <code>nix ***</code> 명령을 사용하듯 <code>hix ***</code>를 사용할 수 있다는 뜻이다. hix는 <code>.hix-flake/flake.nix</code> 에서 자동으로 관리하고, 사용자가 직접 관리할 필요가 없다. 직접 <code>flake.nix</code> 파일을 만들고 유지하고 싶지 않을 때 쓰기 좋다. (반면, haskell-flake는 프로젝트 루트에 <code>flake.nix</code> 파일을 직접 만들고 유지해야 한다.)</p>
<p>hix는 <code>haskell.nix</code> 스타일을 쓰면서, 필요할 때 <code>.hix-flake/flake.nix</code> 내부에서 flakes를 관리한다.</p>
<h2 id="haskell-support-for-nix">Haskell Support for Nix</h2>
<p><a href="https://haskell4nix.readthedocs.io/">haskell4nix</a><br />
Flake를 쓰지 않고, 하스켈 패키지를 닉스로 설치하는 방법<br />
Hackage에 등록되어 있는 모든 하스켈 패키지를 위한 빌드 지침instruction을 배포 중이다. 그런데, 닉스 패키지 검색을 하면, ghc, cabal-install, stack 말고는 나오는 게 없다. 하스켈 패키지는 너무 많아서 탑레벨 네임 스페이스에 등록되어 있지 않다. 탑레벨에 두면 검색이 너무 느려져서 haskellPackages 속성으로 분리되어 있다.</p>
<h2 id="haskell-flake">haskell-flake</h2>
<p><a href="https://github.com/srid/haskell-flake">srid/haskell-flake</a><br />
<a href="https://flake.parts/">flake-parts</a> 모듈로 셋업한다. Cabal만 지원한다.(Stack은 지원하지 않는 것 같다.) 프로젝트 탑레벨에 <code>.cabal</code>이나 <code>cabal.xproject</code>가 있어야만 한다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>&gt; mkdir example &amp;&amp; cd ./example</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>&gt; nix flake init -t github:srid/haskell-flake#example</span></code></pre></div>
<h2 id="하스켈-프로젝트-닉스화nixifying">하스켈 프로젝트 닉스화Nixifying</h2>
<p>아래는 <a href="https://nixos.asia/en/haskell">nixos.asia</a> 페이지를 정리한 노트이다.</p>
<h3 id="프로젝트-닉스화">프로젝트 닉스화</h3>
<p><strong>haskellPackages</strong></p>
<p><strong>callCabal2nix</strong><br />
<code>cabal2nix</code>를 써서 <code>.cabal</code> 파일을 읽어들여 Nix derivation으로 만든다.</p>
<p>※ 뜬금없이 예시를 따라하다 <code>nix repl</code> 멀티라인에서 막혔다.<br />
원문 예시 중 <code>repl</code>에서 멀티라인 입력이 필요한 부분이 있는데, 원문을 따라하면 입력이 되지 않는다. repl은 구문이 끝났는지, 안 끝났는지 추론해서 결정한다. 예전엔 <code>extend</code>함수로 끝난 첫 줄이, 아직 덜 끝난 걸로 인식했었나 본데, 지금은 그렇지 않다. <code>extend</code> 뒤에 아직 구문이 끝나지 않았다는 표시로 <code>(</code>를 써준다.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>nix-repl&gt; myHaskellPackages = pkgs.haskellPackages.extend </span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    (self: super: {</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>       shower = self.callCabal2nix &quot;shower&quot; </span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>         (pkgs.fetchgit { </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>            url = &quot;https://github.com/monadfix/shower.git&quot;;</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>            rev = &quot;2d71ea1&quot;; </span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>            sha256 = &quot;sha256-vEck97PptccrMX47uFGjoBVSe4sQqNEsclZOYfEMTns=&quot;; </span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>         }) {}; </span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    })</span></code></pre></div>
<p><code>extend</code>함수가 인자로 <code>self: super: { ... }</code> 람다 함수를 받고 있다. <code>super</code>에는 확장되기 이전의 패키지 집합이 들어가고, <code>self</code>는 확장된 이후의 패키지 집합이 들어간다. (아마도 이렇게 되려면 fix 패턴을 쓰고 있겠지?)<br />
</p>
<ul>
<li><code>super</code>: <code>pkgs.haskellPackages</code>의 기존 상태를 참조한다. <code>Nixpkgs</code>에 정의되어 있는 하스켈 패키지 <code>ghc</code>,<code>base</code>,<code>lens</code>,<code>text</code>, …등과 하스켈 관련 유틸리티 함수 <code>callCabal2nix</code>, <code>callHackage</code> 등이 포함된다.</li>
<li><code>self</code>: <code>super</code>에 <code>extend</code>를 적용한 새로운 하스켈 패키지 집합</li>
</ul>
<p><strong>Overlay</strong><br />
<code>haskellPackages</code>에 있는 패키지를 덮어 씌우거나override, 추가할 때</p>
<h3 id="devshell-닉스화">devShell 닉스화</h3>
<p><code>nix develop</code>을 실행하면, <code>flake.nix</code>의 <code>outputs</code>에 있는 <code>devShell</code> 설정을 지침으로 삼아 쉘을 준비한다.</p>
<p>빌드가 아니라 개발이 목표일 때.<br />
어차피 두 경우 모두 필요한 라이브러리는 같은게 아닐까 싶지만, 개발 쉘에는 <code>ghcid</code>같은 도구나, 테스트 프레임워크, LSP서버, 디버깅 도구 같은 것들이 추가로 필요하다.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">inputs</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">nixpkgs</span>.<span class="va">url</span> <span class="op">=</span> <span class="st">&quot;github:NixOS/nixpkgs/nixpkgs-unstable&quot;</span><span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">outputs</span> <span class="op">=</span> <span class="op">{</span> <span class="va">self</span><span class="op">,</span> <span class="va">nixpkgs</span> <span class="op">}</span>:</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>      <span class="va">system</span> <span class="op">=</span> <span class="st">&quot;aarch64-darwin&quot;</span><span class="op">;</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>      <span class="va">pkgs</span> <span class="op">=</span> nixpkgs.legacyPackages.$<span class="op">{</span><span class="va">system</span><span class="op">};</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>      <span class="va">overlay</span> <span class="op">=</span> <span class="va">final</span><span class="op">:</span> <span class="va">prev</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">todo-app</span> <span class="op">=</span> final.callCabal2nix <span class="st">&quot;todo-app&quot;</span> <span class="ss">./.</span> <span class="op">{</span> <span class="op">};</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>      <span class="va">myHaskellPackages</span> <span class="op">=</span> pkgs.haskellPackages.extend.overlay<span class="op">;</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>      <span class="va">devShells</span>.${<span class="va">system</span><span class="op">}</span>.default = myHaskellPackages.shellFor <span class="op">{</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">packages</span> <span class="op">=</span> <span class="va">p</span> <span class="op">:</span> <span class="op">[</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>          p.todo-app</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">]</span>:</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>        nativeBuildInputs = <span class="kw">with</span> myHaskellPackages<span class="op">;</span> <span class="op">[</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>          ghcid</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>          cabal-install</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">]</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>      <span class="er">}</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>    <span class="er">}</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p><strong>mkShell 함수</strong> 언어와 무관하게 쓴다.<br />
<strong>shellFor</strong> 하스켈만을 위한 함수. mkShell위에 만든 abstraction이라 한다.<br />
모든 하스켈 패키지는 <code>shellFor</code>를 expose한다. Haskell package로 구성된configured GHC 패키지셋을 가진 <code>devShell</code>을 반환한다.<br />
</p>
<p>두 개의 인자를 받는다.<br />
<code>packages</code> : 로컬 하스켈 패키지를 의미한다.<br />
<code>nativeBuildInputs</code> : <code>devShell</code>의 <code>PATH</code>에서 사용 가능하도록 제공할 프로그램을 의미</p>
<h3 id="외부-의존성-닉스화">외부 의존성 닉스화</h3>
<p>전역 시스템을 건드리지 않고, 현재 프로젝트 환경에서만 쓸 외부 의존성을 준비해보자.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">inputs</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">nixpkgs</span>.<span class="va">url</span> <span class="op">=</span> <span class="st">&quot;github:NixOS/nixpkgs/nixpkgs-unstable&quot;</span><span class="op">;</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">outputs</span> <span class="op">=</span> <span class="op">{</span> <span class="va">self</span><span class="op">,</span> <span class="va">nixpkgs</span> <span class="op">}</span>:</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>      <span class="va">system</span> <span class="op">=</span> <span class="st">&quot;aarch64-darwin&quot;</span><span class="op">;</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>      <span class="va">pkgs</span> <span class="op">=</span> nixpkgs.legacyPackages.$<span class="op">{</span><span class="va">system</span><span class="op">};</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>      <span class="va">apps</span>.${<span class="va">system</span><span class="op">}</span>.postgress = <span class="op">{</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">type</span> <span class="op">=</span> <span class="st">&quot;app&quot;</span><span class="op">;</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">program</span> <span class="op">=</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">script</span> <span class="op">=</span> pkgs.writeShellApplication <span class="op">{</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>              <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;pg_start&quot;</span><span class="op">;</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>              <span class="va">runtimeInputs</span> <span class="op">=</span> <span class="op">[</span> pkgs.postgresql <span class="op">];</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>              <span class="va">text</span> <span class="op">=</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>              <span class="st">''</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a><span class="st">                # 현재 프로젝트 dir를 저장소로 데이터베이스 초기화</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a><span class="st">                [ ! -d &quot;./data/db&quot; ] &amp;&amp; initdb --no-locale -D ./data/db</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a><span class="st">                postgres -D ./data/db -k &quot;$PWD&quot;/data</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a><span class="st">              ''</span><span class="op">;</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">};</span></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span> <span class="st">&quot;</span><span class="sc">${</span>script<span class="sc">}</span><span class="st">/bin/pg_start&quot;</span><span class="op">;</span></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p><code>nix run</code>으로 실행할 앱을 정의하고 있다. 여기서 앱은 Postgres 서버를 시작하는 간단한 쉘스크립트다. <code>nixpkgs</code>는 이런 스크립트를 위한 <code>writeShellApplication</code>이란 편리한 함수를 제공한다. <code>${script}</code>는 <code>nix/store</code>에서 앱이 저장된 위치를 뜻한다.</p>
<p>※ pkg-config<br />
라이브러리에 접근하는 표준 인터페이스 제공<br />
<code>.pc</code>파일은 보통 <code>/usr/lib/pkgconfig</code> 또는 <code>/usr/lib64/pkgconfig</code>에 설치 된다. 만일 패키지가 <code>.pc</code> 파일 생성하는 설정이 없다면, 수동으로 만들어 등록할 수도 있다.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>prefix=/usr</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>libdir=${prefix}/lib</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>includedir=${prefix}/include</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>Name: webkit2gtk-4.0 (필수) </span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>Description: WebKitGTK library (선택)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>Version: 2.46.6 (필수)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>Libs: -L${libdir} -lwebkit2gtk-4.0 (필수)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>Cflags: -I${includedir}/webkitgtk-4.0 (필수)</span></code></pre></div>
<p>잘 설치 되었는지 확인</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>&gt; pkg-config --modversion webkit2gtk-4.0</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>&gt; pkg-config --libs webkit2gtk-4.0</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>&gt; pkg-config --cflags webkit2gtk-4.0</span></code></pre></div>
<p>※ WebkitGTK<br />
Webkit 렌더링 엔진을 GTK(그래픽 툴킷)와 통합한 라이브러리로, 주로 리눅스에서 웹브라우저나 웹컨텐체를 쓰는 애플리케이션을 개발하는데 쓰인다. GTK 버전에 따른 변형이 있다.</p>
<p><a href="https://nixos.wiki/wiki/Haskell">How to develop with Haskell and Nix</a><br />
</p>
<h2 id="nixpkgs-공식-문서-하스켈-섹션">Nixpkgs 공식 문서 하스켈 섹션</h2>
<p><a href="https://nixos.org/manual/nixpkgs/unstable/#haskell">하스켈 섹션</a><br />
Nixpkgs의 하스켈 인프라는 첫 째, 하스켈 <strong>컴파일러</strong>와 <strong>빌드 도구</strong>, 그리고 하스켈 패키지를 만들기 위한 <strong>패키징</strong> 인프라를 제공하고, 둘 째, 빌드된prebuilt 하스켈 라이브러리를 가지고 있는 하스켈 <strong>개발 환경</strong>을 제공하는 것을 목표로 한다.</p>
<h3 id="haskell-available-packages">가용한 패키지</h3>
<p>컴파일러와 대부분의 빌드 툴은 탑레벨에 위치한다.</p>
<ul>
<li>ghc: GHC 디폴트 버전</li>
<li>하스켈 전용 툴: <code>cabal-install</code>, <code>stack</code>, <code>hpack</code>, …</li>
<li><code>nix</code>, <code>cachix</code></li>
</ul>
<p>haskellPackages : Hackage에 있는 모든 패키지들 자체가 아니라, 패키지를 빌드할 수 있는 명세derivation를 가지고 있다고 보면 된다.<br />
haskellPackages에 있는 속성attribute 이름은 항상 Hackage에 있는 같은 이름과 대응된다. Hackage에는 Nix에서 쓰지 않는 글자(<code>+</code>,<code>.</code>,…)도 이름으로 쓸 수 있으니, 완전히 같지 않을 수 있다.
Stackage에 있는 패키지일 경우, LTS스냅샷에 있는 버전을 디폴트 버전으로 갖고 있다.</p>
<p>만일, <code>defaultGhcVersion = "ghc94"</code>라면, <code>haskellPackages = haskell.packages.ghc94</code>와 같다. <code>haskellPackages</code>는 디폴트 버전의 심볼릭 링크다.</p>
<p><code>haskellPackages.foo</code>라 하면, 디폴트로 Hackage에 있는 것 중 최신 버전 <code>foo</code> 패키지를 뜻한다. Nixpkgs는 고정된 Hackage 스냅샷으로, 스냅샷을 뜰 시점의 최신 패키지다.</p>
<p><code>haskell.packages.lts_22_11</code>처럼 Stackage 스냅샷을 지정해서, 해당 스냅샷에 들어있는 버전을 디폴트로 쓸 수 있다.</p>
<p><code>haskellPackages.foo_x_y_z</code> 명시적인 버전 지정 <code>x.y.z</code>를, 닉스는 이름으로 <code>.</code>을 쓸 수 없으니, 언더바<code>_</code>로 바꾼다.</p>
<p><code>cabal-install</code>을 써서 하스켈 패키지를 빌드할 때, 의존성을 푸는데, Hackage에 있는 모든 버전을 확인한 후, 조건에 맞는 적절한 버전을 선택하려는 시도를 한다. 반면, Nixpkgs는 이런 시도 없이, 단순히 입력값으로 패키지 목록을 받아서, 이들이 조건을 충족하는지만 본다. (버전 제약 조건을 우회하라면 <code>jailbreak</code>를 쓴다.)</p>
<p><code>haskellPackages.mkDerivation</code>은 <code>stdenv.mkDerivation</code>의 래퍼다.</p>
<p><code>stdenv.mkDerivation</code>은 닉스의 패키지 빌드를 위한 기본 함수다. 이 함수는 패키지 빌드, 설치, 테스트등의 단계를 정의한다. <code>haskellPackages.mkDerivation</code>은 기본 함수가 가진 <code>configurePhase</code>, <code>buildPhase</code>, <code>installPhase</code> 이외에 하스켈에 특화된 단계들을 가지고 있다. Cabal 라이브러리를 직접 사용하여 의존성을 해결하기 때문에 <code>cabal-install</code> 바이너리는 쓰이지 않는다.</p>
<p>하스켈 프로젝트에선 <code>Setup.hs</code> 파일을 통해 빌드, 테스트, 설치등의 작업을 정의한다. <code>haskellPackages.mkDerivation</code>은 이를 직접 컴파일하고 실행해서 Haskell 프로젝트를 빌드한다.</p>

<div class="comment">
  <script>
    document.addEventListener('DOMContentLoaded', loadUtterances, { once: true });
  </script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>

  </div>
  <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
  <script>
    tocbot.init({
      tocSelector: '.js-toc',
      contentSelector: '.js-toc-content',
      headingSelector: 'h2, h3',
      hasInnerContainers: true,
    });
  </script>
  <div id="footer">
    © 2025 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
  </div>
</body>

</html>
