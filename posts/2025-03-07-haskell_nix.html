<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">

<head>
  <script>
    (function () {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark') {
        document.documentElement.classList.add('dark-mode');
      }
    })();

    function loadUtterances() {
      const savedTheme = localStorage.getItem('theme');
      const themeValue = savedTheme === 'dark' ? 'github-dark' : 'github-light';

      console.log("theme");
      console.log(themeValue);
      const script = document.createElement('script');
      script.src = 'https://utteranc.es/client.js';
      script.setAttribute('repo', 'lionhairdino/lionhairdino.github.io');
      script.setAttribute('issue-term', 'url');
      script.setAttribute('theme', themeValue);
      script.setAttribute('crossorigin', 'anonymous');
      script.async = true;
      document.body.appendChild(script);
    };

    function updateUtterancesTheme() {
      const savedTheme = localStorage.getItem('theme');
      const themeValue = savedTheme === 'dark' ? 'github-dark' : 'github-light';

      // Utterances iframe에 메시지 전송
      const utterances = document.querySelector('.utterances iframe');
      if (utterances) {
        utterances.contentWindow.postMessage(
          {type: 'set-theme', theme: themeValue},
          'https://utteranc.es'
        );
      }
    }

  </script>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>lionhairdino - 닉스로 하스켈 프로젝트 빌드 (스케치 중)</title>
  
  <meta name="description" content="닉스로 하스켈 프로젝트 빌드하기" />
  <meta property="og:description" content="닉스로 하스켈 프로젝트 빌드하기" />
  
  <link rel="stylesheet" type="text/css" href="../css/default.css" />
  <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
  <link rel="shortcut icon" href="../favicon.ico" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
  <link rel="manifest" href="../site.webmanifest" />
  <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
  <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
  <meta name="msapplication-TileColor" content="#ff7500" />
  <meta name="theme-color" content="#ffffff" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="닉스로 하스켈 프로젝트 빌드 (스케치 중)" />
  <meta property="og:site_name" content="Lionhairdino" />
  <meta property="og:url" content="https://lionhairdino.github.io/posts/2025-03-07-haskell_nix.html" />
  
  <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />
  
  
  <meta name="keywords" content="Nix, 닉스, haskell, 하스켈">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-E9WZ6VXGHP');
  </script>
  <script src="../script/copycode.js"></script>

  <script src="../script/darkmode.js"></script>
  <script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
  <meta name="fediverse:creator" content="@lionhairdino@mastodon.social" />
  <link rel="alternate" type="application/rss+xml" title="상상 하스켈 - Lionhairdino" href="rss.xml" />
</head>

<body>
  <div id="header">
    <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
      <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
    </div>
    <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
      <a href="../">lionhairdino</a>
      <a href="../about.html">about</a>
      <!--<a href="/archive.html">archive</a>-->
    </div>
    <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
      <div style="display:inline-block;vertical-align: top;padding-top: 5px"></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:18px;border:none" src="../images/bluesky.svg"></a>
      </div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://discordapp.com/users/lionhairdino#7687"><img style="width:20px;border:none" src="../images/discord.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://x.com/lionhairdino"><img style="width:15px;border:none" src="../images/X.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://linkedin.com/in/lionhairdino-l-baaa54244"><img style="width:20px;border:none" src="../images/linkedin.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://github.com/lionhairdino"><img style="width:20px;border:none" src="../images/github.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://www.threads.net/@linohairdino"><img style="width:20px;border:none" src="../images/threads.svg"></a></div>
    </div>
    <div>
      <div style="display:inline-block;width:180px;">
        <div class="gcse-searchbox-only"></div>
        <div><button id="theme-toggle">
            <script>
              const savedTheme = localStorage.getItem('theme');
              if (savedTheme === 'dark')
                document.write("☉");
              else
                document.write("☾");
            </script>
          </button></div>
      </div>
    </div>
    <div>
      여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다. 여기 글을 처음 읽는 분은, 먼저 <a href="../warning.html">주의문</a>을 꼭 읽어보세요.
    </div>
  </div>
  <div class="js-toc-content">
    <h1>닉스로 하스켈 프로젝트 빌드 (스케치 중)</h1>
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on March  7, 2025
    
</div>

<p>아래 페이지들을 보며 스케치 중인데, 아직은 틀리게 해석, 이해한 곳도 많이 있는 것 같습니다. 교차하며 보며 조금씩 수정하고 있습니다. 2025.3</p>
<p><a href="https://github.com/NixOS/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md">하스켈 언어 프레임 워크</a><br />
<a href="https://github.com/mhwombat/nix-for-numbskulls/blob/78bcc186f79931c0e4a1e445e2f6b1f12f6d46be/Haskell/ss-haskell-dev.md">mwhwombat-haskell-dev</a><br />
<a href="https://haskell4nix.readthedocs.io/">haskell4nix</a><br />
<a href="https://serokell.io/blog/practical-nix-flakes">Serokell 블로그 - 실용 닉스 플레이크</a><br />
<a href="https://input-output-hk.github.io/haskell.nix/index.html">haskell.nix</a><br />
<a href="https://github.com/srid/haskell-flake">srid/haskell-flake</a><br />
<a href="https://nixos.asia/en/haskell">nixos.asia</a><br />
<a href="https://nixos.org/manual/nixpkgs/unstable/#haskell">nixos.org 문서의 하스켈 섹션</a><br />
<a href="https://nixos.wiki/wiki/Haskell">NixOS Wiki</a></p>
<p>로컬에서는 <code>/nix/store/해시-source/pkgs/development/haskell-modules</code>에서 닉스 소스 코드를 확인할 수 있다.</p>
<h2 id="nixpkgs에-있는-하스켈-언어-프레임-워크">nixpkgs에 있는 하스켈 언어 프레임 워크</h2>
<p>derviation을 생성하고, 개발쉘을 준비하는 기본적인 닉스 코드 모양은 아래와 같다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{</span> <span class="op">};</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">package</span> <span class="op">=</span> pkgs.stdenv.mkDerivation <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="va">shell</span> <span class="op">=</span> pkgs.mkShell <span class="op">{</span> <span class="op">...</span> <span class="op">};</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>mkDerivation</code>, <code>mkShell</code>을 하스켈 패키지와 쉽게 쓸 수 있도록, 이들을 래핑한 함수들과 특별한 구조들을 만들어 둔, 하스켈 프레임워크가 준비되어 있다. 하나의 파일이, 하나의 derivation을 생성하는 것이 아니라, derivation은 패키지 단위로 준비한다. 만일, 하스켈 프로젝트가 비하스켈 의존성이 있다면, <code>mkDerivation</code>과 <code>mkShell</code>로 준비하고, 이 것들을 하스켈 프레임워크의 래핑 함수들이 가져다 쓴다.</p>
<p><a href="https://github.com/NixOS/nixpkgs/blob/master/doc/languages-frameworks/haskell.section.md">하스켈 언어 프레임 워크</a></p>
<p>빠르게 보기</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>&gt; nix-env -i cabal2nix cabal-install</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>&gt; cabal2nix . &gt; default.nix</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>&gt; cabal2nix --shell . &gt; shell.nix</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>&gt; nix-shell --command 'cabal configure'</span></code></pre></div>
<p><strong>cabal2nix</strong>
프로젝트 <code>.cabal</code> 파일에서 의존성 정보를 가져오고, <code>nixpkgs</code>가 가진 <code>haskellPackages</code> 컬렉션에서 원하는 것들을 가져오며 의존성을 풀어갑니다.</p>
<h3 id="nixpkgs-바로-아래-있는-툴">nixpkgs 바로 아래 있는 툴</h3>
<p>하스켈만을 위한 툴 <code>ghc</code>,<code>cabal-install</code>, <code>stack</code>, <code>hpack</code>, <code>niv</code>, <code>cachix</code>, …<br />
위 툴들은 특별히 설치하지 않아도 <code>nixpkgs</code> 탑레벨에서 제공 된다.</p>
<h3 id="pkgs.haskell.lib-아래-있는-라이브러리">pkgs.haskell.lib 아래 있는 라이브러리</h3>
<ul>
<li><p><strong>callCabal2nix name src args</strong><br />
<code>cabal2nix</code>를 써서 <code>src</code> 소스 디렉토리 안에 있는 <code>.cabal</code>파일을 닉스 표현식으로 바꾸고, 이 표현식을 <code>haskellPackages.callPackage</code>에 넘겨 <code>name</code> 이름의 하스켈 패키지 <code>derivation</code>을 생성한다. <code>haskellPackages.callPackage</code>에 추가적으로 넘길 인자가 있으면 <code>args</code>를 쓴다.</p></li>
<li><p><strong>callCabal2nixWithOptions name src opts args</strong><br />
<code>opts</code>가 문자열이면 <code>cabal2nix</code>의 특별 명령줄 인자로 쓰인다.<br />
<code>extraCabal2nixOptions</code><br />
<code>srcModfier</code></p></li>
<li><p><strong>overrideCabal f drv</strong><br />
기존 하스켈 패키지의 cabal 정의에 새로운 속성을 추가할 때 쓴다. 결과적으로 수정된 새로운 패키지를 생성한다.</p></li>
<li><p><strong>callHackageDirect</strong><br />
닉스에서 하스켈 패키지를 직접 가져오는 함수. 특별히 뭔가를 하지 않고, 그냥 Hackage에서 다운로드 해서, 닉스 빌드 시스템에 통합시킨다. Hackage에 있는 정확한 버전을 고정. 하스켈에서 하지 않고, 닉스단에서 지정하는 방식이라 nix-stroe에 저장되니, 재다운로드를 덜 하게 된다.</p></li>
<li><p><strong>doJailbreak</strong><br />
<code>doJailbreak = overrideCabal (drv: { jailbreak = true; });</code><br />
<code>/nix/store/해시-source/pkgs/development/haskell-modules/lib/compose.nix</code> 파일에서 소스 확인</p></li>
</ul>
<p>jailbreaking : 패키지들의 모든 버전 제약을 날린다. 각 패키지 집합은, 각 의존성의 단 하나의 버전만 포함하니, 어차피 안전한 작업이다. 안전한 이유는, 닉스의 패키지 집합에는 여러 버전이 공존하지 않고, 오직 하나의 버전만 들어 있다. 예를 들어, <code>pkgs.haskllPackage</code>에 <code>text</code> 패키지가 있다면, 그 안에는 어차피 <code>text-2.0.2</code>같은 하나의 버전만 존재한다. 이렇기 때문에 버전을 제거해도 달리지는 게 없다는 뜻이다. 보통 cabal에서는 패키지마다 의존 버전 범위를 지정하지만, Nix 패키지에서는 의미 없다.</p>
<p>derivation의 속성 중 <code>jailbreak</code>를 <code>true</code>로 놓으면, 버전을 제거한다.</p>
<ul>
<li><p><strong>dontCheck</strong><br />
테스트를 통과하지 못해 빌드를 실패할 경우, 테스트를 건너 띄게 할 수 있다.</p></li>
<li><p><strong>jailbreakUnbreak</strong><br />
다른 패키지들의 버전은 그대로 유지하고, <code>cabal-install</code> 패키지의 버전 제약만 제거한다.</p></li>
</ul>
<h2 id="how-to-develop-with-haskell-and-nix">How to develop with Haskell and Nix</h2>
<p><a href="https://nixos.wiki/wiki/Haskell">NixOS Wiki</a><br />
얼마나 복잡한 하스켈 프로젝트냐에 따라 선택할 수 있는 다양한 방법이 있다. 서브 프로젝트가 없으면 <strong>developPackage</strong>, 서브 프로젝트가 있고 여러 팀이 작업하면 <strong>haskell.nix</strong>, 서브 프로젝트가 있고 단일팀이면 <strong>shellFor</strong>.<br />
</p>
<h3 id="스크립트-실행을-이용">스크립트 실행을 이용</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#!/usr/bin/env nix-shell</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#!nix-shell --pure -i runghc -p &quot;haskellPackages.ghcWithPackages (pkgs: [ pkgs.turtle ])&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Hello World&quot;</span></span></code></pre></div>
<h3 id="닉스-캐싱재현성-없이-직접-cabal-사용">닉스 캐싱/재현성 없이 직접 cabal 사용</h3>
<p>닉스를 쓰지 않을 때처럼 <code>cabal</code>을 쓸 수 있다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>$ nix-shell -p &quot;haskellPackages.ghcWithPackages (pkgs: with pkgs; [ cabal-install ])&quot;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>$ cabal init</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>$ cabal run</span></code></pre></div>
<p>다른 라이브러리 의존성이 있을 땐, <code>nix-shell</code>의 옵션으로 추가할 수 있다.</p>
<h3 id="stack-사용">Stack 사용</h3>
<p>닉스 안에서 stack을 이용해서 프로그램을 패키징하고 싶으면, <code>stack build</code>를 부르는 <code>stdenv.mkDerivation</code>의 래퍼인 <code>haskell.lib.buildStackProject</code>을 쓴다. <code>stack</code>이 필요한 것들을 다운로드 받아야 하기 때문에 sandbox를 비활성화한다. <code>nix-build --option sandbox false</code>. 아래 예시는 <code>R</code>, <code>zeromq</code>, <code>zlib</code>를 쓰는 프로젝트를 <code>stack</code>으로 빌드한다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> <span class="op">(</span><span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{</span> <span class="op">});</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>haskell.lib.buildStackProject <span class="op">{</span> <span class="co"># buildStackProject가 stack build를 부른다.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;HaskellR&quot;</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">buildInputs</span> <span class="op">=</span> <span class="op">[</span> R zeromq zlib <span class="op">];</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="developpackage-사용">developPackage 사용</h3>
<p><code>stack</code> 대신 닉스를 사용하여 재현 가능한 방식으로 의존성을 관리할 수 있다. <code>stack</code>이 의존성에 맞는 집합을 찾기 위해 solver를 사용하는 반면, 닉스는 고정된 패키지 집합을 쓴다. 닉스가 제공하는 캐싱 시스템의 장점을 누릴 수 있다. 닉스도 내부적으로 cabal을 쓴다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>$ nix-shell -p &quot;haskellPackages.ghcWithPackages (pkgs: with pkgs; [ cabal-install ])&quot; --run &quot;cabal init&quot;</span></code></pre></div>
<p>※ <code>cabal-install</code>은 디폴트로 가지고 있는 패키지라 위에처럼 지정하지 않아도 되는데, 특이한 환경에서는 <code>cabal-install</code>이 없는 경우도 있을 수 있으니, 확인 차원에서 명시적으로 넣어주는 것도 나쁘지 않다고 한다.</p>
<p>※ 로컬에 있는 특정 라이브러리를 사용하려면, <code>cabal.project</code> 파일에 해당 라이브러리 경로를 지정하면 된다.</p>
<p><code>default.nix</code> 파일에 다음을 추가한다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{</span> <span class="op">};</span> <span class="co"># 재현성을 높이려면 채널을 고정한다.</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># flake에서 devShell을 빌드하려면 아래를 추가한다.</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 보통 lib.inNixShell을 써서 자동으로 감지되는데, flake에선 작동하지 않는다.</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># returnShellEnv = true;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>pkgs.haskellPackages.developPackage <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="va">root</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span> <span class="co"># 루트에 있는 프로젝트를 위한 개발 환경을 만든다.</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>developPackage</code>의 옵션 확인 <a href="https://github.com/NixOS/nixpkgs/blob/0ba44a03f620806a2558a699dba143e6cf9858db/pkgs/development/haskell-modules/make-package-set.nix#L230">pkgs/development/haskell-modules/make-package-set.nix</a>. 이 함수는, 개발 쉘 설정할 때 필요한 함수들을 추가한 <code>callCabal2nixWithOptions</code>의 래핑 함수다.</p>
<p>닉스는 의존성 이름을 받아 오고, 닉스가 가지고 있는 하스켈 패키지를 쓰기 위해, 자동으로 <code>*.cabal</code>에 있는 <code>build-depends</code> 필드를 읽어 들인다. 닉스 저장소에 있는 하스켈 패키지 중 깨진 것들이 있다. 닉스는 라이브러리의 최신 버전만 가지고 있어, 구버전을 필요로 하는 패키지들은 깨진다. 이럴 때는 <code>overrides</code>와 <code>source-overrides</code> 속성을 이용한다. <code>source-overrides</code> 속성은 로컬 라이브러리를 불러 오기에 적당하다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{</span> <span class="op">};</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>pkgs.haskellPackages.developPackage <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">root</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="va">source-overrides</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">mylibrary</span> <span class="op">=</span> <span class="ss">./mylibrary</span><span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>하지만, 위와 같이 하면, <code>mylibrary</code>가 완전히 컴파일되기 전에 쉘에 들어갈 수 없으므로, 여러 프로젝트에서 동시에 작업하려면 <code>shellFor</code>가 필요하다.</p>
<p>또한, 컴파일할 때 필요한 도구나 실행시 필요한 라이브러리를 추가해야 할 수도 있다. 이를 위해 <code>modifier</code> 필드를 사용할 수 있으며, 이는 최종 하스켈 패키지에 적용할 함수다. (특히, 위에서 본 <code>overrideCabal</code>을 적용할 수도 있다.)</p>
<p><code>pkgs.haskell.lib.addBuildTools</code>를 사용하여 <code>nativeBuildInputs</code>을 추가할 수 있고, <code>pkgs.haskell.lib.addExtraLibraries</code>를 사용하여 <code>buildInputs</code>를 추가할 수 있다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{</span> <span class="op">};</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>pkgs.haskellPackages.developPackage <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">root</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 최종 패키지 derivation에 변형을 가하는 함수를 지정한다.</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 아래는 drv: ~ 람다 함수 형태를 지정하고 있다.</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># developPackage가 생성한 하스켈 패키지 derivation이 drv로 넘어간다.</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span class="va">modifier</span> <span class="op">=</span> <span class="va">drv</span><span class="op">:</span> </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    pkgs.haskell.lib.addBuildTools drv <span class="op">(</span><span class="kw">with</span> pkgs.haskellPackages<span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span> cabal-install</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        ghcid</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>      <span class="op">]);</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><a href="https://srid.ca/haskell-nix">srid.ca/haskell-nix</a></p>
<h3 id="복수-패키지일-때는-shellfor">복수 패키지일 때는 shellFor</h3>
<p><code>shellFor</code>는 <code>developPackage</code>와 비슷한데, 복수의 패키지를 동시(이 건 <code>cabal.project</code>와 비슷)에 개발할 수 있게 조금 더 복잡한 기능을 가지고 있다. <code>developPackage</code>와는 다르게 <code>shellFor</code>는 derivation을 <code>output</code>으로 가지고 있지 않다.</p>
<p>사용자 프로젝트를 “추가 하스켈 패키지”로 하스켈 패키지에 추가하기 위해, 하스켈 패키지 집합을 <code>extend</code> 하거나 <code>override</code>한다. (예를 들어, <code>haskellPackages.extend</code> 와 <code>packageSourceOverrides</code>를 사용하여, 프로젝트의 경로만 제공하면 이를 컴파일할 수 있다.) 그 후, <code>haskellPackages.shellFor { packages = p: [p.myproject1 p.myproject2] }</code>를 사용하여 원하는 모든 패키지가 포함된 쉘을 생성하는 방식이다.</p>
<p>현재 프로젝트가 서브 폴더 <code>./frontend</code>와 <code>./backend</code>를 가지고 있을 때, 아래와 같이 <code>cabal.project</code>를 생성한다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">packages</span><span class="kw">:</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="at">  frontend/</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="at">  backend/</span></span></code></pre></div>
<p>최종 <code>shell.nix</code>파일을 만든다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{</span> <span class="op">};</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>haskellPackages.extend <span class="op">(</span>haskell.lib.compose.packageSourceOverrides <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">frontend</span> <span class="op">=</span> <span class="ss">./frontend</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">backend</span> <span class="op">=</span> <span class="ss">./backend</span><span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}))</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>     .shellFor <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>       <span class="va">packages</span> <span class="op">=</span> <span class="va">p</span><span class="op">:</span> <span class="op">[</span> p.frontend p.backend <span class="op">];</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>       <span class="va">withHoogle</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>       <span class="va">buildInputs</span> <span class="op">=</span> <span class="op">[</span> pkgs.python pkgs.cabal-install <span class="op">];</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>$ nix-shell</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>$ cabal new-build all</span></code></pre></div>
<p>예를 들어, <code>nix-build</code>를 써서 <code>backend</code>를 빌드하려면 <code>default.nix</code>를 다음과 같이 만든다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{</span> <span class="op">};</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>haskellPackages.extend <span class="op">(</span>haskell.lib.compose.packageSourceOverrides <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">frontend</span> <span class="op">=</span> <span class="ss">./frontend</span><span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">backend</span> <span class="op">=</span> <span class="ss">./backend</span><span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}))</span>.backend</span></code></pre></div>
<p>하나의 derivation을 생성하고 싶으면, 쉘을 시작하고 싶을 때는 쉘을 <code>output</code>하고, 빌드하길 원할 때는 패키지를 <code>output</code>하도록 <code>if pkgs.lib.inNixShell then ... else ...</code>를 쓴다.</p>
<h3 id="overrides">Overrides</h3>
<p>nixpkgs는 특정 프로젝트에 맞는 모든 버전 제약들을 해소하기 위해 솔버를 쓰지 않고, 하나의 패키지 집합만 유지하려고 한다.(stackage에 있는 패키지를 기반으로 하고, 그 외 패키지는 Hackage에서 최신 버전을 가져 온다.) 여러 이유로 깨진 패키지를 사용자가 고쳐 쓸 수도 있다. 첫 번째로, 현재 프로젝트가 쓰고 있는 GHC 버전으로 컴파일 했는지 확인한다. 현재 프로젝트의 버전을, <code>haskellPackages</code> 대신 <code>haskell.packages.ghcXYZ</code>로 패키지를 컴파일할 때 쓰인 버전으로 바꿔 볼 수 있다.</p>
<p><code>developPackage</code>를 사용 중이면, 아래에서 설명하는 <code>override</code>를 쓰든가, 간단하게 <code>srouce-override</code>를 쓴다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>pkgs.haskellPackages.developPackage <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">root</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">source-overrides</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 현재 쓰고 있는 GHC haskellPackages가 1.6.0.0을 쓰고 있어 현재 제약과 맞지 않을 때</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">HUnit</span> <span class="op">=</span> <span class="st">&quot;1.5.0.0&quot;</span><span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<p><code>source-overrides</code>에 아래 둘 중 하나를 넘긴다.</p>
<ul>
<li>버전 (<code>callHackage</code>에게 전달 된다. 닉스는 <code>all-cabal-hashes</code>라는 패키지를 써서, 자동으로 해시를 찾으니, 해시를 지정할 필요가 없다. 만약 패키지가 <code>all-cabal-hashes</code>에 없으면 <code>callHackageDirect</code>를 쓴다.) ※ <code>all-cabal-hashes</code>는 Hackage의 모든 패키지 정보와 각 버전들의 해시를 저장한 닉스 DB이다. <code>callHackage</code>, <code>callHackageDirect</code>는 Hackage에서 패키지를 가져오는 함수니, 해시가 필요 없을 것 같은데, 패키지를 가져온 후 현재 닉스 생태계에서 쓰이는 해시와 맞는지 확인하기 위해 필요하다.</li>
</ul>
<p>※ <strong>all-cabal-hashes</strong></p>
<ul>
<li><p>닉스는 반드시 해시로 패키지를 특정한다.</p></li>
<li><p>Hackage는 버전으로 관리된다.</p></li>
<li><p>Hackage에 패키지가 올라오면, 주기적으로 자동 감지하고 해시를 만들어 <code>all-cabal-hashes</code> 패키지에 담아두는 스크립트를 닉스팀이 만들어 뒀다.</p></li>
<li><p>닉스에서 Hackage에 있는 패키지가 필요할 때는, <code>callHackage</code> 함수에 버전만 넘기면, 알아서 <code>all-cabal-hashes</code>에서 해시를 찾는다.</p></li>
<li><p>만일, 아직 <code>all-cabal-hashes</code>에 해시가 없는 패키지에 접근할 일이 있을 땐, <code>nix-prefetch-url</code>등으로 패키지를 다운받아 해시를 계산한 후 직접 <code>callHackageDirect</code>의 <code>sha256</code> 필드로 넘겨줘야 한다.</p></li>
<li><p>경로 <code>callCabal2nix</code>를 통해 패키지를 가져 온다. <code>fetchurl</code>,<code>fetchFromGitHub</code> 같은 닉스 fetcher로 지정할 수 있다. 로컬 라이브러리라면, 해당 디렉토리를 지정하면 된다. ※ <code>callCabal2nix</code>는 로컬 패키지나 Hackage가 아닌 곳의 패키지를 닉스 패키지로 변환할 때 쓴다. 변환할 때는 해시를 요구하지 않지만, 닉스 저장소에 저장할 때는 해시를 기반으로 저장된다.</p></li>
</ul>
<p>derivation의 속성을 바꾸기 위해, 더 강력한 override 시스템을 쓸 수도 있다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>pkgs.haskellPackages.developPackage <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">root</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">overrides</span> <span class="op">=</span> <span class="va">self</span><span class="op">:</span> <span class="va">super</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">random</span> <span class="op">=</span> pkgs.haskell.lib.overrideCabal super.random <span class="op">{</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>      <span class="va">version</span> <span class="op">=</span> <span class="st">&quot;1.1&quot;</span><span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>      <span class="va">sha256</span> <span class="op">=</span> <span class="st">&quot;sha256-...&quot;</span><span class="op">;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>      <span class="va">doCheck</span> <span class="op">=</span> <span class="cn">false</span><span class="op">;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="er">}</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="er">}</span></span></code></pre></div>
<p><code>developPackage</code>의 <code>source-overrides</code>와 <code>overrides</code> 속성 차이는 다음과 같다.<br />
<strong>source-overrides</strong><br />
패키지 소스 코드를 덮어 씌울 때 쓴다. 주로 버전 충돌을 해결하거나 로컬에서 수정된 패키지를 사용할 때.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>  source<span class="op">-</span>overrides = <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">myPackage</span> <span class="op">=</span> <span class="ss">/path/to/my/local/package</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="er">}</span></span></code></pre></div>
<p><strong>overrides</strong><br />
기존 하스켈 패키지를 수정할 때 사용. 패키지의 기본 설정을 덮어 씌우거나 , 패키지 내용을 변경하려는 경우.</p>
<p>※ 둘이 하는 일을 설명하면 다르다. <code>overrides</code>는 패키지의 설정 중 소스 경로를 바꾸는 거고, <code>source-overrides</code>는 패키지가 가진 소스 자체를 교체한다. 설명은 다른데, 최종 결과물은 같다.</p>
<p><code>ghcWithPackages</code>를 써서 override할 수도 있다. 아래는 라이브러리 <code>quipper</code>가 올라오는 <code>nix-shell</code>을 만드는 예시다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">pkgs</span> <span class="op">?</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{}</span> <span class="op">}</span>:</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> pkgs<span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>pkgs.mkShell <span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">buildInputs</span> <span class="op">=</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>      <span class="va">myHaskell</span> <span class="op">=</span> pkgs.haskell.packages.ghc884.override <span class="op">{</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">overrides</span> <span class="op">=</span> <span class="va">self</span><span class="op">:</span> <span class="va">super</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>          <span class="va">random</span> <span class="op">=</span> pkgs.haskell.lib.overrideCabal super.random <span class="op">{</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>            <span class="va">version</span> <span class="op">=</span> <span class="st">&quot;1.1&quot;</span><span class="op">;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>            <span class="va">sha256</span> <span class="op">=</span> <span class="st">&quot;sha256-...&quot;</span><span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>          <span class="op">};</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>          <span class="va">fixedprec</span> <span class="op">=</span> haskell.lib.markUpbroken super.fixedprec<span class="op">;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>          <span class="va">quipper</span> <span class="op">=</span> haskell.lib.markUpbroken super.quipper<span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>myHaskell.ghcWithPackages <span class="op">(</span><span class="va">hpkgs</span><span class="op">:</span> <span class="op">[</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>          hpkgs.quipper</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">]))</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>      <span class="op">]</span>:</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a><span class="er">}</span></span></code></pre></div>
<p><code>mkShell</code>은 하스켈에 특화된 함수는 아니다. 닉스에서 개발 쉘을 생성하는 기본 함수다. <code>overrideCabal</code>은 구 패키지의 속성을 수정한 새 패키지를 반환한다. 이 함수가 수정 가는한 옵션은 <a href="https://github.com/NixOS/nixpkgs/blob/0ba44a03f620806a2558a699dba143e6cf9858db/pkgs/development/haskell-modules/generic-builder.nix#L13">여기 소스</a>를 참고한다.</p>
<h2 id="super-simple-haskell-development-with-nix">Super-Simple Haskell Development with Nix</h2>
<p><a href="https://github.com/mhwombat/nix-for-numbskulls/blob/78bcc186f79931c0e4a1e445e2f6b1f12f6d46be/Haskell/ss-haskell-dev.md">mwhwombat 원문</a><br />
많은 튜토리얼들이 niv, binary cache, flakes, Stack 등의 툴을 쓰라하는데, 빌드 툴을 최소화 해보자.<br />
<code>default.nix</code>를 아래와 같이 작성한다.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{</span> <span class="op">};</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  pkgs.haskellPackages.developPackage <span class="op">{</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># name = &quot;패키지이름&quot; # 현재 폴더명이 패키지 이름과 다를 경우, `name` 필드를 추가한다.</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">root</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">source-overrides</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>      <span class="va">grid</span> <span class="op">=</span> <span class="ss">../grid</span><span class="op">;</span> <span class="co"># haskellPackages에 있는 grid 오버라이드</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>※ TODO <code>./</code>와 <code>./.</code>는 둘 다 현재 디렉토리를 뜻하고, 대부분의 경우 차이가 없다고 하긴 하는데? 아직 어떤 차이점이 있는지 모른다.<br />
</p>
<p><code>default.nix</code> 파일에, 쉘에 들어갔을 때 쓸 패키지들의 버전을 지정할 수도 있고, <code>cabal.project</code>에 지정할 수도 있다. 필요한 버전을 수정할 때 <code>cabal.project</code>에 안 쓰고, <code>default.nix</code>에 버전을 지정하면, 간단히 쉘을 빠져 나왔다 다시 들어가기만 하면, 새 버전으로 준비된 쉘로 들어 간다.</p>
<ul>
<li><code>nix-build</code>를 실행</li>
<li><code>nix-shell</code>을 실행. 모든 의존성이 준비된 상태의 쉘에 들어가고, <code>cabal</code> 명령어들을 쓸 수 있다.</li>
</ul>
<h3 id="바로-nix-shell에서-실행되는-하스켈-스크립트-만들기">바로 nix-shell에서 실행되는 하스켈 스크립트 만들기</h3>
<p>※ 별다른 옵션 없이 <code>nix-shell</code>을 실행하면, <code>default.nix</code>를 찾지만, 패키지를 직접 지정하는 옵션 <code>-p</code>를 쓰면 <code>default.nix</code> 없이 환경에 들어갈 수있다. 처음 실행할 때는 지정한 패키지를 준비하느라 시간이 걸리지만, 한 번 준비한 이 후에는 nix-collect-garbage를 하기 전엔 바로 쉘로 들어간다.</p>
<p>하스켈 소스 파일에 아래 내용을 제일 처음에 추가한다.<br />
※ <code>#!</code>(Shebang) 현재 스크립트를 해석할 해석기를 지정한다. 그런데, 아래와 같이 하면 해석기안에서 또 해석기를 실행하는 것처럼 보인다. <code>nix-shell</code>이 쉬뱅을 만나면 특별한 동작을 하도록 되어 있어 다음이 가능하다고 한다. 아래는 <code>nix-shell</code> 옵션을 여러 줄에 걸쳐서 표현 했을 뿐, <code>nix-shell -p "haskell~~·" -i runghc</code>처럼 한 줄로 지정한 것과 같은 효과를 낸다.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#! /usr/bin/env nix-shell # 뱅! 닉스쉘로 실행하겠다는 뜻</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#! nix-shell -p &quot;haskellPackages.ghcWithPackages (p: [p.pandoc])&quot; </span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#! nix-shell -i runghc</span></span></code></pre></div>
<p>※ <strong>ghcWithPackages</strong> GHC와 지정 패키지를 함께 제공하는 유틸리티다.<br />
(특정 ghc 버전에 추가 패키지를 넣어 올릴 수 있어서, 프로젝트별로 다른 GHC버전을 사용할 때 유용할 수 있다.<br />
pure/impure nix-shell을 모두 지원, 여러 패키지들을 <code>[]</code>안에 지정하면, 지정 패키지들이 준비된 상태의 쉘에 들어간다)</p>
<p>※ <code>-p</code>: 패키지를 지정하는 옵션인데, <code>ghcWithPackages</code>가 <code>pandoc</code>을 포함한 새로운 패키지를 생성하고, 그 패키지를 불러온다는 의미다</p>
<p>※ <code>-i</code>: 명령어를 nix-shell 환경에서 실행한다.</p>
<p>※ 지금은 하스켈 관련 유틸리티를 쓰기 편하도록 <code>gw</code>라는 이름의 래핑 유틸리티가 생겼다.</p>
<p><code>nix-shell</code> 모드는 두 가지가 있다.</p>
<ul>
<li><p>순수: <code>nix-shell --pure</code><br />
Nix에서 제공하는 패키지만 사용하고, 시스템 환경 변수나 글로벌 설정을 쓰지 않는다.</p></li>
<li><p>비순수 : <code>nix-shell --impure</code><br />
시스템 환경 변수도 접근 가능하다. 예를 들어 <code>/usr/bin/ghc</code>가 있다면, 그 것도 사용 가능하다. 재현성은 더 떨어질 수도 있다는 걸 알고 쓰자.</p></li>
</ul>
<h2 id="practical-nix-flakes">Practical Nix Flakes</h2>
<p><a href="https://serokell.io/blog/practical-nix-flakes">Serokell 블로그 - 실용 닉스 플레이크</a><br />
</p>
<p>※ Flake가 활성화된 닉스를 “flake-y” 닉스라 부르기도 한다.<br />
최소한의 Nix언어 문법과, 간단한 Flake 설명 후에 하스켈 패키지 설치 방법에 대해 얘기한다.</p>
<p>세로켈 깃헙 저장소에서 제공하는, <code>cabal2nix</code>를 쓰는 템플릿을 이용해, 기본적인 flake 파일을 생성한다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>nix flake init -t github:serokell/templates#haskell-cabal2nix</span></code></pre></div>
<p>※ haskell-flake를 쓸 때는 srid 계정에 있는 템플릿을 쓰기도 한다.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>nix flake init -t github:srid/haskell-flake</span></code></pre></div>
<p><strong>nix shell</strong>에서 실행이 필요한 패키지들을 <code>$PATH</code>에 등록할 수 있다.</p>
<p>가능한 URI 모양</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>github:owner/repo/[revision or branch]</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>gitlab:owner/repo/[revision or branch]</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>https://example.com/path/to/tarball.tar.gz</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>git+https://example.com/path/to/repo.git</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>git+ssh://example.com/path/to/repo.git</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>file:///path/to/directory</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>/path/to/directory</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>./path/to/relative/directory</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>flake-registry-value</span></code></pre></div>
<p>어디에 설치 됐는지 궁금할 때</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>&gt; command -v hello</span></code></pre></div>
<p>hello 빌드에 필요한 모든 환경 설정이 같이 올라오게 하려면, <strong>nix develop</strong></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>&gt; nix develop nixpkgs#hello</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>&gt; unpackPhase -- 소스 풀고</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>&gt; cd hello-2.12.1</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>&gt; configurePhase -- configure 스크립트를 돌리고</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>&gt; buildPhase -- 빌드</span></code></pre></div>
<p><strong>nix profile</strong> (프로젝트별 환경 지정이 아니라, 계정에 종속된 환경을 만드는 <code>nix-env</code>의 대체)</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>&gt; nix profile install nixpkgs#hello</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>&gt; nix profile list</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>&gt; nix profile update hello</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>&gt; nix profile remove hello</span></code></pre></div>
<p><strong>nix flake</strong></p>
<ul>
<li><p><code>flake URI</code>를 받아 <code>flake</code>의 출력을 트리 구조로 그려 준다.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>&gt; nix flake show github:nixos/nixpkgs</span></code></pre></div></li>
<li><p><code>nix flake clone</code> flake 소스를 로컬 디렉토리에 복사한다. <code>git clone</code>과 비슷.</p></li>
<li><p><code>nix flake lock</code> (이전 <code>nix flake update</code>)</p></li>
</ul>
<h2 id="haskell.nix">haskell.nix</h2>
<p><a href="https://input-output-hk.github.io/haskell.nix/index.html">haskell.nix</a> Cabal 프로젝트나 Stack 프로젝트를 Nix 코드로 자동 번역한다. <code>Nixpkgs</code>의 <code>haskellPackages</code>를 쓰지 않는, 독립적인 패키지 관리시스템으로 <code>cabal-install</code>이나 <code>stack</code>과의 호환성에 중점을 두고 설계되었다.<br />
</p>
<p>※ 이 동네 특징인 것 같은데, 설정 파일 이름도 <code>haskell.nix</code>고, 이 <code>haskell.nix</code> 파일을 읽어 해석하는 Nix 모듈 이름도, 즉 시스템 이름도 <code>haskell.nix</code>라 부른다. 컨텍스트에 따라서 뭘 가리키는지 알아 먹어야 하는 상황을 자주 만난다.</p>
<p>※ <a href="https://hackage.haskell.org/package/cabal-install">cabal-install</a>: <code>cabal</code> 명령줄 프로그램을 가지고 있는 패키지. cabal이라 하면, cabal 스펙, cabal 라이브러리, cabal 도구(명령줄 프로그램 <code>cabal</code>)을 모두 의미할 수 있지만, 보통 cabal이라 하면, 도구 <code>cabal</code>을 의미하는 경우가 많다.</p>
<blockquote>
<p>순환 의존성Cyclic dependencies</p>
<p><code>nixpkgs</code>에 있는 하스켈 빌더는 프로젝트의 라이브러리, 실행 파일, 테스트등을 <strong>개별 Nix derivation으로 분리하여 빌드</strong>한다. 이 때 라이브러리와 테스트가 서로 의존하는 경우 순환 의존성이 생겨 빌드에 실패한다. 라이브러리와 테스트가 공유하는 기능을 잘 빼내는 리팩토링을 하든가, <code>doCheck</code> 속성을 <code>false</code>로 해서 테스트 빌드를 비활성화 하거나, <code>libraryHaskellDepends</code> 속성을 사용하여 라이브러리 의존성을 명시적으로 지정할 수 있다.</p>
</blockquote>
<p><strong>nix-tools</strong>는 다음 하스켈 패키지들을 가지고 있다.<br />
<strong>cabal-to-nix</strong>: 조건부 표현식을 유지retain?하며 <code>.cabal</code>을 <code>.nix</code>로 변환하는 트랜스포머.<br />
※ 조건부 표현식 유지? - nix로 옮길 때 cabal에서 쓰던 조건부 표현식들이 사리지지 않는다는 뜻<br />
<strong>stack-to-nix</strong>: <code>stack.yaml</code>을 <code>.nix</code>로 변환하는 트랜스포머. <code>stack.yaml</code>에 있는 표현식을 읽어 <code>haskell.nix</code>에 적합한 <code>pkgs.nix</code> 파일을 만든다.<br />
<strong>plan-to-nix</strong>: <code>plan.json</code>을 <code>.nix</code>로 변환하는 트랜스포머. <code>plan.json</code>을 읽어 <code>pkgs.nix</code> 파일을 만든다.</p>
<ul>
<li><code>haskell.nix</code> 하스켈 인프라를 위한 런타임 시스템이다.</li>
<li><code>hackage.nix</code> Hackage에 있는 모든 cabal 표현식을 닉스 표현식으로 제공한다. hackage에 있는 패키지셋과 동기화하기 위해 주기적으로 업데이트 된다.</li>
<li><code>stackage.nix</code> 모든 stackage 스냅샷을 닉스 표현식으로 제공한다. <code>hackage.nix</code>에 의존</li>
</ul>
<p><strong>Niv</strong><br />
닉스 프로젝트 의존성을 트래킹하는 명령줄 도구다. flake를 쓰려면 안봐도 된다고 한다. 일단 패스.</p>
<p>haskell.nix는 <code>stack.yaml</code>과 <code>cabal.project</code> 기반 프로젝트 모두에 작동한다.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Niv 소스를 읽어들인다.</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">sources</span> <span class="op">=</span> <span class="bu">import</span> <span class="ss">./nix/sources.nix</span> <span class="op">{};</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ./nix/sources.nix 파일이 없으면, 다음을 실행</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">#   niv init</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">#   niv add input-output-hk/haskell.nix -n haskellNix</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Niv로 고정한 haskell.nix commit을 가져 온다.</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>  <span class="va">haskellNix</span> <span class="op">=</span> <span class="bu">import</span> sources.haskellNix <span class="op">{};</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># haskellNix가 없으면 다음을 실행</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">#   niv add input-output-hk/haskell.nix -n haskellNix</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># nixpkgs를 불러오고 haskell.nix 에서 제공하는 nixpkgsArgs 전달한다.</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>  <span class="va">pkgs</span> <span class="op">=</span> <span class="bu">import</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># haskell.nix provides access to the nixpkgs pins which are used by our CI,</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># hence you will be more likely to get cache hits when using these.</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># But you can also just use your own, e.g. '&lt;nixpkgs&gt;'.</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>    haskellNix.sources.nixpkgs<span class="op">-</span>unstable</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># These arguments passed to nixpkgs, include some patches and also</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># the haskell.nix functionality itself as an overlay.</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>    haskellNix.nixpkgsArgs<span class="op">;</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span> pkgs.haskell<span class="op">-</span>nix.project <span class="op">{</span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 'cleanGit' cleans a source directory based on the files known by git</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>  <span class="va">src</span> <span class="op">=</span> pkgs.haskell<span class="op">-</span>nix.haskellLib.cleanGit <span class="op">{</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>    <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;haskell-nix-project&quot;</span><span class="op">;</span></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>    <span class="va">src</span> <span class="op">=</span> <span class="ss">./.</span><span class="op">;</span></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 사용할 GHC 버전 지정.</span></span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>  <span class="va">compiler-nix-name</span> <span class="op">=</span> <span class="st">&quot;ghc925&quot;</span><span class="op">;</span> <span class="co"># `stack.yaml`기반 프로젝트에선 필요 없다.</span></span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>아래는 Reflex 공식 홈에 있는 <a href="https://reflex-frp.org/tutorial">예시</a>를 빌드하는 <code>haskell.nix</code>이다.<br />
※ 2025.3 master 브랜치가 아니라, <a href="https://github.com/obsidiansystems/calculator-tutorial/tree/enhance/ob-9.0.1">enhance/ob-9.0.1 브랜치</a>를 가져와서 빌드 성공했다.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">obelisk</span> <span class="op">?</span> <span class="bu">import</span> <span class="ss">./.obelisk/impl</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">system</span> <span class="op">=</span> <span class="bu">builtins</span>.currentSystem<span class="op">;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">iosSdkVersion</span> <span class="op">=</span> <span class="st">&quot;10.2&quot;</span><span class="op">;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>:</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> obelisk<span class="op">;</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>project <span class="ss">./.</span> <span class="op">({</span> <span class="va">pkgs</span><span class="op">,</span> <span class="va">hackGet</span><span class="op">,</span> <span class="op">...</span> <span class="op">}</span>:</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> pkgs.haskell.lib<span class="op">;</span> <span class="op">{</span> <span class="co"># 하스켈 프로젝트를 빌드할 때 쓰는 라이브러리</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 아래, packages, overrides 같은 속성들은 Nixpkgs에 정의된 하스켈 관련 스펙이다.</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>  <span class="va">android</span>.<span class="va">applicationId</span> <span class="op">=</span> <span class="st">&quot;systems.obsidian.obelisk.examples.minimal&quot;</span><span class="op">;</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>  <span class="va">android</span>.<span class="va">displayName</span> <span class="op">=</span> <span class="st">&quot;Obelisk Minimal Example&quot;</span><span class="op">;</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>  <span class="va">ios</span>.<span class="va">bundleIdentifier</span> <span class="op">=</span> <span class="st">&quot;systems.obsidian.obelisk.examples.minimal&quot;</span><span class="op">;</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>  <span class="va">ios</span>.<span class="va">bundleName</span> <span class="op">=</span> <span class="st">&quot;Obelisk Minimal Example&quot;</span><span class="op">;</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>  <span class="va">__closureCompilerOptimizationLevel</span> <span class="op">=</span> <span class="cn">null</span><span class="op">;</span> <span class="co"># 클로저 컴파일러가 뭐지?</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 구글에서 만든 JS 컴파일러라 한다. 최적화 수준을 지정. null이면 안한다는 뜻</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 아마도 Reflex 코드를 GHCJS가 뽑아내면 그 다음 이게 돌지 않을까?</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 프로젝트에서 사용할 Nixpkgs에 없는 하스켈 패키지를 추가할 때</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 주로 pkgs.haskellPackages.callCabal2nix와 같이 cabal파일을 이용하여 패키지를 불러오는</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 함수를 사용한다. Cabal 패키지 설정을 Nix 표현식으로 변환하여 Nix가 하스켈 프로젝트의</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 의존성을 관리하도록 한다. .cabal 파일에서 의존성, 빌드 옵션, 소스 파일들을 분석해서</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Nix 표현식을 생성, Nix가 패키지를 빌드한다.</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>  <span class="va">packages</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>    <span class="va">mmark</span> <span class="op">=</span> hackGet <span class="ss">./dep/mmark</span><span class="op">;</span> <span class="co"># 소스 코드를 지정한 곳(로컬, 인터넷 주소...)에서 가져 온다.</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>          <span class="co"># hackGet : 원래 있던 건 아니고, obelisk에서 추가 했다. </span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>          <span class="co"># 하스켈 패키지를 가져오는데 쓴다.</span></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 위는 nixpkg에 없는 패키지를 추가하고,</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 아래는 nixpkg에 있는 패키지를 덮어 씌운다.</span></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 그런데 위아래 모두 mmark를 가지고 있다. </span><span class="al">TODO</span><span class="co">: overrides에만 있으면 되는 것 아닌가?</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 주로 pkgs.haskell.lib.overrideCabal과 같은 함수를 사용하여 cabal 패키지 설정을 오버라이드</span></span>
<span id="cb28-32"><a href="#cb28-32" aria-hidden="true" tabindex="-1"></a>  <span class="va">overrides</span> <span class="op">=</span> <span class="va">self</span><span class="op">:</span> <span class="va">super</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb28-33"><a href="#cb28-33" aria-hidden="true" tabindex="-1"></a>    <span class="va">temporary</span> <span class="op">=</span> dontCheck super.temporary<span class="op">;</span> <span class="co"># dontCheck : 테스트 단계에서 checkPhase를 비활성화</span></span>
<span id="cb28-34"><a href="#cb28-34" aria-hidden="true" tabindex="-1"></a>    <span class="va">email-validate</span> <span class="op">=</span> dontCheck super.email<span class="op">-</span>validate<span class="op">;</span></span>
<span id="cb28-35"><a href="#cb28-35" aria-hidden="true" tabindex="-1"></a>    <span class="va">mmark</span> <span class="op">=</span> doJailbreak <span class="op">(</span>dontCheck <span class="op">(</span><span class="kw">if</span> <span class="op">(</span>self.ghc.isGhcjs <span class="kw">or</span> <span class="cn">false</span><span class="op">)</span> </span>
<span id="cb28-36"><a href="#cb28-36" aria-hidden="true" tabindex="-1"></a>                                    <span class="kw">then</span> dontHaddock super.mmark <span class="kw">else</span> super.mmark<span class="op">));</span></span>
<span id="cb28-37"><a href="#cb28-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">## doJailbreak : 하스켈 패키지 의존성 제약을 무시, 버전 범위 지정을 무시</span></span>
<span id="cb28-38"><a href="#cb28-38" aria-hidden="true" tabindex="-1"></a>    <span class="va">modern-uri</span> <span class="op">=</span> doJailbreak <span class="op">(</span>dontCheck <span class="op">(</span>self.callHackageDirect <span class="op">{</span></span>
<span id="cb28-39"><a href="#cb28-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">pkg</span> <span class="op">=</span> <span class="st">&quot;modern-uri&quot;</span><span class="op">;</span></span>
<span id="cb28-40"><a href="#cb28-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">ver</span> <span class="op">=</span> <span class="st">&quot;0.3.4.4&quot;</span><span class="op">;</span></span>
<span id="cb28-41"><a href="#cb28-41" aria-hidden="true" tabindex="-1"></a>        <span class="va">sha256</span> <span class="op">=</span> <span class="st">&quot;19qwfrida77mxix4v41qyvanfxy8qljg4fxz9ccxlcjdbks5v6pa&quot;</span><span class="op">;</span></span>
<span id="cb28-42"><a href="#cb28-42" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="op">{}));</span></span>
<span id="cb28-43"><a href="#cb28-43" aria-hidden="true" tabindex="-1"></a>    <span class="va">lucid</span> <span class="op">=</span> dontCheck <span class="op">(</span>self.callHackageDirect <span class="op">{</span></span>
<span id="cb28-44"><a href="#cb28-44" aria-hidden="true" tabindex="-1"></a>        <span class="va">pkg</span> <span class="op">=</span> <span class="st">&quot;lucid&quot;</span><span class="op">;</span></span>
<span id="cb28-45"><a href="#cb28-45" aria-hidden="true" tabindex="-1"></a>        <span class="va">ver</span> <span class="op">=</span> <span class="st">&quot;2.11.1&quot;</span><span class="op">;</span></span>
<span id="cb28-46"><a href="#cb28-46" aria-hidden="true" tabindex="-1"></a>        <span class="va">sha256</span> <span class="op">=</span> <span class="st">&quot;035idsv283s6484wyb8yndzw4rbyivvz6b3cwxan2cf0xd3s78dk&quot;</span><span class="op">;</span></span>
<span id="cb28-47"><a href="#cb28-47" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="op">{});</span></span>
<span id="cb28-48"><a href="#cb28-48" aria-hidden="true" tabindex="-1"></a>    <span class="va">markdown-unlit</span> <span class="op">=</span> self.callHackageDirect <span class="op">{</span></span>
<span id="cb28-49"><a href="#cb28-49" aria-hidden="true" tabindex="-1"></a>      <span class="va">pkg</span> <span class="op">=</span> <span class="st">&quot;markdown-unlit&quot;</span><span class="op">;</span></span>
<span id="cb28-50"><a href="#cb28-50" aria-hidden="true" tabindex="-1"></a>        <span class="va">ver</span> <span class="op">=</span> <span class="st">&quot;0.5.1&quot;</span><span class="op">;</span></span>
<span id="cb28-51"><a href="#cb28-51" aria-hidden="true" tabindex="-1"></a>        <span class="va">sha256</span> <span class="op">=</span> <span class="st">&quot;194g4f12xpvdp9yr16ngxx6w9kmpvilkivvag3drpc8cv15csp8l&quot;</span><span class="op">;</span></span>
<span id="cb28-52"><a href="#cb28-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="op">{};</span></span>
<span id="cb28-53"><a href="#cb28-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># super.frontend는 원래의 frontend 패키지 정의</span></span>
<span id="cb28-54"><a href="#cb28-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># overrideCabal 기존 cabal 패키지의 속성을 수정할 때 사용하는 닉스 함수</span></span>
<span id="cb28-55"><a href="#cb28-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># drv : 기존 패키지(super.frontend)의 속성</span></span>
<span id="cb28-56"><a href="#cb28-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># drv.buildTools 속성을 수정하여 새로운 빌드 추가</span></span>
<span id="cb28-57"><a href="#cb28-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 닉스가 빌드할 때 buildTools에 있는 것들을 PATH에 추가한다.</span></span>
<span id="cb28-58"><a href="#cb28-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 실제 실행시키는 곳은 Setup.hs 또는 *.cabal 설정에서 실행시킨다.</span></span>
<span id="cb28-59"><a href="#cb28-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (drv: {   }) 기존 패키지 속성을 변경하는 람다 함수. </span></span>
<span id="cb28-60"><a href="#cb28-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 인자로 받은 derivation의 buildTools란 속성을 바꾸고 있다.</span></span>
<span id="cb28-61"><a href="#cb28-61" aria-hidden="true" tabindex="-1"></a>    <span class="va">frontend</span> <span class="op">=</span> overrideCabal super.frontend <span class="op">(</span><span class="va">drv</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb28-62"><a href="#cb28-62" aria-hidden="true" tabindex="-1"></a>      <span class="va">buildTools</span> <span class="op">=</span> <span class="op">(</span>drv.buildTools <span class="kw">or</span> <span class="op">[])</span> <span class="op">++</span> <span class="op">[</span> self.buildHaskellPackages.markdown-unlit <span class="op">];</span></span>
<span id="cb28-63"><a href="#cb28-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb28-64"><a href="#cb28-64" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb28-65"><a href="#cb28-65" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span></code></pre></div>
<p>※ <code>with obelisk;</code>라 하면, 다음 한 표현식 스코프안으로 <code>obelisk</code>가 가진 것들을 가져 온다.</p>
<h3 id="flake-y-nix-에서-haskell.nix-사용하는-방법">flake-y nix 에서 haskell.nix 사용하는 방법</h3>
<div class="sourceCode" id="cb29"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>nix flake init --template templates#haskell-nix --impure</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a># `--impure` is required by `builtins.currentSystem`</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>nix develop</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>cabal build</span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>nix flake show</span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>nix build .#hello:exe:hello</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>nix run .#hello:exe:hello</span></code></pre></div>
<h3 id="hix">Hix</h3>
<p>기존 하스켈 프로젝트에 <code>haskell.nix</code> 지원을 추가하는 간편한 방법을 제공하는 명령줄 도구<br />
<code>hix init</code> 명령은 <code>flake.nix</code>와 <code>nix/hix.nix</code>파일을 추가한다. 이렇게 하면, 프로젝트를 보통의 nix 도구들로 작업할 수 있게 된다.<br />
</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>cabal unpack hello</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>cd hello-1.0.0.2</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>nix run &quot;github:input-output-hk/haskell.nix#hix&quot; -- init</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>nix develop</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>cabal build</span></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>nix flake show</span></code></pre></div>
<div class="sourceCode" id="cb35"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>nix build .#hello:exe:hello</span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>nix run .#hello:exe:hello</span></code></pre></div>
<p>다른 Hix 특징들을 쓰려면 Hix를 설치한다.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>nix-env -iA hix -f https://github.com/input-output-hk/haskell.nix/tarball/master</span></code></pre></div>
<p>최신 버전을 쓰려면</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>hix update</span></code></pre></div>
<p><code>hix develop</code>, <code>hix flake</code>, <code>hix build</code>, <code>hix run</code> 등, <code>nix</code>를 쓰듯 쓰는 게 인상적이다. 분명 nix flake에 익숙하다면 장점이 될 것 같다.</p>
<p>이들 명령은 <code>flake.nix</code>를 쓰지 않고, 닉스 버전과 동일하게 작동한다는데, 무슨 말이지? hix는 flake를 쓰는 것 아니었나?
프로젝트 루트에 <code>flake.nix</code> 파일을 만들지 않아도, <code>flake.nix</code> 파일이 있을 때 <code>nix</code> 명령을 사용하듯 <code>hix</code>를 사용할 수 있다는 뜻이다. hix는 <code>.hix-flake/flake.nix</code> 에서 자동으로 flake를 관리하고, 사용자는 신경 쓸 필요 없다. 직접 <code>flake.nix</code> 파일을 만들고 유지하고 싶지 않을 때 쓰기 좋다. (반면, haskell-flake는 프로젝트 루트에 <code>flake.nix</code> 파일을 직접 만들고 유지해야 한다.)</p>
<p>hix는 <code>haskell.nix</code> 스타일을 쓰면서, 필요할 때 <code>.hix-flake/flake.nix</code> 내부에서 flakes를 관리하며, flake와 비슷한 인터페이스를 제공한다.</p>
<h2 id="haskell-support-for-nix">Haskell Support for Nix</h2>
<p><a href="https://haskell4nix.readthedocs.io/">haskell4nix</a><br />
</p>
<h3 id="flake를-쓰지-않고-하스켈-패키지를-닉스로-설치">Flake를 쓰지 않고, 하스켈 패키지를 닉스로 설치</h3>
<p>Hackage에 등록되어 있는 모든 하스켈 패키지를 위한 빌드 지침instruction을 배포 중이다. 그런데, 닉스 패키지 검색을 하면, <code>ghc</code>, <code>cabal-install</code>, <code>stack</code> 말고는 나오는 게 없다. 하스켈 패키지는 너무 많아서 탑레벨 네임 스페이스에 등록되어 있지 않다. 탑레벨에 두면 검색이 너무 느려져서 <code>haskellPackages</code> 속성으로 분리되어 있다.</p>
<p>기본적인 설치</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>nix-env -f &quot;&lt;nixpkgs&gt;&quot; -iA haskellPackages.Allure ...</span></code></pre></div>
<p><code>-f</code>(<code>--file</code>): Nix 표현식 파일을 지정할 때. <code>&lt;nixpkgs&gt;</code>는 시스템에 설치된 Nixpkgs 경로<br />
<code>-i</code>(<code>--install</code>): 설치<br />
<code>-A</code>(<code>--attr</code>): 속성을 통해 패키지를 지정. <code>Allure</code>는, 패키지는 표현식으론 <code>haskellPackages</code>의 속성이다. 이 옵션 없이는 <code>&lt;nixpkgs&gt;</code>의 최상위 속성에서 해당 패키지를 찾는다.<br />
</p>
<p>“Nixpkgs 채널의 최신 버전에서 <code>haskellPackages</code> 속성 집합 안에서 <code>Allure</code> 속성을 찾아 설치하라”란 뜻이다.</p>
<p><code>haskell-</code>로 시작하는 패키지는 라이브러리(와 실행 파일)를 제공하고, 그렇지 않은 패키지는 실행 파일을 제공한다. 예를 들어, <code>haskell-pandoc</code>은 라이브러리와 실행 애플리케이션을 같이 설치한다.</p>
<p>NixOS라면 <code>-f "&lt;nixpkgs&gt;"</code>를 안쓰고, <code>nixos.</code>을 붙여 <code>nixos.haskellPackages</code>를 찾으라 하면 된다.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>nix-env -qaP -A nixos.haskellPackages</span></code></pre></div>
<p><code>-q</code>(<code>--query</code>): 현재 사용할 수 있는 패키지 조회(아무 옵션 없이 쓰면, 현재 사용자 환경에 설치된 패키지에서만 조회)<br />
<code>-a</code>(<code>--available</code>): 설치되지 않은 패키지도 포함해서, 사용할 수 있는 모든 패키지<br />
<code>-P</code>(<code>--attr-path</code>): 패키지의 속성 경로도 출력. 예를 들어 <code>lens</code> 라 출력하지 않고, <code>nixos.haskellPackages.lens</code>라 출력<br />
<code>-A</code>: 지정 속성만 조회. 예를 들어 <code>-A nixos.haskellPackages</code>를 하면, <code>haskellPackages</code>아래 모든 속성(패키지)을 나열</p>
<p>컴파일러와 해당 컴파일러로 컴파일한 패키지가 묶여 있다.<br />
<code>haskellPackages</code>는 <code>haskell.packages.ghcXYZ</code>(<code>XYZ</code>는 <code>Nixpkg</code>에 있는 디폴트 버전)의 alias다.</p>
<p>하스켈 패키지는 일반적으로 Hackage에 있는 릴리즈를 기반으로 생성되지만, Hackage는 패키지 빌드를 위한 소스 코드도 제공하므로, 필요에 따라 소스 코드를 직접 다운 받아 패키지를 설치할 수도 있다.</p>
<h3 id="패키지-브랜치-설치하기">패키지 브랜치 설치하기</h3>
<div class="sourceCode" id="cb41"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>my<span class="op">-</span>hledger<span class="op">-</span>lib = <span class="op">(</span>haskell.lib.overrideSrc haskellPackages.hledger<span class="op">-</span>lib <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">src</span> <span class="op">=</span> <span class="ss">/home/aengelen/dev/hledger/hledger-lib</span><span class="op">;</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="op">})</span>;</span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>my<span class="op">-</span>hledger = <span class="op">(</span>haskell.lib.overrideSrc haskellPackages.hledger <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">src</span> <span class="op">=</span> <span class="ss">/home/aengelen/dev/hledger/hledger</span><span class="op">;</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="op">})</span>.override <span class="op">{</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">hledger-lib</span> <span class="op">=</span> my<span class="op">-</span>hledger<span class="op">-</span>lib<span class="op">;</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>;</span></code></pre></div>
<div class="sourceCode" id="cb43"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>hledger<span class="op">-</span>web = haskell.lib.justStaticExecutables <span class="op">(</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>haskell.lib.overrideSrc haskellPackages.hledger<span class="op">-</span>web <span class="op">{</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>      <span class="va">src</span> <span class="op">=</span> <span class="ss">/home/aengelen/dev/hledger/hledger-web</span><span class="op">;</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">})</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>  .override <span class="op">{</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">hledger</span> <span class="op">=</span> my<span class="op">-</span>hledger<span class="op">;</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="va">hledger-lib</span> <span class="op">=</span> my<span class="op">-</span>hledger<span class="op">-</span>lib<span class="op">;</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">})</span>;</span></code></pre></div>
<p><code>overrideSrc { src, version } drv</code>: derivation <code>drv</code>를 만드는데 쓰인 소스를 <code>src</code> 경로에 있는 것으로 바꾼다. <code>version</code> 속성은 옵션이다.<br />
<code>.override</code>: 패키지의 속성을 변경한다.</p>
<h3 id="개발-환경-생성">개발 환경 생성</h3>
<h4 id="컴파일러-설치">컴파일러 설치</h4>
<div class="sourceCode" id="cb44"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>nix-env -f &quot;&lt;nixpkgs&gt;&quot; -iA haskellPackages.ghc haskellPackages.cabal-install</span></code></pre></div>
<p>위 명령으론 설치된 바이너리들이 있는 폴더가 자동으로 <code>$PATH</code> 잡히지 않지만, 아래 명령은 자동으로 잡힌다.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>nix-shell -p haskell.compiler.ghc784</span></code></pre></div>
<p>Stack의 Nix 지원을 켜면, Stack이 내부적으로 <code>nix-shell</code>을 이용한다.</p>
<p><code>nix-shell</code>로 만든 Nix 저장소 경로는 <code>nix-shell</code>이 종료되면, “alive”가 아닌 상태가 되어 <code>nix-collect-garbage</code>하면 사라져서 환경이 깨질 수 있다. 그럴 땐, <code>nix-shell</code>에서 <code>cabal-configure</code>를 다시 실행하면 된다.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>nix-shell -p haskell.compiler.ghc784 --command &quot;cabal configure&quot;</span></code></pre></div>
<p>configure phase는 GHC를 비롯한 모든 필요한 툴의 절대 경로(<code>/nix/store</code>아래 경로)를 <code>dist/</code> 디렉토리 안의 빌드 설정에 기록한다. <code>dist/</code> 디렉토리는 빌드 과정에서 생성되는 다양한 파일들(설정 파일, 컴파일된 오브젝트 파일, 라이브러리, 실행 파일)이 저장된다. 절대 경로가 저장되는 파일은, <code>dist/setup-config</code>, <code>dist/build/*</code> 등에 키-값 쌍같은 구조로 저장된다.</p>
<h4 id="컴파일러와-라이브러리-설치">컴파일러와 라이브러리 설치</h4>
<p>기본적으로 GHC는 자신의 <code>lib</code>디렉토리에 모든 라이브러리가 설치될 것이라 가정한다. 이 방식은 전통적인 Unix 계열 시스템에선 문제 없지만, 닉스에선 작동하지 않는다. 닉스에서 GHC의 저장 경로는 한 번 빌드되면 불변이다. 추가로 라이브러리를 해당 경로에 넣을 수 없다. GHC는 자신의 코어 라이브러리 <code>base</code>, <code>containers</code>, <code>Cabal</code>등을 제외한 다른 라이브러리는 어디있는지 모르게 된다. GHC가 추가 라이브러리들이 어디 있는지 알게 하려면 특별 빌드 함수인 <code>ghcWithPackages</code> 함수로 빌드해야 한다. 이 함수는 “<strong>하스켈 패키지의 속성 집합을 패키지 리스트에 매핑하는 함수</strong>”를 인자로 받는다. 예를 들어 <code>ghcWithPackages (pkgs: [pkgs.mtl])</code> 표현식은 <code>mtl</code> 라이브러리를 가진 GHC 복제 패키지를 생성한다. GHC 복제는 기존에 코어만 가지고 있던 GHC 패키지들을 alias로 가지고 있다.</p>
<p>새로운 프로젝트마다, 프로젝트가 필요한 라이브러리들이 추가된 GHC복제 패키지를 각 각 가지고 있다.</p>
<p>현재 nix-shell에 등록된 패키지를 보려면</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>[nix-shell:~]$ ghc-pkg list mtl</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>/nix/store/zy79...-ghc-7.10.2/lib/ghc-7.10.2/package.conf.d: mtl-2.2.1</span></code></pre></div>
<p><code>ghcWithPackages</code> 함수로 override해서, 사용자들은 자신만의 원하는 환경을 만들 수있다. 다음 코드 조각snippet을 <code>~/.config/nixpkgs/config.nix</code>에 추가하고,</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">packageOverrides</span> <span class="op">=</span> <span class="va">super</span> <span class="op">:</span> <span class="kw">let</span> <span class="va">self</span> <span class="op">=</span> super.pkgs<span class="op">;</span> <span class="kw">in</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">myHaskellEnv</span> <span class="op">=</span> self.haskell.packages.ghc7102.ghcWithPackages</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>                     <span class="op">(</span><span class="va">haskellPackages</span><span class="op">:</span> <span class="kw">with</span> haskellPackages<span class="op">;</span> <span class="op">[</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>                       <span class="co"># 라이브러리</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>                       arrows async cgi criterion</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>                       <span class="co"># 도구 </span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>                       cabal-install haskintex</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>                     <span class="op">]);</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a><span class="er">}</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 위 코드는 ghcWithPackages (pkgs: [pkgs.mtl]) 모양 그대로이다.</span></span></code></pre></div>
<p><code>nix-env -f "&lt;nixpkgs&gt;" -iA myHaskellEnv</code>로 컴파일러와 환경을 같이 준비할 수 있다.</p>
<p>위 표현식으로 닉스가 생성한 <code>ghc</code> 프로그램은, 사실 새로운 <code>lib</code> 디렉토리를 쓰도록 지정한 <strong>실제 GHC의 래핑 스크립트</strong>다.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>&gt; cat $(type -p ghc)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>#! /nix/sotre/xlxj...-bash-4.3-p33/bin/bash -e</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>export NIX_GHC=/nix/store/19sm...-ghc-7.10.2/bin/ghc</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>export NIX_GHCPKG=/nix/sotre/19sm...-ghc-7.10.2/bin/ghc-pkg</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>export NIX_GHC_DOCDIR=/nix/store/19sm...-ghc-7.10.2/share/doc/ghc/html</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>export NIX_GHC_LIBDIR=/nix/store/19sm...-ghc-7.10.2/lib/ghc-7.10.2</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>exec /nix/store/j50p...-ghc-7.10.2/bin/ghc &quot;-B$NIX_GHC_LIBDIR&quot; &quot;$@&quot;</span></code></pre></div>
<p>※ <code>type -p</code> <code>type 명령어</code>는 명령어가 어떻게 해석되는지(alias, 함수, 내장 명령어, 파일 …) 알려 준다. <code>-p</code>를 주면 파일 경로만 출력한다.<br />
※ <code>-B</code> GHC의 라이브러리 경로를 지정, <code>$@</code> 쉘스크립트에 전달 된 모든 인수를 뜻한다.</p>
<h4 id="컴파일러와-라이브러리-그리고-후글-문서-인덱스-설치">컴파일러와 라이브러리, 그리고 후글, 문서 인덱스 설치</h4>
<p>위에 <code>ghcWithPackages</code>를 <code>ghcWithHoogle</code>로 바꾸면, 라이브러리들의 문서haddock도 같이 설치하고, 위에 <code>ghc</code> 스크립트처럼, 새로 설치한 문서 위치를 인식하게 설정하는 <code>hoogle</code> 래핑 스크립트를 만든다.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">packageOverrides</span> <span class="op">=</span> <span class="va">super</span><span class="op">:</span> <span class="kw">let</span> <span class="va">self</span> <span class="op">=</span> super.pkgs<span class="op">;</span> <span class="kw">in</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">myHaskellEnv</span> <span class="op">=</span> self.haskellPackages.ghcWithHoogle</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>                     <span class="op">(</span><span class="va">haskellPackages</span><span class="op">:</span> <span class="kw">with</span> haskellPackages<span class="op">;[</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>                       <span class="co"># 라이브러리</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>                       arrows async cgi criterion</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>                       <span class="co"># 도구</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>                       cabal-install haskintex</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>                     <span class="op">]);</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="haskell-language-server-설치">haskell-language-server 설치</h4>
<p>Hls는 현재 프로젝트가 쓰는 GHC버전으로 컴파일되어 있어야 한다.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>pkgs.haskell-language-server.override { supportedGhcVersions = [ &quot;884&quot; &quot;901&quot; ] }</span></code></pre></div>
<p><code>haskell-language-server-wrapper</code>를 실행하면, cabal이나 stack을 보고, 현재 프로젝트에 쓰이는 버전을 찾게 되고, path에 잡혀 있는 바이너리 중 적합한 걸 고른다.</p>
<h4 id="nix-shell에서-haskell-language-server가-ghc-찾기">nix-shell에서 haskell-language-server가 GHC 찾기</h4>
<div class="sourceCode" id="cb52"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>&gt; nix-shell</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>[nix-shell] &gt; code .</span></code></pre></div>
<p>파일을 편집하고 싶을 때마다 nix-shell 실행해야 하는 건 번거롭다. <code>direnv</code>로 해결할 수 있다.</p>
<h4 id="stack으로-하스켈-프로젝트-빌드">stack으로 하스켈 프로젝트 빌드</h4>
<p><code>--nix</code> 플래그를 주면, 내부에서 닉스를 쓴다.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>&gt; git clone --recurse-submodules https://github.com/yesodweb/wai.git</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>&gt; cd wai</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>&gt; stack --nix build</span></code></pre></div>
<p>기본으로 닉스를 쓰게 하려면 <code>stack.yaml</code>에 다음을 추가한다.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">nix</span><span class="kw">:</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">enable</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">packages</span><span class="kw">:</span><span class="at"> </span><span class="kw">[</span><span class="at">pkgconfig zeromq zlib</span><span class="kw">]</span></span></code></pre></div>
<p>이렇게 하면, 모든 stack 명령어는 Nixpkgs에 있는 <code>pkgconfig</code>, <code>zeromq</code>, <code>zlib</code>를 쓸 수 있는 환경에서 실행된다.</p>
<p>좀 더 복잡한 요구 사항이 있을 땐, <code>shell</code>필드를 이용할 수 있다.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">nix</span><span class="kw">:</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">enable</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">shell-file</span><span class="kw">:</span><span class="at"> shell.nix</span></span></code></pre></div>
<p><code>mkDerivation</code>을 래핑하고 있는 <code>haskell.lib.buildStackProject</code>함수를 써서 derivation을 만든다.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span><span class="va">nixpkgs</span> <span class="op">?</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{</span> <span class="op">},</span> <span class="va">ghc</span> <span class="op">?</span> nixpkgs.ghc <span class="op">}</span>:</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">with</span> nixpkgs<span class="op">;</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="va">R</span> <span class="op">=</span> pkgs.R.override <span class="op">{</span> <span class="va">enableStrictBarrier</span> <span class="op">=</span> <span class="cn">true</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>haskell.lib.buildStackProject <span class="op">{</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>  <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;HaskellR&quot;</span><span class="op">;</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>  <span class="va">buildInputs</span> <span class="op">=</span> <span class="op">[</span> R zeromq zlib <span class="op">];</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">inherit</span> ghc<span class="op">;</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="nix-shell을-위한-ad-hoc-환경">nix-shell을 위한 ad hoc 환경</h4>
<p>ad hoc한 개발 환경을 만드는 가장 편한 방법은, 적절한 GHC 환경을 명령줄에서 써주면 된다.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>nix-shell -p &quot;haskellPackages.ghcWithPackages (pkgs: with pkg; [mtl pandoc])&quot;</span></code></pre></div>
<p>환경이 복잡하면 <code>shell.nix</code>를 쓴다.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">nixpkgs</span> <span class="op">?</span> <span class="bu">import</span> &lt;nixpkg&gt; <span class="op">{},</span> <span class="va">compiler</span> <span class="op">?</span> <span class="st">&quot;ghc7102&quot;</span> <span class="op">}</span>:</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>  <span class="va">inherit</span> (<span class="va">nixpkgs</span>) <span class="va">pkgs</span>;</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">ghc</span> <span class="op">=</span> pkgs.haskell.packages.$<span class="op">{</span><span class="va">compiler</span><span class="op">}</span>.ghcWithPackages <span class="op">(</span><span class="va">ps</span><span class="op">:</span> <span class="kw">with</span> ps<span class="op">;</span> <span class="op">[</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>          monad-par mtl</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">]);</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>pkgs.stdenv.mkDerivation <span class="op">{</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>  <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;my-haskell-env-0&quot;</span><span class="op">;</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>  <span class="va">buildInputs</span> <span class="op">=</span> <span class="op">[</span> ghc <span class="op">];</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>  <span class="va">shellHook</span> <span class="op">=</span> <span class="st">&quot;eval $(egrep ^export </span><span class="sc">${</span>ghc<span class="sc">}</span><span class="st">/bin/ghc)&quot;</span><span class="op">;</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>다른 버전의 컴파일러 쓰려면</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>nix-shell --argstr compiler ghc784</span></code></pre></div>
<p>Hackage에 있는 Lens를 해킹한다고 가정하면</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>&gt; cabal get lens-4.11 &amp;&amp; cd lens-4.11</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>Downloading lens-4.11...</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>Unpacking to lens-4.11/</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>&gt; nix-shell &quot;&lt;nixpkgs&gt;&quot; -A haskellPackages.lens.env</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>[nix-shell:/tmp/lens-4.11] &gt; </span></code></pre></div>
<p><code>cabal-install</code>도 nix-shell 환경이 제공하는 것이 아니니, 설치하고 <code>$PATH</code>에 잡아 주어야 한다.</p>
<h3 id="특정-프로젝트만을-위한-하스켈-패키지">특정 프로젝트만을 위한 하스켈 패키지</h3>
<p><code>cabal2nix</code>를 쓰면 Cabal로 빌드하는 프로젝트를 자동으로 Nix로 빌드할 수 있게 바꿀 수 있다. <code>nix-env -i cabal2nix</code>
#### stand-alone 프로젝트 빌드
현재 프로젝트 <code>foo</code>의 루트 디렉토리에서</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>cabal2nix . &gt; foo.nix</span></code></pre></div>
<p>그리고, <code>default.nix</code>에 다음 코드를 추가한다.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">nixpkgs</span> <span class="op">?</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{},</span> <span class="va">compiler</span> <span class="op">?</span> <span class="st">&quot;ghc7102&quot;</span> <span class="op">}</span>:</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>nixpkgs.pkgs.haskell.packages.$<span class="op">{</span><span class="va">compiler</span><span class="op">}</span>.callPackage <span class="ss">./foo.nix</span> <span class="op">{</span> <span class="op">}</span></span></code></pre></div>
<p>개발 환경을 위해 <code>shell.nix</code>에 다음을 추가한다.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="va">nixpkgs</span> <span class="op">?</span> <span class="bu">import</span> &lt;nixpkgs&gt; <span class="op">{},</span> <span class="va">compiler</span> <span class="op">?</span> <span class="st">&quot;ghc7102&quot;</span> <span class="op">}</span>:</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="op">(</span><span class="bu">import</span> <span class="ss">./default.nix</span> <span class="op">{</span> <span class="kw">inherit</span> nixpkgs compiler<span class="op">;</span> <span class="op">})</span>.env</span></code></pre></div>
<p>위 파일들 준비가 끝나면, <code>nix-build</code>로 빌드하고, Nix 저장소에 설치할 수 있다. 로컬 디렉토리에는 이를 가리키는 <code>result</code>라는 심볼릭 링크 디렉토리가 생긴다. 또한, nix-shell로 들어가면, 필요한 GHC 버전, 라이브러리, 시스템 레벨의 라이브러리등이 잡힌 상태의 환경에서 <code>cabal configure</code>, <code>cabal build</code>를 쓰며 개발할 수도 있다.</p>
<p>만일, 시스템 레벨의 라이브러리가 전혀 필요하지 않으면, 위에서 준비한 <code>.nix</code> 파일들 없이</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>nix-shell --command &quot;cabal configure&quot;</span></code></pre></div>
<p>를 실행하는 것으로 준비가 끝난다. 위 명령어를 실행하면, <code>cabal-install</code> 패키지가 빌드에 필요한 모든 자원들의 절대 경로를 찾아 <code>dist/</code> 디렉토리 안의 설정 파일들에 기록한다. 이 후, nix-shell 환경이 아닐 때 처럼 <code>cabal build</code> 같은 명령들을 실행할 수 있다.</p>
<p>default.nix, shell.nix를 직접 만들지 않고, 기본적인 내용으로 준비하려면</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>cabal2nix --shell . &gt; shell.nix</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>nix-shell --command &quot;cabal configure&quot;</span></code></pre></div>
<p>이 후, <code>nix-build shell.nix</code>를 실행해서 빌드 할 수 있다.</p>
<h4 id="서로-의존하는-프로젝트-빌드">서로 의존하는 프로젝트 빌드</h4>
<p>각 프로젝트의 cabal 정보를 읽어 <code>default.nix</code>를 준비하고,</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>cd ~/src/foo &amp;&amp; cabal2nix . &gt; default.nix</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>cd ~/src/bar &amp;&amp; cabal2nix . &gt; default.nix</span></code></pre></div>
<p>디폴트 하스켈 패키지 집합에 빌드 결과물을 등록한다.
<code>~/.config/nixpkgs/config.nix</code></p>
<div class="sourceCode" id="cb67"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">packageOverrides</span> <span class="op">=</span> <span class="va">super</span><span class="op">:</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">haskellPackages</span> <span class="op">=</span> super.haskellPackages.override <span class="op">{</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>      <span class="va">overrides</span> <span class="op">=</span> <span class="va">self</span><span class="op">:</span> <span class="va">super</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">foo</span> <span class="op">=</span> self.callPackage <span class="ss">../src/foo</span> <span class="op">{};</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">bar</span> <span class="op">=</span> self.callPackage <span class="ss">../src/bar</span> <span class="op">{};</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>이제 <code>nix-env -f "&lt;nixpkgs&gt;" -qA haskellPackages</code>하면, Hackage의 다른 패키지처럼 <code>foo</code>와 <code>bar</code>를 볼 수 있고, 다음처럼 빌드할 수 있다.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>nix-build &quot;&lt;nixpkgs&gt;&quot; -A haskellPackages.foo</span></code></pre></div>
<p>개발 환경에 들어가려면,</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>nix-shell &quot;&lt;nixpkgs&gt;&quot; -A haskellPackages.bar.env</span></code></pre></div>
<h2 id="haskell-flake">haskell-flake</h2>
<p><a href="https://github.com/srid/haskell-flake">srid/haskell-flake</a><br />
<a href="https://flake.parts/">flake-parts</a> 모듈로 셋업한다. Cabal만 지원한다.(Stack은 지원하지 않는 것 같다.) 프로젝트 탑레벨에 <code>.cabal</code>이나 <code>cabal.xproject</code>가 있어야만 한다.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>&gt; mkdir example &amp;&amp; cd ./example</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>&gt; nix flake init -t github:srid/haskell-flake#example</span></code></pre></div>
<h2 id="하스켈-프로젝트-닉스화nixifying">하스켈 프로젝트 닉스화Nixifying</h2>
<p>아래는 <a href="https://nixos.asia/en/haskell">nixos.asia</a> 페이지를 정리한 노트이다.</p>
<h3 id="프로젝트-닉스화">프로젝트 닉스화</h3>
<p><strong>haskellPackages</strong></p>
<p><strong>callCabal2nix</strong><br />
<code>cabal2nix</code>이 <code>.cabal</code> 파일을 읽어들여 “닉스 derivation을 생성하는 닉스 표현식”을 만들고, 이 닉스 표현식을 평가해서 derivation을 만든다. <code>cabal2nix</code>가 만든 닉스 표현식에는 <code>mkDerivation</code> 함수나, <code>mkDrivation</code>을 특정 목적으로 래핑한 함수가 들어가 있다.</p>
<p>※ 뜬금없이 예시를 따라하다 <code>nix repl</code> 멀티라인에서 막혔다.<br />
원문 예시 중 <code>repl</code>에서 멀티라인 입력이 필요한 부분이 있는데, 원문을 따라하면 입력이 되지 않는다. repl은 구문이 끝났는지, 안 끝났는지 추론해서 결정한다. 예전엔 <code>extend</code>함수로 끝난 첫 줄이, 아직 덜 끝난 걸로 인식했었나 본데, 지금은 그렇지 않다. <code>extend</code> 뒤에 아직 구문이 끝나지 않았다는 표시로 <code>(</code>를 써준다.</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>nix-repl&gt; myHaskellPackages = pkgs.haskellPackages.extend </span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    (self: super: {</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>       shower = self.callCabal2nix &quot;shower&quot; </span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>         (pkgs.fetchgit { </span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a>            url = &quot;https://github.com/monadfix/shower.git&quot;;</span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>            rev = &quot;2d71ea1&quot;; </span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>            sha256 = &quot;sha256-vEck97PptccrMX47uFGjoBVSe4sQqNEsclZOYfEMTns=&quot;; </span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>         }) {}; </span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a>    })</span></code></pre></div>
<p><code>extend</code>함수가 인자로 <code>self: super: { ... }</code> 람다 함수를 받고 있다. <code>super</code>에는 확장되기 이전의 패키지 집합이 들어가고, <code>self</code>는 확장된 이후의 패키지 집합이 들어간다. (아마도 이렇게 되려면 fix 패턴을 쓰고 있겠지?)<br />
</p>
<ul>
<li><code>super</code>: <code>pkgs.haskellPackages</code>의 기존 상태를 참조한다. <code>Nixpkgs</code>에 정의되어 있는 하스켈 패키지 <code>ghc</code>,<code>base</code>,<code>lens</code>,<code>text</code>, …등과 하스켈 관련 유틸리티 함수 <code>callCabal2nix</code>, <code>callHackage</code> 등이 포함된다.</li>
<li><code>self</code>: <code>super</code>에 <code>extend</code>를 적용한 새로운 하스켈 패키지 집합</li>
</ul>
<p><strong>Overlay</strong><br />
<code>haskellPackages</code>에 있는 패키지를 덮어 씌우거나override, 추가할 때</p>
<h3 id="devshell-닉스화">devShell 닉스화</h3>
<p><code>nix develop</code>을 실행하면, <code>flake.nix</code>의 <code>outputs</code>에 있는 <code>devShell</code> 설정을 지침으로 삼아 쉘을 준비한다.</p>
<p>빌드가 아니라 개발이 목표일 때.<br />
어차피 두 경우 모두 필요한 라이브러리는 같은게 아닐까 싶지만, 개발 쉘에는 <code>ghcid</code>같은 도구나, 테스트 프레임워크, LSP서버, 디버깅 도구 같은 것들이 추가로 필요하다.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">inputs</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">nixpkgs</span>.<span class="va">url</span> <span class="op">=</span> <span class="st">&quot;github:NixOS/nixpkgs/nixpkgs-unstable&quot;</span><span class="op">;</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">outputs</span> <span class="op">=</span> <span class="op">{</span> <span class="va">self</span><span class="op">,</span> <span class="va">nixpkgs</span> <span class="op">}</span>:</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>      <span class="va">system</span> <span class="op">=</span> <span class="st">&quot;aarch64-darwin&quot;</span><span class="op">;</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>      <span class="va">pkgs</span> <span class="op">=</span> nixpkgs.legacyPackages.$<span class="op">{</span><span class="va">system</span><span class="op">};</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>      <span class="va">overlay</span> <span class="op">=</span> <span class="va">final</span><span class="op">:</span> <span class="va">prev</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">todo-app</span> <span class="op">=</span> final.callCabal2nix <span class="st">&quot;todo-app&quot;</span> <span class="ss">./.</span> <span class="op">{</span> <span class="op">};</span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>      <span class="va">myHaskellPackages</span> <span class="op">=</span> pkgs.haskellPackages.extend.overlay<span class="op">;</span></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>      <span class="va">devShells</span>.${<span class="va">system</span><span class="op">}</span>.default = myHaskellPackages.shellFor <span class="op">{</span></span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">packages</span> <span class="op">=</span> <span class="va">p</span> <span class="op">:</span> <span class="op">[</span></span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>          p.todo-app</span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">]</span>:</span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>        nativeBuildInputs = <span class="kw">with</span> myHaskellPackages<span class="op">;</span> <span class="op">[</span></span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>          ghcid</span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>          cabal-install</span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">]</span></span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>      <span class="er">}</span></span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>    <span class="er">}</span></span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p><strong>mkShell 함수</strong> 언어와 무관하게 쓴다.<br />
<strong>shellFor</strong> 하스켈만을 위한 함수. <code>mkShell</code>위에 만든 abstraction이라 한다.<br />
모든 하스켈 패키지는 <code>shellFor</code>를 가지고 있다. Haskell package로 구성된configured GHC 패키지셋을 가진 <code>devShell</code>을 반환한다.<br />
</p>
<p>두 개의 인자를 받는다.<br />
<code>packages</code> : 로컬 하스켈 패키지를 의미한다.<br />
<code>nativeBuildInputs</code> : <code>devShell</code>의 <code>PATH</code>에서 사용 가능하도록 제공할 프로그램을 의미, 개발에 필요한 도구들을 지정한다.</p>
<h3 id="외부-의존성-닉스화">외부 의존성 닉스화</h3>
<p>전역 시스템을 건드리지 않고, 현재 프로젝트 환경에서만 쓸 외부 의존성을 준비해보자.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode nix"><code class="sourceCode nix"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>  <span class="va">inputs</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">nixpkgs</span>.<span class="va">url</span> <span class="op">=</span> <span class="st">&quot;github:NixOS/nixpkgs/nixpkgs-unstable&quot;</span><span class="op">;</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>  <span class="va">outputs</span> <span class="op">=</span> <span class="op">{</span> <span class="va">self</span><span class="op">,</span> <span class="va">nixpkgs</span> <span class="op">}</span>:</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>      <span class="va">system</span> <span class="op">=</span> <span class="st">&quot;aarch64-darwin&quot;</span><span class="op">;</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>      <span class="va">pkgs</span> <span class="op">=</span> nixpkgs.legacyPackages.$<span class="op">{</span><span class="va">system</span><span class="op">};</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb73-11"><a href="#cb73-11" aria-hidden="true" tabindex="-1"></a>      <span class="va">apps</span>.${<span class="va">system</span><span class="op">}</span>.postgress = <span class="op">{</span></span>
<span id="cb73-12"><a href="#cb73-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">type</span> <span class="op">=</span> <span class="st">&quot;app&quot;</span><span class="op">;</span></span>
<span id="cb73-13"><a href="#cb73-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">program</span> <span class="op">=</span></span>
<span id="cb73-14"><a href="#cb73-14" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span></span>
<span id="cb73-15"><a href="#cb73-15" aria-hidden="true" tabindex="-1"></a>            <span class="va">script</span> <span class="op">=</span> pkgs.writeShellApplication <span class="op">{</span></span>
<span id="cb73-16"><a href="#cb73-16" aria-hidden="true" tabindex="-1"></a>              <span class="va">name</span> <span class="op">=</span> <span class="st">&quot;pg_start&quot;</span><span class="op">;</span></span>
<span id="cb73-17"><a href="#cb73-17" aria-hidden="true" tabindex="-1"></a>              <span class="va">runtimeInputs</span> <span class="op">=</span> <span class="op">[</span> pkgs.postgresql <span class="op">];</span></span>
<span id="cb73-18"><a href="#cb73-18" aria-hidden="true" tabindex="-1"></a>              <span class="va">text</span> <span class="op">=</span></span>
<span id="cb73-19"><a href="#cb73-19" aria-hidden="true" tabindex="-1"></a>              <span class="st">''</span></span>
<span id="cb73-20"><a href="#cb73-20" aria-hidden="true" tabindex="-1"></a><span class="st">                # 현재 프로젝트 dir를 저장소로 데이터베이스 초기화</span></span>
<span id="cb73-21"><a href="#cb73-21" aria-hidden="true" tabindex="-1"></a><span class="st">                [ ! -d &quot;./data/db&quot; ] &amp;&amp; initdb --no-locale -D ./data/db</span></span>
<span id="cb73-22"><a href="#cb73-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-23"><a href="#cb73-23" aria-hidden="true" tabindex="-1"></a><span class="st">                postgres -D ./data/db -k &quot;$PWD&quot;/data</span></span>
<span id="cb73-24"><a href="#cb73-24" aria-hidden="true" tabindex="-1"></a><span class="st">              ''</span><span class="op">;</span></span>
<span id="cb73-25"><a href="#cb73-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">};</span></span>
<span id="cb73-26"><a href="#cb73-26" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span> <span class="st">&quot;</span><span class="sc">${</span>script<span class="sc">}</span><span class="st">/bin/pg_start&quot;</span><span class="op">;</span></span>
<span id="cb73-27"><a href="#cb73-27" aria-hidden="true" tabindex="-1"></a>      <span class="op">};</span></span>
<span id="cb73-28"><a href="#cb73-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>;</span>
<span id="cb73-29"><a href="#cb73-29" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p><code>nix run</code>으로 실행할 앱을 정의하고 있다. 여기서 앱은 Postgres 서버를 시작하는 간단한 쉘스크립트다. <code>nixpkgs</code>는 이런 스크립트를 위한 <code>writeShellApplication</code>이란 편리한 함수를 제공한다. <code>${script}</code>는 <code>nix/store</code>에서 앱이 저장된 위치를 뜻한다.</p>
<p>※ pkg-config<br />
라이브러리에 접근하는 표준 인터페이스 제공한다.<br />
<code>.pc</code>파일은 보통 <code>/usr/lib/pkgconfig</code> 또는 <code>/usr/lib64/pkgconfig</code>에 설치 된다. 만일 패키지가 <code>.pc</code> 파일을 생성하는 설정이 없다면, 수동으로 만들어 등록할 수도 있다.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>prefix=/usr</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>libdir=${prefix}/lib</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>includedir=${prefix}/include</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>Name: webkit2gtk-4.0 (필수) </span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>Description: WebKitGTK library (선택)</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>Version: 2.46.6 (필수)</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>Libs: -L${libdir} -lwebkit2gtk-4.0 (필수)</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>Cflags: -I${includedir}/webkitgtk-4.0 (필수)</span></code></pre></div>
<p>잘 설치 되었는지 확인</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>&gt; pkg-config --modversion webkit2gtk-4.0</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>&gt; pkg-config --libs webkit2gtk-4.0</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>&gt; pkg-config --cflags webkit2gtk-4.0</span></code></pre></div>
<p>※ WebkitGTK<br />
Webkit 렌더링 엔진을 GTK(그래픽 툴킷)와 통합한 라이브러리로, 주로 리눅스에서 웹브라우저나 웹컨텐체를 쓰는 애플리케이션을 개발하는데 쓰인다. GTK 버전에 따른 변형이 있다.</p>
<p><a href="https://nixos.wiki/wiki/Haskell">How to develop with Haskell and Nix</a><br />
</p>
<h2 id="nixpkgs-공식-문서-하스켈-섹션">Nixpkgs 공식 문서 하스켈 섹션</h2>
<p><a href="https://nixos.org/manual/nixpkgs/unstable/#haskell">하스켈 섹션</a><br />
Nixpkgs의 하스켈 인프라는 첫 째, 하스켈 <strong>컴파일러</strong>와 <strong>빌드 도구</strong>, 그리고 하스켈 패키지를 만들기 위한 <strong>패키징</strong> 인프라를 제공하고, 둘 째, 빌드된prebuilt 하스켈 라이브러리를 가지고 있는 하스켈 <strong>개발 환경</strong>을 제공하는 것을 목표로 한다.</p>
<h3 id="haskell-available-packages">가용한 패키지</h3>
<p>컴파일러와 대부분의 빌드 툴은 탑레벨에 위치한다.</p>
<ul>
<li>ghc: GHC 디폴트 버전</li>
<li>하스켈 전용 툴: <code>cabal-install</code>, <code>stack</code>, <code>hpack</code>, …</li>
<li><code>nix</code>, <code>cachix</code></li>
</ul>
<p>haskellPackages : Hackage에 있는 모든 패키지들 자체가 아니라, 패키지를 빌드할 수 있는 명세derivation를 생성할 수 있는 닉스 표현식을 가지고 있다.<br />
haskellPackages에 있는 속성attribute 이름은 항상 Hackage에 있는 같은 이름과 대응된다. Hackage에는 Nix에서 쓰지 않는 글자(<code>+</code>,<code>.</code>,…)도 이름으로 쓸 수 있으니, 완전히 같지 않을 수 있다.
Stackage에 있는 패키지일 경우, LTS스냅샷에 있는 버전을 디폴트 버전으로 갖고 있다.</p>
<p>만일, <code>defaultGhcVersion = "ghc94"</code>라면, <code>haskellPackages = haskell.packages.ghc94</code>와 같다. <code>haskellPackages</code>는 디폴트 버전의 심볼릭 링크다.</p>
<p><code>haskellPackages.foo</code>라 하면, 디폴트로 Hackage에 있는 것 중 최신 버전 <code>foo</code> 패키지를 뜻한다. Nixpkgs는 고정된 Hackage 스냅샷으로, 스냅샷을 뜰 시점의 최신 패키지다.</p>
<p><code>haskell.packages.lts_22_11</code>처럼 Stackage 스냅샷을 지정해서, 해당 스냅샷에 들어있는 버전을 디폴트로 쓸 수 있다.</p>
<p><code>haskellPackages.foo_x_y_z</code> 명시적인 버전 지정 <code>x.y.z</code>를, 닉스는 이름으로 <code>.</code>을 쓸 수 없으니, 언더바<code>_</code>로 바꾼다.</p>
<p><code>cabal-install</code>을 써서 하스켈 패키지를 빌드할 때, 의존성을 푸는데, Hackage에 있는 모든 버전을 확인한 후, 조건에 맞는 적절한 버전을 선택하려는 시도를 한다. 반면, Nixpkgs는 이런 시도 없이, 단순히 입력값으로 패키지 목록을 받아서, 이들이 조건을 충족하는지만 본다. (버전 제약 조건을 우회하라면 <code>jailbreak</code>를 쓴다.)</p>
<p><code>haskellPackages.mkDerivation</code>은 <code>stdenv.mkDerivation</code>의 래퍼다.</p>
<p><code>stdenv.mkDerivation</code>은 닉스의 패키지 빌드를 위한 derivation을 생성하는 기본 함수다. 이 함수는 패키지 빌드, 설치, 테스트등의 단계를 정의한다. <code>haskellPackages.mkDerivation</code>은 이 기본 함수가 가진 <code>configurePhase</code>, <code>buildPhase</code>, <code>installPhase</code> 이외에 하스켈에 특화된 단계들을 가지고 있다. Cabal 라이브러리를 앱을 통하지 않고 직접 사용하여 의존성을 해결하기 때문에 <code>cabal-install</code>의 바이너리는 쓰이지 않는다.</p>
<p>하스켈 프로젝트에선 <code>Setup.hs</code> 파일을 통해 빌드, 테스트, 설치등의 작업을 정의한다. <code>haskellPackages.mkDerivation</code>은 이를 직접 컴파일하고 실행해서 Haskell 프로젝트를 빌드한다.</p>

<div class="comment">
  <script>
    document.addEventListener('DOMContentLoaded', loadUtterances, { once: true });
  </script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>

  </div>
  <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
  <script>
    tocbot.init({
      tocSelector: '.js-toc',
      contentSelector: '.js-toc-content',
      headingSelector: 'h2, h3',
      hasInnerContainers: true,
    });
  </script>
  <div id="footer">
    © 2025 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
  </div>
</body>

</html>
