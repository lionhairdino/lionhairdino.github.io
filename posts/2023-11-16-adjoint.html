<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - Adjunction 관계의 두 Adjoint 펑터로 모나드 표현하기 (작성 중)</title>

        <meta name="description" content="카테고리 이론에서 모나드를 설명하는 방법 중 하나인 Adjoint Functor를 비수학적으로 해석합니다." />
        <meta property="og:description" content="카테고리 이론에서 모나드를 설명하는 방법 중 하나인 Adjoint Functor를 비수학적으로 해석합니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Adjunction 관계의 두 Adjoint 펑터로 모나드 표현하기 (작성 중)" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-11-16-adjoint.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

      <meta name="keywords" content="Monad, Functor, Identity, Natural Transformation, Isomorphic, Isomorphism">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>Adjunction 관계의 두 Adjoint 펑터로 모나드 표현하기 (작성 중)</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on November 16, 2023
    
</div>

<p><strong><em>주의</em></strong> - 아래 내용은 <strong><em>유사 수학</em></strong>이란 지적을 들은 적이 있습니다. 여기 설명이 어떤 분들이 보기에는 유사 수학일 수 있습니다. 애초에, 수학적인 의미보다는 개념이 가지고 있는 어떤 아이디어가 프로그래밍에, 하스켈에 녹아든 건지 찾는 게 목표로, 굳이 유사 수학이 아니라고 밀어 붙이진 않겠습니다. 주제는 수학에서 가져온 것이지만, 수학적인 의미를 찾는 분들을 위한 글이 아닙니다. 아마도 수학 전공이나, PL 전공분들이 보기에 적당하지 않은 상상, 그리고 당연히 오류가 있을 수 있습니다.</p>
<p>현재의 제 수학 배경으론 완벽히 이해하기엔 무리가 있지만, 적정선까지 이해를 하면, 함수형 프로그래밍으로 현실을 모델링할 때 분명 힘이 될 개념이라 생각합니다. 하스켈 프로그램은 하나의 거대한 모노이드로 만들어지니, 무언가를 같거나, 조금 다른 걸 우겨서라도 같다고 보는 테크닉이 중요합니다. 모나드는 (이펙트가 추가 되며) 조금 달라진 걸 원래의 것과 같게 볼 수 있는 방법에 대한 얘기였습니다. Adjunction도 두 개의 무언가가 얼마나 같은 가를 포멀하게 얘기하는 하나의 방법입니다. 둘이 연관성이 있을 거라 예측할 수 있습니다.
참고 - <a href="../posts/2022-03-25-beforeMonad.html">모나드, 같음 - m (m a)와 m a는 얼마나 다를까?</a></p>
<p>카테고리 이론에 대한 글을 남기는 건, 어설퍼서 잘 안하는데, 재미난 상상이 떠올라 남깁니다. 아래가 궁금하지 않은 분들은 읽을만한 글이 아닙니다. 항등, 동형, 펑터, 자연 변환에 대해 간단히 짚고 가긴 하지만, 부족한 설명들이니, 다른 정식 텍스트들을 통해 제대로 알아두시면 좋습니다.</p>
<ul>
<li>왜 두 개의 펑터로, 얼마나 같은지를 표현할까?</li>
<li>두 개가 얼마나 같은지를 따지는데 왜 자연 동형 얘기가 나올까?</li>
<li>왜 <code>ϵ</code>과 <code>η</code>의 화살표 방향이 반대일까?</li>
<li>모나드와 어떤 연관성이 있을까?</li>
</ul>
<p><code>=</code>을 쓸만큼 같지 않으면 <code>~</code>도 쓰고, <code>≃</code>, <code>⋍</code> …(<code>=</code>과 여러 기호의 조합)을 써서 그래도 어찌 보면, 어느 정도는 같게 볼 수 있다고 말하는 개념들이 많습니다. Adjunction도 그들 중 하나입니다.</p>
<p>다시 한 번 말하지만, 수학 카테고리 이론의 Adjunction을 정교하게 공부하려는 분에게 어울리는 글이 아닙니다.</p>
<h2 id="얼마나-같은-걸까">얼마나 같은 걸까</h2>
<p>모나드를 해석하면서, 이펙트가 섞여 있는 것들 타입을 맞춰 나가는 훈련을 했으니, “같다”는 개념에 약간의 지식이 생겼겠지 하고 붙었습니다. 하지만, 동형, 자연 변환 등의 기본 용어 조차, 어렵사리 어떤 동작을 하는지만 알지, 의미를 충분히 알지 못하고 있구나를 느꼈습니다. 역시, “같다”는 개념은 어려운 주제 같습니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>F∘G   = , ~=, -&gt;  id_D   </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>G∘F   = , ~=, -&gt;  id_C   </span></code></pre></div>
<p>위에 식 중 어떤 걸 만족하냐에 따라 <code>C</code>와 <code>D</code>의 조금씩 다른 관계를 표현할 수 있습니다. 여기에 숨은 뜻을 보기 위해 아래 질문들을 먼저 고민해 봤습니다.</p>
<p>isomorphic인 것과 homomorphic 중 isomorphic이 아닌 것들의 차이는 뭘까요? 구조는 유지하며 변환해 갔지만, 다시 처음으로 돌아오지 못한다입니다.(역연산이 존재하지 않음) 어떤 경우에 처음으로 돌아오지 못할까요? collapse 됐다거나 해서 처음 정보를 잃어버려야만 돌아 갈 수 없지 않을까 추측하고 있습니다. 처음을 잃어버려도 필요한 정보는 살아 있는 가장 간단한 경우를 예를 들면, <code>0</code>포함 자연수들에서 <code>1+2</code>의 결과로 <code>3</code>을 받았을 때, <code>3</code>만 보고선 <code>1+2</code>의 결과인지 <code>1+1+1</code>, <code>3+0</code>, …인지 알 수 없습니다. 하지만, 필요한 정보는 <code>3</code>이기 때문에 처음 출발지를 잃어버려도 상관없습니다. Writer 모나드의 로그 누적을 보면 <code>"this is log"</code>에서 <code>"this is"</code>가 먼저 쌓였는지 <code>"this"</code>가 먼저 쌓였는지 알 수 없습니다. 하지만 필요한 건 최종 전체 로그이니, 어떻게 쌓였는지 몰라도 상관없습니다. Reader 모나드의 경우 외부 스코프의 상수값을 두 번 읽어오나, 한 번 읽어오나 차이가 없으니, 몇 번을 읽었는지 알 필요가 없습니다. 세상엔 이 정도로만 같으면, 이 정도의 관계만 있으면 되는 경우가 무수히 많습니다.</p>
<p><code>id</code>와 자연 동형인 것과, <code>id</code>로 변환해주는 자연 변환이 있는 것의 차이가 뭘까요?<br />
카테고리가 동형인가를 알아보려면, 둘 사이에 id펑터 역할을 할 수 있는 펑터 조합이 있는가를 봅니다.<br />
펑터 조합이 id펑터와 동형인지 보려면, 자연 동형인가를 알아보고, 없다면 자연 동형이 되는 자연 변환이 있는가를 봅니다.<br />
그럼, 자연 변환이 동형인가를 보려면?
카테고리에선 대상 언급 없이 모든 걸 풀어나가니, 같음도 마찬가지입니다. 모피즘이 되는 것들이 id 모피즘과 같아지는지, 동형이 되는지등을 찾아 봅니다.</p>
<p>모르는 것 투성이라 글로 정리하는 게 의미있을까 싶어 계속 미루고 있었는데, 약간 기록할만한 상상이 생겨 정리했습니다.</p>
<h2 id="adjoint-adjunction-단어-뜻">Adjoint, Adjunction 단어 뜻</h2>
<p><code>Ad</code>(무엇과 가까이, 어디를 향해, 무엇과 관련하여) - <code>Joint</code>(jungere 결합하다)<br />
<code>Ad</code> - <code>Junction</code> “closely connected, joined, united”를 뜻하는 라틴어 Adjunction</p>
<p>일상 생활에서도 가끔 만나는 용어입니다. 고속도로와 고속도로가 만나서, 한 고속도로에서 다른 고속도로로 옮겨 갈 수 있는 연결 길을 Junction(JC, 우리말로는 분기점)이라 부릅니다.</p>
<p>선형 대수학에서 행렬 공부할 때 보이던 용어이긴 한데, 모나드 설명에 나오는 것과 어떤 개념이 이어지는지 명확하게 보이진 않습니다.</p>
<p>Adjunction 관계라 하면, 무슨 뜻인지 명확하게 정의하는 곳을 못 찾았습니다. 보통 둘이 특별한 관계가 있다는, 매우 추상적인 설명으로 (불친절하게) 끝나는 자료가 대부분입니다. 거의 같은 말이지만, 조금 더 구체적인 느낌을 주게 말하자면, <strong>혼자서는 특별한 일을 못하지만, 둘이 만나면 특별한 일을 해낼 수 있는 관계</strong>를 Adjunction 관계라 합니다. 이 특별한 일이란 게 어떤 동작으로 한정되는 게 아니라서, 딱 떨어지는 문장으로 정의한 곳이 없습니다. 예를 들어, 어떤 펑터가 혼자서는 별다른 일이 벌어지지 않지만, 적당한 짝이 되는 펑터를 만나면, 둘이선 모나드를 표현할 수 있습니다. 이 때 각 각을 오른 쪽, 왼 쪽 Adjoint 펑터라고 합니다.</p>
<p>혼자서는 아니지만, 둘이 뭉쳐(결합) 지구를 지킬 수 있으면 Adjunction 관계라 부릅니다.</p>
<p>※ 명사냐 형용사냐로 갈릴 뿐, Adjoint와 Adjunction은 뜻 자체는 거의 같은 뜻으로 쓰입니다.</p>
<p>아래 용어들은 몇 번을 봤던 개념들인데, 다 알고 있다 생각했는데, 의외로 혼란스러운 부분이 많았습니다. 항등원은 어떤 연산에 대해서 정의되는데, 항등 함수와 항등 펑터, 항등 자연 변환들은 어떤 “연산”에 대해 정의된 것인가부터, 텍스트마다 <code>F</code>, <code>id_F</code>를 펑터, 항등 펑터, 항등 자연 변환 표현으로 혼용해서 쓰는 바람에 더 혼란스러웠습니다. 항등X들은 정의와 성질을 혼동하기도 했습니다. 정식 정의들 보다는 Adjunction을 이해하는데 필요한 아이디어만 정리했습니다.</p>
<h2 id="펑터functor">펑터Functor</h2>
<p>카테고리에선 대상을 매핑하는 동작은 모피즘, 카테고리를 매핑하는 동작은 펑터라 부릅니다. 함수가 한 가지만 매핑한다면, 펑터는 오브젝트도, 모피즘도, 모피즘 합성도 모두 매핑(카테고리를 매핑)해야 합니다. 참고 - <a href="../posts/2023-03-09-functor.html">한 번쯤 나올 법 했는데, 아직 없었던 펑터 이야기</a></p>
<h2 id="동형isomorphic">동형isomorphic</h2>
<p>텍스트들의 설명으론, 구조가 같은 두 대상 사이에서 구조를 보존하는 사상을 isomorphism이라 합니다. 둘은 다르지만, isomorphism이 있으면(<strong>up to isomorphism</strong>), isomorphic하다고 말합니다.<br />
한 시스템에서 어떤 상태가 어디에서 출발해서 어떤, 어떤 값을 거쳐 어디에 도달하는 상황을 생각하면, 이를 모델링한 곳에서도 항상 동일한 경로로 변경이 되어, 모델링 한 것으로 현실을 완벽히 추적할 수도 있고, 거꾸로 현실에서 모델링한 것이 어떻게 값이 변해갈지 완벽히 추적할 수 있는 걸 말합니다. 두 시스템의 상태가 완전히 <strong>일대일 대응</strong>으로 어느 한 쪽을 알면, 다른 한 쪽도 알 수 있는 iso(같은)morphic(모양)이라 합니다.</p>
<p><code>homo-</code> 는 <code>same</code>을 의미하고, <code>iso-</code>는 <code>equal</code>을 의미한다고 합니다.<br />
<code>same</code>은 <code>identity</code>를 보는 것이고, <code>equal</code>은 <code>equality</code>를 본다고 합니다. 동어 반복 같은 설명입니다.<br />
“today’s exchange rate 1 dollar is <strong>equal</strong> to 0.91 euros. but they are not the <strong>same</strong> thing”<br />
구글링으로 여러 설명을 찾아 봐도 딱히 명쾌하단 느낌을 주는 설명이 없습니다. 대수에선 위 예문과 좀 다른듯 한데, 제 경험적으로 느끼는 건, 내가 주목하는, 필요로하는 구조는 같고, 그 외는 같을 수도, 다를 수도 있는 (거의 비슷한) 것에는 <code>homo-</code>를 붙이고, 모든 구조가 같아 일대일 대응이 되는 것(역변환이 되는 것)에는 <code>iso-</code>를 붙입니다.</p>
<h2 id="항등원identity">항등원Identity</h2>
<p>어떤 연산에 항등원Identity이라면, 항등원과 연산하면 원래 값이 바뀌지 않는, 다른 말로 하면 해당 연산과 만났을 때 <strong>아무 일도 일어나지 않는</strong> 걸 항등원이라 합니다. 대수학 정의를 보면<br />
<code>e_L * a = a</code> 이 성립하면 좌항등원<br />
<code>a * e_R = a</code> 이 성립하면 우항등원<br />
이 둘이 모두 성립하면 그제서야 항등원이라 합니다. (추가적으로 따라야 하는 법칙들이 몇 개 있습니다.)<br />
참고 - <a href="../posts/2022-12-12-CommutativeAssociativeIdentity.html#%ED%95%AD%EB%93%B1%EC%9B%90">결합 법칙, 교환 법칙, 항등원, 합성</a></p>
<h2 id="항등-함수identity-function">항등 함수Identity Function</h2>
<p><code>id_X: X -&gt; X</code><br />
모양은 <code>X</code>를 넣어주면 변형, 변환 없이 그대로 <code>X</code>가 나오는 함수입니다. 정식 정의는 다른 텍스트들을 참고해 주시고, 제가 눈여겨 보는 것은 다음 성질입니다.<br />
좌항등원, 우항등원처럼 임의의 함수 <code>f: X -&gt; Y</code>와 합성<code>(⋅)</code>이라는 연산에 대해<br />
<code>f ⋅ id_X = f</code><br />
<code>id_Y ⋅ f = f</code><br />
성질을 만족해야 합니다. 잘 보면 <strong>id_X와 id_Y 두 가지</strong>가 나옵니다. 단일 값인 <code>1</code>같은 값의 더하기 연산에 대한 항등원은 <code>1 + 0 = 0</code>, <code>0 + 1 = 0</code> 으로 하나의 값인 <code>0</code>이 항등원이었지만, 함수는 <strong>한 가지 정보</strong>를 가지고 있는 값이 아닙니다. <strong>두 가지 정보 X, Y</strong>를 갖고 있는 <code>X -&gt; Y</code>란 함수의, <strong>함수 합성(연산)</strong>에 대한 항등원 역할을 하는 건, <strong>두 가지</strong>를 봐야 한다고 예측할 수 있습니다.</p>
<p>만일 <code>f: X -&gt; Y</code> 함수라면,<br />
<code>f ⋅ id_X</code>를 하려면 <code>id_X: X -&gt; X</code> 타입일테고,<br />
<code>id_Y ⋅ f</code>를 하려면 <code>id_Y: Y -&gt; Y</code> 타입이 되어야 합성 할 수 있습니다.<br />
타입 일치를 보면서, 그냥 당연하다고 넘어가면 되겠지만, 전 두 가지 정보가 있는 것의 연산에서 항등원은 두 가지를 봐야 한다는 것에 눈이 갔습니다. 하스켈에서는 폴리모픽으로 정의해서 <code>id :: a -&gt; a</code> 하나로 표현만 할 수 있지, 항등 함수 성질을 만족하려면 <code>id_X</code>, <code>id_Y</code> 두 개의 항등 함수가 있어야 합니다.</p>
<h2 id="항등-펑터identity-functor">항등 펑터Identity Functor</h2>
<p>Identity 펑터는 뭘 의미할까요? (Identity 모피즘과 구별) 어떤 연산에 Identity라는 걸까요?<br />
함수가 함수 합성이란 연산에 대해 항등원을 찾았듯이, 펑터 합성 <code>(∘)</code>에 대한 항등원입니다. 함수 합성 <code>(⋅)</code>과 구별하기 위해 속이 빈 동그라미로 표기하겠습니다.<br />
카테고리 <code>C</code>, <code>D</code>가 있을 때<br />
<code>F: C -&gt; D</code><br />
펑터 <code>F</code>와 합성해서 다음을 만족하면<br />
<code>id_D ∘ F = F = F ∘ id_C</code><br />
<code>id_C</code>, <code>id_D</code> 들을 항등 펑터라 합니다.</p>
<p>어설프게 펑터, 항등원, 항등 함수를 차례로 짚으면서 온 이유가, 어떤식으로든 펑터로 <strong>항상 같음</strong>(항등)을 말하려면 <strong>두 가지</strong> 정보가 필요하다는 걸 보기 위해서입니다.</p>
<p>어떤 타입의 대상이 작업(펑터)을 거친 후에도 같은 타입으로 돌아 오는 모노이드로 만들려면 원래부터 두 가지 정보가 필요하고, 펑터 두 개로 표현할 수 있는 게 당연하다로 이어지는 상상입니다. 다 작성한 후에, 아 잘 못 생각했구나 라고 할 수도 있는, 아직까지는 그저 상상입니다.</p>
<h2 id="항등-자연-변환identity-natural-transformation">항등 자연 변환Identity Natural Transformation</h2>
<p>카테고리 <code>C</code>, <code>D</code><br />
펑터 <code>F: C -&gt; D</code><br />
항등 자연 변환 <code>id_F(F) = F</code><br />
펑터 <code>F</code>를 변환해도 <code>F</code>가 나오는 자연 변환입니다. 항등 자연 변환도 역시 왼 쪽, 오른 쪽을 봐야 합니다.
카테고리에 <code>X</code>, <code>Y</code> 대상이 있고, <code>f: X -&gt; Y</code> 모피즘이 있을 때</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(id_F)_Y ∘ F(f) </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  = id_F(Y) ∘ F(f) </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  = F(f) </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  = F(f) ∘ id_F(X) </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  = F(f) ∘ (id_F)_X</span></code></pre></div>
<p>역시나 항등 성질을 만족하려면 <code>id_F</code>를 <code>X</code>,<code>Y</code> 두 군데서 봐야 합니다.</p>
<p>지금부턴 제 상상입니다. 한 시스템에서 다른 시스템으로 가도록 변환하는데, <strong>항상 고정적인(예측이 가능한) 변형이 일어나고, 원래의 히스토리를 기억한다</strong>면, 이 고정적인 변형을 보정할 수 있는 매핑(isomorphism)을 정의할 수 있습니다. 이 고정적인 변형을 지우는 작업(Natural isomorphism)을 하면 다시 원래의 것과 같아지는 걸 Natural isomorphic이라 합니다. 둘이 같진 않지만, <code>F</code>와 <code>G</code>의 합성이 항상 고정적인 변형이 일어나고, 처음을 알수 있다면? 이란 상상에서 풀어간 생각입니다.</p>
<p>※ 아래 첨자 표기가 어려워 <code>_</code>로 썼습니다.<br />
※ 텍스트들이 <code>id_F</code>가 자연 변환인지, 펑터인지 딱 짚어서 말해주지 않는 경우가 많습니다. 심지어 그냥 <code>F</code>로 쓰고 자연 변환을 뜻할 때도 있고, 항등 자연 변환을 뜻할 때도 있습니다. 알아서 잘 보는 수밖에 없다고 합니다.</p>
<h2 id="adjoint-펑터">Adjoint 펑터</h2>
<p>※ 여기서는 일반적인 Adjunction이 아니라, Adjunction 관계의 두 Adjoint 펑터가 만나서 모나드가 되는 것만 보려고 합니다. 결론부터 말하면, Adjunction도 결국 얼마나 같게 볼 수 있는가에 관한 얘기입니다.</p>
<p>우리말 번역으론 “수반 함자”라고 합니다. 隨伴 따를 수, 짝 반 : 어떤 사물 현상에 따라서 함께 생기는 것. 안타깝게도 번역이 딱히 더 익숙하지도, 더 구체적인 감을 주지도 않습니다.</p>
<p><code>C</code>,<code>D</code>는 카테고리, <code>F</code>,<code>G</code>는 펑터</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">F</span><span class="op">:</span> <span class="dt">C</span> <span class="ot">-&gt;</span> <span class="dt">D</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">G</span><span class="op">:</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">C</span></span></code></pre></div>
<p><code>F∘G = id_D</code>이고, <code>G∘F = id_C</code>이면 카테고리<code>C</code>와 카테고리<code>D</code>는 동형isomorphic입니다. 조금 풀어서 얘기하면, 어딘가의 펑터 합성식에 <code>id_D</code>가 등장한다면, 아무런 추가 작업 없이 그냥 <code>F∘G</code>를 쓸 수 있습니다. 그런데, 현실에선 이렇게 딱 동형이 아닐 때도 의미가 있는 경우가 많습니다. Adjunction은 딱 동형은 아니지만 어찌 어찌하면 동형처럼 보일 때에 관한 얘기입니다.</p>
<p><code>F</code>와 <code>G</code> 사이의 Adjunction <code>(ϵ, η)</code>는 다음과 같은 두 개의 자연 변환Natural Transformation으로 이루어진 순서쌍이라고 합니다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>epsilon ϵ<span class="op">:</span> <span class="dt">F</span>∘<span class="dt">G</span> <span class="ot">=&gt;</span> id_D</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>eta     η<span class="op">:</span> id_C <span class="ot">=&gt;</span> <span class="dt">G</span>∘<span class="dt">F</span></span></code></pre></div>
<p>여기까지가 보통 텍스트들 서두에서 볼 수 있는 내용입니다. 참고-<a href="https://ko.wikipedia.org/wiki/%EC%88%98%EB%B0%98_%ED%95%A8%EC%9E%90">Wiki - Adjoint Functor</a>. 당연하게도 비수학인이 봐서 이해할만한 자료는 거의 없습니다. 이제부터는 대부분 제 상상입니다.</p>
<p>상상해보면, <code>ϵ</code>, <code>η</code>가 없으면 <code>F∘G</code>를 <code>id_D</code>처럼, <code>id_C</code>를 <code>G∘F</code>처럼 볼 수 없지만, <code>ϵ</code>, <code>η</code>의 도움을 받으면(보정한다면) <code>F</code>와 <code>G</code>의 합성으로 <code>id_D</code>, <code>id_C</code>와 같은 일을 할 수 있습니다.<br />
<code>F∘G</code>가 <code>id_D</code>가 아닌데, <code>ϵ</code>으로 살짝 보정하면 <code>id_D</code> 동작을 하고,<br />
<code>G∘F</code>가 <code>id_C</code>가 아닌데, <code>η</code>로 살짝 보정하면 <code>id_C</code> 동작을 한다고<br />
보면 순조롭게 넘어 갈 수 있을 것만 같습니다.</p>
<h3 id="ϵ과-η의-화살표가-반대">ϵ과 η의 화살표가 반대</h3>
<p>하지만, <code>η</code>가 <strong><em>화살표 방향이 반대</em></strong>입니다. <code>G∘F</code>를 주면 <code>id_C</code>를 돌려주는 게 아니라, <code>id_C</code>를 주면 <code>G∘F</code>를 돌려줍니다.</p>
<p>만일<br />
<code>F∘G</code>가 아무 조치 없이 <code>id_D</code>가 되고,<br />
<code>G∘F</code>가 아무 조치 없이 <code>id_C</code>가 되면<br />
카테고리 <code>C</code>와 <code>D</code>는 isomorphic합니다.</p>
<p><code>C</code>와 <code>D</code>가 딱 isomorphic하진 않지만,
<code>F∘G</code>가 <code>id_D</code>와 같지 않은데, <code>F∘G ~= id_D</code>가 있고,<br />
<code>G∘F</code>가 <code>id_C</code>와 같지 않은데, <code>G∘F ~= id_C</code>가 있어 자연 동형이면<br />
<code>C</code>와 <code>D</code>를 isomorphic<strong>처럼</strong> 볼 수 있게 됩니다.</p>
<p>지금부터는 거의 모두 상상입니다. <strong>틀린 걸로 확인되면 지울 수 있습니다.</strong></p>
<h3 id="시작점으로-다시-돌아오면-동형">시작점으로 다시 돌아오면 동형</h3>
<p>자연 변환은 한 카테고리에서 다른 카테고리로 가는 펑터를 변환하는데, 이 때 변환한 값도 원래의 도메인을 벗어나지 않습니다. <code>F∘G</code> 합성의 도메인, 코도메인을 보면 <code>id_D</code>와 같은 <code>D -&gt; D</code>로 원래 것과 같습니다. 사실은 <code>D -&gt; C -&gt; D</code>로 무려 현재 카테고리를 벗어났다가 돌아 오고 있지만, <code>id_D</code>와 같은 동작을 하게끔 하려는 게 목적입니다. 이 걸 척학적이라고 해야 할지, 인문적이라 해야 할지 모르지만, 그동안 “isomorphic하다” 라고 생각한 것들이, 시작과 끝을 제외하면 무슨 복잡한 일을 하고 있을 수 있다는 생각이 듭니다. 시간이란 양이 존재하지 않는 수학 세계에서는 얼마나 오래 걸리는 작업을 하든, 시작과 끝만 같다면 같은 것이니까요. 과정은 중요하지 않고, 결과만 같으면 같은 것입니다.</p>
<p>지금까지는 “같음”의 정도는 완전히 같음(이 건 수학적 정의를 모릅니다.) &gt; 동형Isomorphic &gt; 준동형Homomorphic 정도의 구분을 하고 있었는데, Homomorphic 중에 Adjunction 관계인 걸 특징지을 수 있습니다.</p>
<h3 id="id와-동형isomorphic은-아니지만-준동형homomorphic">id와 동형isomorphic은 아니지만 준동형homomorphic</h3>
<p>우선, 여기선 같음의 기준을 Isomorphic으로 잡고 얘기를 이어가겠습니다.<br />
<code>F∘G</code>에서 <code>id_D</code>로는 갈 수 있지만 돌아오지 못하는 자연 변환이 있고, <code>G∘F</code>에서 <code>id_C</code>로 갈 수 있는데, 돌아오지 못하는 자연 변환이 있는 경우를 생각해 보겠습니다. 돌아오지 못한다는 건, 무언가 정보를 잃어버렸다는 얘기입니다. 하지만, 잃어버린 정보가 그다지 필요한 정보가 아니었다면, 무시하고 같게 볼 수 있을 정도의 관계입니다. 조금씩 틀어진 걸 보정하려면 언뜻 생각하기에 아래 자연 변환이 있으면 될 것처럼 보입니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>ϵ'<span class="op">:</span> <span class="dt">F</span>∘<span class="dt">G</span>  <span class="ot">-&gt;</span> id_D   </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>η'<span class="op">:</span> <span class="dt">G</span>∘<span class="dt">F</span>  <span class="ot">-&gt;</span> id_C   </span></code></pre></div>
<h3 id="isomorphic인지-보려면-fgf와-f의-관계-gfg와-g의-관계를-보면-된다">isomorphic인지 보려면 F∘G∘F와 F의 관계, G∘F∘G와 G의 관계를 보면 된다</h3>
<p>대부분의 텍스트에선 따로 설명없이 <code>F∘G∘F</code>, <code>G∘F∘G</code>가 등장하는데, 왜 이들이 조건에 등장하는지 말해주고 시작하는 자료는 못찾았습니다. (다들 그 정도는 척하고 알아 들을만한 사람들만 봐서 그럴까요?)<br />
카테고리에선 대상이 뭔지 관심 없습니다. 두 카테고리가 isomorphic인지 본다면, 한 대상에서 출발해서 돌아온 대상이 같은 걸 보는 게 아니라, 둘 사이를 오갈 수 있는 펑터<code>F</code>와 펑터 <code>G</code>가 변하지 않는가 봅니다. <code>F</code>의 경우 <code>F</code>로 갔다가, <code>G</code>로 <strong>돌아온 대상이 같은 가 보는 게 아니라, 돌아온 대상에 또 F를 적용했을 때, 동작이 변하지 않는 걸</strong> 보는 겁니다. 이 걸 식으로 표현하면 <code>F∘G∘F</code>에서 <code>F</code>로 돌아 올 수 있고, <code>G∘F∘G</code>에서 <code>G</code>로 돌아올 수 있나 보는 테크닉으로 표현합니다. 그럼, 대상을 전혀 보지 않아도 같은 대상임을 알 수 있습니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>F∘G∘F = F</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>G∘F∘G = G</span></code></pre></div>
<p>아무 작업 없이 위 식이 성립하면 isomorphic입니다. 특정 작업으로 위 관계를 <code>=</code>과 비슷하게 만들면, isomorphic<strong>처럼</strong> 볼 수 있습니다. 과연 위에 두 자연 변환 <code>ϵ'</code>,<code>η'</code>으로 가능한지 따라 가 보겠습니다.</p>
<h3 id="화살표가-반대-방향인-이유">화살표가 반대 방향인 이유</h3>
<p><img src="../images/adjunction_triangle.jpg" alt="F∘G∘F, G∘F∘G" />
카테고리 이론은 다이아그램 체이싱을 하며 대체commute 경로를 찾는 작업이 기본이라 합니다. 대수에서 <code>왼 쪽 = 오른 쪽</code> 식과 같은 의미입니다. 빨간색 화살표들이 서로 commute하도록 만드는 게 목표입니다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>나∘가 = id_F 자연 변환</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>라∘다 = id_G 자연 변환</span></code></pre></div>
<ul>
<li>(가)자연 변환에는 <code>F -&gt; F∘G∘F</code> 변환이 들어가야 하고,</li>
<li>(나)자연 변환에는 <code>F∘G∘F -&gt; F</code> 변환이 들어가야 하고.</li>
<li>(다)자연 변환에는 <code>G -&gt; G∘F∘G</code> 변환이 들어가야 하고,</li>
<li>(라)자연 변환에는 <code>G∘F∘G -&gt; G</code> 변환이 들어가야 합니다.</li>
</ul>
<p>위 식이 성립하게 만들기 위해, 현재 가지고 있는 유일한 변환 <code>ϵ'</code>, <code>η'</code>을 활용해 보겠습니다.
- (가)에는 <code>F항등자연변환 ⋅ (id_C -&gt; G∘F)</code>(수평합성) 자연 변환이 들어가야 하는데, 우리 손엔 반대 모양 <code>η': G∘F -&gt; id_C</code>만 있습니다. <strong>실패</strong>
&gt; Q. <code>(F∘G -&gt; id_D) ⋅ F항등자연변환</code>(수평합성) 자연 변환이 있어도 되지 않나?<br />
&gt; A. 물론 가능합니다. 하지만, <code>ϵ: F∘G =&gt; id_D</code> 가 있는데 <code>F∘G -&gt; id_D</code>까지 있으면 그냥 자연 동형이 돼 버립니다.
- (나)에는 <code>(F∘G -&gt; id_D) ⋅ F항등자연변환</code>(수평합성) 자연 변환이 들어가야 하는데, 마침 <code>ϵ': F∘G -&gt; id_D</code>가 딱 이 모양입니다. <strong>성공</strong>
- (다)에는 <code>(id_C -&gt; G∘F) ⋅ F항등자연변환</code>(수평합성) 자연 변환이 들어가야 하는데, 마찬가지로 우리 손엔 없습니다. <strong>실패</strong>
- (라)에는 <code>F항등자연변환 ⋅ (F∘G -&gt; id_D)</code>(수평합성) 자연 변환이 들어가야 하는데, 마침 <code>ϵ': F∘G -&gt; id_D</code>가 딱 이 모양입니다. <strong>성공</strong></p>
<p><code>왼 쪽 = 오른 쪽</code> 둘을 같게 만들 때, 꼭 한 쪽만 변형할 필요는 없습니다. 아래처럼 놓고 다시 한 번 체이싱을 해보겠습니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>ϵ''<span class="op">:</span> id_D <span class="ot">=&gt;</span> <span class="dt">F</span>∘<span class="dt">G</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>η''<span class="op">:</span> id_C <span class="ot">=&gt;</span> <span class="dt">G</span>∘<span class="dt">F</span></span></code></pre></div>
<ul>
<li>(가)에서 원하는 모양과 <code>η''</code>이 딱 맞고, <strong>성공</strong></li>
<li>(나)에서 원하는 모양과 <code>ϵ''</code>은 반대입니다. <strong>실패</strong></li>
<li>(다)에서 원하는 모양과 <code>η''</code>이 딱 맞고, <strong>성공</strong></li>
<li>(라)에서 원하는 모양과 <code>ϵ''</code>은 반대입니다. <strong>실패</strong></li>
</ul>
<p>결국 Adjunction 텍스트에 나오는 서로 반대 방향의 자연 변환 <code>ϵ'</code>과 <code>η''</code>을 다음처럼 준비하면 다이아그램 체이싱에 성공할 수 있습니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ϵ<span class="op">:</span> <span class="dt">F</span>∘<span class="dt">G</span> <span class="ot">=&gt;</span> id_D</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>η<span class="op">:</span> id_C <span class="ot">=&gt;</span> <span class="dt">G</span>∘<span class="dt">F</span></span></code></pre></div>
<p>위 그림을 보면 <code>F∘G∘F</code>에서 앞에 <code>F</code>와 뒤에 <code>F</code>의 색을 달리 했습니다. 제 눈엔 독특한 특징으로 보이는데 아직 속 뜻은 잘 못 찾고 있습니다. <code>F</code>와 같아지려면, 앞에 <code>F</code>가 살아남아도 되고(<code>G∘F</code>를 <code>id_C</code>로), 뒤에 <code>F</code>가 살아 남아도(<code>F∘G</code>를 <code>id_D</code>로) 되는 상황입니다. Adjunction이 가능한 이유가 여기에 있다고 생각됩니다.</p>
<p>다른 글에서, 모든 값을 <code>id</code>가 적용된 Computation으로 보자는 생각을 얘기했었는데, Adjunction도 비슷한 느낌으로 본다면, <code>F</code> 펑터는 <code>id_D∘F∘id_C</code>로 볼 수 있고, <code>G</code>펑터는 <code>id_C∘G∘id_D</code>로 볼 수 있습니다.</p>
<p>모나드에서는 <code>return</code>이 번뜩이는 센스라 생각했는데, Adjunction에선 화살표 반대가 번뜩이는 센스로 생각됩니다.</p>
<p>과연, 화살표 반대 방향은 위처럼 쫓아가다 나온 것인지, 아니면 내포된 속 뜻이 있어, 단 번에 서로 반대 방향의 자연 변환을 준비해야 되는 걸 알았는지 지금은 모르겠습니다. 속 뜻에 대한 질문에 <span class="citation" data-cites="Ailrun님으로부터">@Ailrun님으로부터</span> 아래 같은 답을 받았습니다.</p>
<blockquote>
<p><span class="citation" data-cites="Ailrun">@Ailrun</span>:<br />
<code>f∘g = id</code>, <code>g∘f = id</code>가 가능하면, <code>g</code>의 정의역domain과 치역codomain이 <strong>같은 수준의 정보를 가지고 있습니다</strong>.<br />
만약에 둘 다를 아래와 같이 정의하면</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>ϵ: F∘G =&gt; id_D</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>η: G∘F =&gt; id_C -- 원래 정의는 id_C =&gt; G∘F</span></code></pre></div>
<p><code>F∘G</code>나 <code>G∘F</code>가 <code>id</code>에 비해서 훨씬 “약한” 녀석이어도 (함수로 따지자면 <code>id_C</code>나 <code>id_D</code>라는 치역보다 훨씬 적은 정보만을 가지고 있어도) 얼마든지 두 자연 변환을 줄 수 있기에 <code>C</code>와 <code>D</code>의 강한 관계를 나타내는 대표자로서 <code>F</code>와 <code>G</code>를 쓰기 힘듭니다.<br />
마찬가지로 반대로만 정의하면</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ϵ: id_D =&gt; F⋅G -- 원래 정의는 F∘G =&gt; id_D</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>η: id_C =&gt; G⋅F</span></code></pre></div>
<p><code>id_C</code>에는 포함되지 않는 아무 온갖 쓸데없는 추가 정보를 포함하고 있어도, 문제가 없기 때문에 또 제약이 너무 약하다고 할 수 있습니다.</p>
</blockquote>
<p>둘 중 하나 방향을 뒤집게 되면, 추가적인 제약이 들어있는 것과 같습니다. 위의 경우는 <code>id_C</code>, <code>id_D</code> 만큼의 정보(혹은 같은 양의 정보?)를 <code>F</code>와<code>G</code>의 합성도 가지고 있다는 얘기가 숨어 있다고 볼 수 있습니다.</p>
<p>결론은, 카테고리 <code>C</code>,<code>D</code>는 펑터<code>F</code>, <code>G</code>, 자연 변환<code>ϵ</code>, <code>η</code>가 있으면(Adjunction이 있으면) 같은 것처럼 볼 수 있을 정도로 같다(다르다)입니다.</p>
<p>※ <code>ϵ</code>은 <code>counit</code>이라 부르고, <code>η</code>는 <code>unit</code>이라 부르기도 합니다.</p>
<h2 id="모나드와-연관성">모나드와 연관성</h2>
<p>정의만 읽어서 알 수 있는 공통점은, Adjunction, 모나드 둘 다 정보를 잃어버리면서도 같은 것이라 우기는 개념입니다. -<span class="citation" data-cites="todo">@todo</span></p>
<h2 id="요약">요약</h2>
<p><code>C</code>, <code>D</code> 둘이 얼마나 같은데?</p>
<ul>
<li>둘이 완전히 같아.<br />
(완전히 같다는 정의하기 무척 어려운 거란 생각이 듭니다. 하지만, 전 티없이 맑은 정의를 원하는 것이 아니라, 현실 문제를 모델링할 때 문제 없을 정도의 정밀함만 있으면 됩니다.)</li>
<li>isomorphism으로 같아.<br />
<code>C</code>, <code>D</code> 둘은 다르지만, isomorphism으로 같게 볼 수 있는 것</li>
<li>Natural isomorphism이 있는 관계야.<br />
<code>C</code>, <code>D</code> 둘은 다르고, isomorphism도 없지만, 둘 간의 펑터를 <code>id</code>와 같게 볼 수 있게 하는 Natural isomorphism이 있는 관계야</li>
<li><code>C</code>, <code>D</code> 둘은 다르고, isomorphism도 없고, Natural isomorphism인 펑터 합성도 없지만, Adjunction관계의 펑터 합성이 있는 관계야.</li>
</ul>
<p>아래는 과연 현실에서 <strong>자연 동형</strong>이 어떤 직관으로 나타날까 고민하다 나온 상상입니다. 아래는 우선 <code>G∘F</code>만 보겠습니다.</p>
<figure>
<img src="../images/adjunction.jpg" alt="동형, 자연동형이 있는 관계, Adjunction이 있는 관계" /><figcaption aria-hidden="true">동형, 자연동형이 있는 관계, Adjunction이 있는 관계</figcaption>
</figure>
<p>동형, 자연동형, Adjunction은 그림에서 빨간 변형에 따라 구분이 되는 것으로 생각하고 있습니다. (동일한 일이 <code>F∘G</code>에도 일어난다고 가정해 주세요.)</p>
<ul>
<li>빨간 변형이 없다면 <strong>C와 D는 동형</strong></li>
<li>빨간 변형을 <strong><em>항상 정확히 알 수 있고, 되돌릴 수 있다면, C와 D사이에는 ID_C와 자연 동형인 펑터 G∘F 합성이 존재</em></strong>.<br />
자연 동형이라면 <code>ID_C</code>나 <code>ID_D</code>에서 역으로 <code>F∘G</code>나 <code>G∘F</code>를 찾을 수도 있어야 하니 얼마나 변형됐는지 정보를 잃어버리면 안됩니다.</li>
<li>빨간 변형을 버리거나 참조해서, <strong><em>어떻게든 수긍할만한 새로운 변형 생성을 허락</em></strong>한다면 <strong>C와 D는 Adjunction관계인 펑터F, G 합성이 존재</strong></li>
</ul>
<p>※ 변형이 일어났다는 말은, 곧 <code>F</code>가 <code>x1</code>이란 정보를 잃어버리면서 온다는 얘기로 보입니다.</p>
<p><code>ϵ</code>과 <code>η</code>는 <code>id</code>들과 일대일 대응이 아닙니다. 무언가 정보를 잃어버리면서 <code>id</code>와 같은 일을 합니다. 모나드와 마찬가지로 쓸모 없는 정보를 잃어버리거나 합치면서 같은 모양이 가능한 것들이 있다면, Adjunction으로 모델링을 시도해 볼 수 있겠습니다.</p>
<p>아마도 이런 인포멀한 접근이, 전공 선수분들한테는 의미가 없을지도 모르겠습니다. 전 현실 문제를 보고, 펑터로 이리 저리 변환을 하는데, 어떤 경우가 보이면 Adjunction을 이용해 모델링해야겠다란 생각이 들 수 있도록 하는 게 목표입니다.</p>
<p>참고. 다음 글은 찾은 자료 중, 직관에 대한 설명이 가장 많이 등장하는, 제 입맛에 딱 맞는 글입니다. 예시를 벡터 스페이스로 들고 있어 그리 쉽지는 않지만, 딱딱한 정규 텍스트들보다는 좋았습니다.<br />
<a href="https://www.math3ma.com/blog/what-is-an-adjunction-part-1">What is an Adjunction? Part 1 (Motivation) - math3ma</a><br />
<a href="https://www.math3ma.com/blog/what-is-an-adjunction-part-2">What is an Adjunction? Part 2 (Definition) - math3ma</a>
하스켈 코드로 Adjunction 보기 <a href="https://www.stephendiehl.com/posts/adjunctions.html">From Adjunctions to Monads - Stephen Diehl</a><br />
</p>
<p>Mon Nov 27 03:45:47 PM KST 2023 작성 중</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
