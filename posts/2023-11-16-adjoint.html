<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - Adjunction 관계의 두 Adjoint 펑터로 모나드 표현하기(작성예정)</title>

        <meta name="description" content="카테고리 이론에서 모나드를 설명하는 방법 중 하나인 Adjoint Functor를 비수학적으로 해석합니다." />
        <meta property="og:description" content="카테고리 이론에서 모나드를 설명하는 방법 중 하나인 Adjoint Functor를 비수학적으로 해석합니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Adjunction 관계의 두 Adjoint 펑터로 모나드 표현하기(작성예정)" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-11-16-adjoint.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

      <meta name="keywords" content="Monad, Functor, Identity, Natural Transformation, Isomorphic, Isomorphism">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>Adjunction 관계의 두 Adjoint 펑터로 모나드 표현하기(작성예정)</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on November 16, 2023
    
</div>

<p>주의 - 아래 내용은 유사 수학이란 지적을 들은 적이 있습니다. 여기 설명이 어떤 분들이 보기에는 유사 수학일 수 있습니다. 애초에, 수학적인 의미보다는 개념이 가지고 있는 어떤 아이디어가 프로그래밍에, 하스켈에 녹아든 건지 찾는 게 목표로, 굳이 유사 수학이 아니라고 밀어 붙이진 않겠습니다. 주제는 수학에서 가져온 것이지만, 수학적인 의미를 찾는 분들을 위한 글이 아닙니다. 아마도 수학 전공이나, PL 전공분들이 보기에 적당하지 않은 상상, 그리고 당연히 오류가 있을 수 있습니다.</p>
<p>현재의 제 수학 배경으론 완벽히 이해하기엔 무리가 있지만, 적정선까지 이해를 하면, 함수형 프로그래밍으로 현실을 모델링할 때 분명 힘이 될 개념이라 생각합니다. 모나드는 조금 달라진 걸 원래의 것과 같게 볼 수 있는 방법에 대한 얘기였습니다. Adjunction도 두 개의 무언가가 얼마나 같은 가를 포멀하게 얘기하는 하나의 방법입니다. 둘이 연관성이 있을 거라 예측할 수 있습니다.
참고 - <a href="../posts/2022-03-25-beforeMonad.html">모나드, 같음 - m (m a)와 m a는 얼마나 다를까?</a></p>
<p>카테고리 이론에 대한 글을 남기는 건, 어설퍼서 잘 안하는데, 재미난 상상이 떠올라 남깁니다. 아래가 궁금하지 않은 분들은 읽을만한 글이 아닙니다. 항등, 동형, 펑터, 자연 변환에 대해 간단히 짚고 가긴 하지만, 부족한 설명들이니, 다른 정식 텍스트들을 통해 제대로 알아두시면 좋습니다.</p>
<ul>
<li>왜 두 개의 펑터로, 얼마나 같은지를 표현할까?</li>
<li>두 개가 얼마나 같은지를 따지는데 왜 자연 동형 얘기가 나올까?</li>
<li>왜 <code>ϵ</code>과 <code>η</code>의 화살표 방향이 반대일까?</li>
<li>모나드와 어떤 연관성이 있을까?</li>
</ul>
<p><code>=</code>을 쓸만큼 같지 않으면 <code>~</code>도 쓰고, <code>≃</code>, <code>⋍</code> …(<code>=</code>과 여러 기호의 조합)을 써서 그래도 어찌 보면, 어느 정도는 같게 볼 수 있다고 말하는 개념들이 많습니다. Adjunction도 그들 중 하나입니다.</p>
<p>다시 한 번 말하지만, 수학 카테고리 이론의 Adjunction을 정교하게 공부하려는 분에게 어울리는 글이 아닙니다.</p>
<h2 id="adjoint-adjunction-단어-뜻">Adjoint, Adjunction 단어 뜻</h2>
<p><code>Ad</code>(무엇과 가까이, 어디를 향해, 무엇과 관련하여) - <code>Joint</code>(jungere 결합하다)<br />
<code>Ad</code> - <code>Junction</code> “closely connected, joined, united”를 뜻하는 라틴어 Adjunction</p>
<p>일상 생활에서도 가끔 만나는 용어입니다. 고속도로와 고속도로가 만나서, 한 고속도로에서 다른 고속도로로 옮겨 갈 수 있는 연결 길을 Junction(JC, 우리말로는 분기점)이라 부릅니다.</p>
<p>선형 대수학에서 행렬 공부할 때 보이던 용어이긴 한데, 모나드 설명에 나오는 것과 어떤 개념이 이어지는지 명확하게 보이진 않습니다.</p>
<p>Adjunction 관계라 하면, 무슨 뜻인지 명확하게 정의하는 곳을 못 찾았습니다. 보통 둘이 특별한 관계가 있다는, 매우 추상적인 설명으로 (불친절하게) 끝나는 자료가 대부분입니다. 거의 같은 말이지만, 조금 더 구체적인 느낌을 주게 말하자면, <strong>혼자서는 특별한 일을 못하지만, 둘이 만나면 특별한 일을 해낼 수 있는 관계</strong>를 Adjunction 관계라 합니다. 이 특별한 일이란 게 어떤 동작으로 한정되는 게 아니라서, 딱 떨어지는 문장으로 정의한 곳이 없습니다. 예를 들어, 어떤 펑터가 혼자서는 별다른 일이 벌어지지 않지만, 적당한 짝이 되는 펑터를 만나면, 둘이선 모나드를 표현할 수 있습니다. 이 때 각 각을 오른 쪽, 왼 쪽 Adjoint 펑터라고 합니다.</p>
<p>혼자서는 아니지만, 둘이 뭉쳐(결합) 지구를 지킬 수 있으면 Adjunction 관계라 부릅니다.</p>
<p>※ 명사냐 형용사냐로 갈릴 뿐, Adjoint와 Adjunction은 뜻 자체는 거의 같은 뜻으로 쓰입니다.</p>
<p>아래 용어들은 몇 번을 봤던 개념들인데, 다 알고 있다 생각했는데, 의외로 혼란스러운 부분이 많았습니다. 항등원은 어떤 연산에 대해서 정의되는데, 항등 함수와 항등 펑터, 항등 자연 변환들은 어떤 “연산”에 대해 정의된 것인가부터, 텍스트마다 <code>F</code>, <code>id_F</code>를 펑터, 항등 펑터, 항등 자연 변환 표현으로 혼용해서 쓰는 바람에 더 혼란스러웠습니다. 항등X들은 정의와 성질을 혼동하기도 했습니다. 정식 정의들 보다는 Adjunction을 이해하는데 필요한 아이디어만 정리했습니다.</p>
<h2 id="펑터functor">펑터Functor</h2>
<p>카테고리에선 대상을 매핑하는 동작은 모피즘, 카테고리를 매핑하는 동작은 펑터라 부릅니다. 함수가 한 가지만 매핑한다면, 펑터는 오브젝트도, 모피즘도, 모피즘 합성도 모두 매핑(카테고리를 매핑)해야 합니다. 참고 - <a href="../posts/2023-03-09-functor.html">한 번쯤 나올 법 했는데, 아직 없었던 펑터 이야기</a></p>
<h2 id="동형isomorphic">동형isomorphic</h2>
<p>텍스트들의 설명으론, 구조가 같은 두 대상 사이에서 구조를 보존하는 사상을 isomorphism이라 합니다. 둘은 다르지만, isomorphism이 있으면(<strong>up to isomorphism</strong>), isomorphic하다고 말합니다.<br />
한 시스템에서 어떤 상태가 어디에서 출발해서 어떤, 어떤 값을 거쳐 어디에 도달하는 상황을 생각하면, 이를 모델링한 곳에서도 항상 동일한 경로로 변경이 되어, 모델링 한 것으로 현실을 완벽히 추적할 수도 있고, 거꾸로 현실에서 모델링한 것이 어떻게 값이 변해갈지 완벽히 추적할 수 있는 걸 말합니다. 두 시스템의 상태가 완전히 <strong>일대일 대응</strong>으로 어느 한 쪽을 알면, 다른 한 쪽도 알 수 있는 iso(같은)morphic(모양)이라 합니다.</p>
<p><code>homo-</code> 는 <code>same</code>을 의미하고, <code>iso-</code>는 <code>equal</code>을 의미한다고 합니다.<br />
<code>same</code>은 <code>identity</code>를 보는 것이고, <code>equal</code>은 <code>equality</code>를 본다고 합니다. 동어 반복 같은 설명입니다.<br />
“today’s exchange rate 1 dollar is <strong>equal</strong> to 0.91 euros. but they are not the <strong>same</strong> thing”<br />
구글링으로 여러 설명을 찾아 봐도 딱히 명쾌하단 느낌을 주는 설명이 없습니다. 대수에선 위 예문과 좀 다른듯 한데, 제 경험적으로 느끼는 건, 내가 주목하는, 필요로하는 구조는 같고, 그 외는 같을 수도, 다를 수도 있는 (거의 비슷한) 것에는 <code>homo-</code>를 붙이고, 모든 구조가 같아 일대일 대응이 되는 것(역변환이 되는 것)에는 <code>iso-</code>를 붙입니다.</p>
<h2 id="항등원identity">항등원Identity</h2>
<p>어떤 연산에 항등원Identity이라면, 항등원과 연산하면 원래 값이 바뀌지 않는, 다른 말로 하면 해당 연산과 만났을 때 <strong>아무 일도 일어나지 않는</strong> 걸 항등원이라 합니다. 대수학 정의를 보면<br />
<code>e_L * a = a</code> 이 성립하면 좌항등원<br />
<code>a * e_R = a</code> 이 성립하면 우항등원<br />
이 둘이 모두 성립하면 그제서야 항등원이라 합니다. (추가적으로 따라야 하는 법칙들이 몇 개 있습니다.)<br />
참고 - <a href="../posts/2022-12-12-CommutativeAssociativeIdentity.html#%ED%95%AD%EB%93%B1%EC%9B%90">결합 법칙, 교환 법칙, 항등원, 합성</a></p>
<h2 id="항등-함수identity-function">항등 함수Identity Function</h2>
<p><code>id_X: X -&gt; X</code><br />
모양은 <code>X</code>를 넣어주면 변형, 변환 없이 그대로 <code>X</code>가 나오는 함수입니다. 정식 정의는 다른 텍스트들을 참고해 주시고, 제가 눈여겨 보는 것은 다음 성질입니다.<br />
좌항등원, 우항등원처럼 임의의 함수 <code>f: X -&gt; Y</code>와 합성<code>(⋅)</code>이라는 연산에 대해<br />
<code>f ⋅ id_X = f</code><br />
<code>id_Y ⋅ f = f</code><br />
성질을 만족해야 합니다. 잘 보면 <strong>id_X와 id_Y 두 가지</strong>가 나옵니다. 단일 값인 <code>1</code>같은 값의 더하기 연산에 대한 항등원은 <code>1 + 0 = 0</code>, <code>0 + 1 = 0</code> 으로 하나의 값인 <code>0</code>이 항등원이었지만, 함수는 <strong>한 가지 정보</strong>를 가지고 있는 값이 아닙니다. <strong>두 가지 정보 X, Y</strong>를 갖고 있는 <code>X -&gt; Y</code>란 함수의, <strong>함수 합성(연산)</strong>에 대한 항등원 역할을 하는 건, <strong>두 가지</strong>를 봐야 한다고 예측할 수 있습니다.</p>
<p>만일 <code>f: X -&gt; Y</code> 함수라면,<br />
<code>f ⋅ id_X</code>를 하려면 <code>id_X: X -&gt; X</code> 타입일테고,<br />
<code>id_Y ⋅ f</code>를 하려면 <code>id_Y: Y -&gt; Y</code> 타입이 되어야 합성 할 수 있습니다.<br />
타입 일치를 보면서, 그냥 당연하다고 넘어가면 되겠지만, 전 두 가지 정보가 있는 것의 연산에서 항등원은 두 가지를 봐야 한다는 것에 눈이 갔습니다. 하스켈에서는 폴리모픽으로 정의해서 <code>id :: a -&gt; a</code> 하나로 표현만 할 수 있지, 항등 함수 성질을 만족하려면 <code>id_X</code>, <code>id_Y</code> 두 개의 항등 함수가 있어야 합니다.</p>
<h2 id="항등-펑터identity-functor">항등 펑터Identity Functor</h2>
<p>Identity 펑터는 뭘 의미할까요? (Identity 모피즘과 구별) 어떤 연산에 Identity라는 걸까요?<br />
함수가 함수 합성이란 연산에 대해 항등원을 찾았듯이, 펑터 합성 <code>(∘)</code>에 대한 항등원입니다. 함수 합성 <code>(⋅)</code>과 구별하기 위해 속이 빈 동그라미로 표기하겠습니다.<br />
카테고리 <code>C</code>, <code>D</code>가 있을 때<br />
<code>F: C -&gt; D</code><br />
펑터 <code>F</code>와 합성해서 다음을 만족하면<br />
<code>id_D ∘ F = F = F ∘ id_C</code><br />
<code>id_C</code>, <code>id_D</code> 들을 항등 펑터라 합니다.</p>
<p>어설프게 펑터, 항등원, 항등 함수를 차례로 짚으면서 온 이유가, 어떤식으로든 펑터로 <strong>항상 같음</strong>(항등)을 말하려면 <strong>두 가지</strong> 정보가 필요하다는 걸 보기 위해서입니다.</p>
<p>어떤 타입의 대상이 작업(펑터)을 거친 후에도 같은 타입으로 돌아 오는 모노이드로 만들려면 원래부터 두 가지 정보가 필요하고, 펑터 두 개로 표현할 수 있는 게 당연하다로 이어지는 상상입니다. 다 작성한 후에, 아 잘 못 생각했구나 라고 할 수도 있는, 아직까지는 그저 상상입니다.</p>
<h2 id="항등-자연-변환identity-natural-transformation">항등 자연 변환Identity Natural Transformation</h2>
<p>카테고리 <code>C</code>, <code>D</code><br />
펑터 <code>F: C -&gt; D</code><br />
항등 자연 변환 <code>id_F(F) = F</code><br />
펑터 <code>F</code>를 변환해도 <code>F</code>가 나오는 자연 변환입니다. 항등 자연 변환도 역시 왼 쪽, 오른 쪽을 봐야 합니다.
카테고리에 <code>X</code>, <code>Y</code> 대상이 있고, <code>f: X -&gt; Y</code> 모피즘이 있을 때</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(id_F)_Y ∘ F(f) </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  = id_F(Y) ∘ F(f) </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  = F(f) </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  = F(f) ∘ id_F(X) </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  = F(f) ∘ (id_F)_X</span></code></pre></div>
<p>역시나 항등 성질을 만족하려면 <code>id_F</code>를 <code>X</code>,<code>Y</code> 두 군데서 봐야 합니다.<br />
</p>
<p>지금부턴 제 상상입니다. 한 시스템에서 다른 시스템으로 가도록 변환하는데, <strong>항상 고정적인(예측이 가능한) 변형이 일어난다</strong>면, 이 고정적인 변형을 보정할 수 있는 매핑(모피즘)을 정의할 수 있습니다. 이 고정적인 변형을 덜어내는 작업Natural isomorphism을 하면 다시 원래의 것과 같아지는 걸 Natural isomorphic이라 합니다. 둘이 같진 않지만, <code>F</code>와 <code>G</code>의 합성이 항상 고정적인 변형이 일어난다면? 이란 상상에서 풀어간 생각입니다.</p>
<p>※ 아래 첨자 표기가 어려워 <code>_</code>로 썼습니다.<br />
※ 텍스트들이 <code>id_F</code>가 자연 변환인지, 펑터인지 딱 짚어서 말해주지 않는 경우가 많습니다. 심지어 그냥 <code>F</code>로 쓰고 자연 변환을 뜻할 때도 있고, 항등 자연 변환을 뜻할 때도 있습니다. 알아서 잘 보는 수밖에 없다고 합니다.</p>
<h2 id="adjoint-펑터">Adjoint 펑터</h2>
<p>※ 여기서는 일반적인 Adjunction이 아니라, Adjunction 관계의 두 Adjoint 펑터가 만나서 모나드가 되는 것만 보려고 합니다. 결론부터 말하면, Adjunction도 결국 얼마나 같게 볼 수 있는가에 관한 얘기입니다.</p>
<p>우리말 번역으론 “수반 함자”라고 합니다. 隨伴 따를 수, 짝 반 : 어떤 사물 현상에 따라서 함께 생기는 것. 안타깝게도 번역이 딱히 더 익숙하지도, 더 구체적인 감을 주지도 않습니다.</p>
<p><code>C</code>,<code>D</code>는 카테고리, <code>F</code>,<code>G</code>는 펑터</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">F</span><span class="op">:</span> <span class="dt">C</span> <span class="ot">-&gt;</span> <span class="dt">D</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">G</span><span class="op">:</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">C</span></span></code></pre></div>
<p><code>F∘G = id_D</code>이고, <code>G∘F = id_C</code>이면 카테고리<code>C</code>와 카테고리<code>D</code>는 동형isomorphic입니다. 조금 풀어서 얘기하면, 어딘가의 펑터 합성식에 <code>id_D</code>가 등장한다면, 아무런 추가 작업 없이 그냥 <code>F∘G</code>를 쓸 수 있습니다. 그런데, 현실에선 이렇게 딱 동형이 아닐 때도 의미가 있는 경우가 많습니다. Adjunction은 딱 동형은 아니지만 어찌 어찌하면 동형처럼 보일 때에 관한 얘기입니다.</p>
<p><code>F</code>와 <code>G</code> 사이의 Adjunction <code>(ϵ, η)</code>는 다음과 같은 두 개의 자연 변환Natural Transformation으로 이루어진 순서쌍이라고 합니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>ϵ<span class="op">:</span> <span class="dt">F</span>⋅<span class="dt">G</span> <span class="ot">=&gt;</span> id_D</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>η<span class="op">:</span> id_C <span class="ot">=&gt;</span> <span class="dt">G</span>⋅<span class="dt">F</span></span></code></pre></div>
<p>여기까지가 보통 텍스트들 서두에서 볼 수 있는 내용입니다. <a href="https://ko.wikipedia.org/wiki/%EC%88%98%EB%B0%98_%ED%95%A8%EC%9E%90">Wiki - Adjoint Functor</a>. 당연하게도 비수학인이 봐서 이해할만한 자료는 거의 없습니다. 이제부터는 대부분 제 상상입니다.</p>
<p>상상해보면, <code>ϵ</code>, <code>η</code>가 없으면 <code>F∘G</code>를 <code>id_D</code>처럼, <code>id_C</code>를 <code>G∘F</code>처럼 볼 수 없지만, <code>ϵ</code>, <code>η</code>의 도움을 받으면(보정한다면) <code>F</code>와 <code>G</code>의 합성으로 <code>id_D</code>, <code>id_C</code>와 같은 일을 할 수 있습니다.<br />
<code>F∘G</code>가 <code>id_D</code>가 아닌데, <code>ϵ</code>으로 살짝 보정하면 <code>id_D</code> 동작을 하고,<br />
<code>G∘F</code>가 <code>id_C</code>가 아닌데, <code>η</code>로 살짝 보정하면 <code>id_C</code> 동작을 한다고<br />
보면 순조롭게 넘어 갈 수 있을 것만 같습니다.</p>
<p>하지만, <code>η</code>가 <strong><em>화살표 방향이 반대</em></strong>입니다. <code>G∘F</code>를 주면 <code>id_C</code>를 돌려주는 게 아니라, <code>id_C</code>를 주면 <code>G∘F</code>를 돌려줍니다.</p>
<p>만일<br />
<code>F∘G</code>가 아무 조치 없이 <code>id_D</code>가 되고,<br />
<code>G∘F</code>가 아무 조치 없이 <code>id_C</code>가 되면<br />
카테고리 <code>C</code>와 <code>D</code>는 isomorphic합니다.</p>
<p><code>C</code>와 <code>D</code>가 딱 isomorphic하진 않지만,
<code>F∘G</code>가 <code>id_D</code>와 같지 않은데, <code>ϵ: F∘G =&gt; id_D</code>가 있고,<br />
<code>G∘F</code>가 <code>id_C</code>와 같지 않은데, <code>η: id_C =&gt; G∘F</code>가 있으면<br />
<code>C</code>와 <code>D</code>를 isomorphic처럼 볼 수 있게 됩니다.</p>
<p>※ 대부분의 텍스트에선 따로 설명없이 <code>F∘G∘F</code>, <code>G∘F∘G</code>가 등장하는데, 왜 이들이 조건에 등장하는지 말해주고 시작하는 자료는 못찾았습니다. 다들 그 정도는 척하고 알아 들을만한 사람들만 봐서 그럴까요?<br />
상상 - 카테고리에선 대상이 뭔지 관심 없습니다. isomorphic스러운 성질을 가지고 있는지 보기 위해 한 대상에서 출발해서 돌아온 대상이 같은 걸 보는 게 아니라, 펑터<code>F</code>가 변하지 않는 걸 봅니다. <code>F</code>로 갔다가, <code>G</code>로 <strong>돌아온 대상이 같은 가 보는 게 아니라, 돌아온 대상에서 F 동작이 변하지 않는 걸</strong> 보는 겁니다. 이 걸 식으로 표현하려면 <code>F∘G∘F</code>에서 <code>F</code>로 돌아 올 수 있고, <code>G∘F∘G</code>에서 <code>G</code>로 돌아올 수 있나 보는 테크닉을, 카테고리 이론에선 자주 만납니다. 그럼, 대상을 전혀 보지 않아도 같은 대상임을 알 수 있습니다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>F∘G∘F = F</span></code></pre></div>
<p>아무 절차 없이 이렇게 되면 isomorphic이고, 추가 절차 <code>ϵ</code>으로 <code>ϵ(F∘G)</code>로 변환하면 <code>id_D</code>가 되어 <code>ϵ(F∘G)∘F = id_D∘F = F</code>가 되고,</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>G = G∘F∘G</span></code></pre></div>
<p><code>G∘F∘G = id_C∘G</code>로 보면, <code>η(id_C)</code>로 변환하면 <code>G = η(id_C)∘G = G∘F∘G</code>가 되면 <code>F</code>와 <code>G</code>는 Adjunction이라 합니다.</p>
<p>항등 펑터와 항등 자연 변환이 섞여 있어 혼란스럽긴 한데, 왼 쪽을 보정해서 오른 쪽과 같게 만들든, 오른 쪽을 보정해서 왼 쪽과 같게 만들든, 여하튼 <code>ϵ</code>,<code>η</code>만 있으면 <code>=</code>가 성립하게 만들 수 있다는 것까지는 보입니다. 그런데, 왜 언제는 왼 쪽, 언제는 오른 쪽을 보정하게 했을까요?</p>
<p>제 첫 해석은, 대체commute 경로가 되기 위해선 하나가 뒤집어져야 한다라고 생각했습니다. 하지만, 이대로 넘어가기에는 찜찜했습니다. 아마도 여기에 번뜩이는 아이디어가 숨어 있는 듯 한데 쉽게 찾아지지 않습니다.</p>
<p><code>f∘g = id</code>, <code>g∘f = id</code>가 가능하면, <code>g</code>의 정의역domain과 치역codomain이 <strong>같은 수준의 정보를 가지고 있습니다</strong> - <span class="citation" data-cites="Ailrun">@Ailrun</span></p>
<blockquote>
<p><span class="citation" data-cites="Ailrun">@Ailrun</span>:<br />
만약에 둘 다를 아래와 같이 정의하면</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>ϵ: F∘G =&gt; id_D</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>η: G∘F =&gt; id_C -- 원래 정의는 id_C =&gt; G∘F</span></code></pre></div>
<p><code>F∘G</code>나 <code>G∘F</code>가 <code>id</code>에 비해서 훨씬 “약한” 녀석이어도 (함수로 따지자면 <code>id_C</code>나 <code>id_D</code>라는 치역보다 훨씬 적은 정보만을 가지고 있어도) 얼마든지 두 자연 변환을 줄 수 있기에 <code>C</code>와 <code>D</code>의 강한 관계를 나타내는 대표자로서 <code>F</code>와 <code>G</code>를 쓰기 힘듭니다.<br />
마찬가지로 반대로만 정의하면</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>ϵ: id_D =&gt; F⋅G -- 원래 정의는 F∘G =&gt; id_D</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>η: id_C =&gt; G⋅F</span></code></pre></div>
<p><code>id_C</code>에는 포함되지 않는 아무 온갖 쓸데없는 추가 정보를 포함하고 있어도, 문제가 없기 때문에 또 제약이 너무 약하다고 할 수 있습니다.</p>
</blockquote>
<p>둘 중 하나 방향을 뒤집게 되면, 추가적인 제약이 들어있는 것과 같습니다. 위의 경우는 <code>id_C</code>, <code>id_D</code> 만큼의 정보(혹은 같은 양의 정보?)를 <code>F</code>와<code>G</code>의 합성도 가지고 있다는 얘기가 숨어 있습니다. 왜 그런지 좀 더 상상해 봤습니다.<br />
<code>ϵ</code>과 <code>η</code>는 (co)domain이 달라 바로는 합성할 수 없습니다.</p>
<p>자연 변환은 한 카테고리에서 다른 카테고리로 가는 펑터를 변환하는데, 이 때 변환한 값도 원래의 카테고리를 벗어나지 않습니다. <code>F∘G</code> 합성의 도메인, 코도메인을 보면 <code>id_D</code>와 같은 <code>D -&gt; D</code>로 원래 것과 같습니다. 사실은 <code>D -&gt; C -&gt; D</code>로 무려 현재 카테고리를 벗어났다가 돌아 오고 있지만, <code>id_D</code>와 같은 동작을 하게끔 하려는 게 목적입니다. 이 걸 척학적이라고 해야 할지, 인문적이라 해야 할지 모르지만, 그동안 “같다” 라고 생각한 것들이, 시작과 끝을 제외하면 무슨 복잡한 일을 하고 있을 수 있다는 생각이 듭니다. 시간이란 양이 존재하지 안는 수학에서는 얼마나 오래 걸리는 작업을 하든, 시작과 끝만 같다면 같은 것이니까요. 과정은 중요하지 않고, 결과만 같으면 같은 것입니다.</p>
<p>최종 결론은, 카테고리 <code>C</code>,<code>D</code>는 펑터<code>F</code>, <code>G</code>, 자연 변환<code>ϵ</code>, <code>η</code>가 있으면(Adjunction이 있으면) 같은 것처럼 볼 수 있을 정도로 같다(다르다)입니다.</p>
<p>※ <code>ϵ</code>은 <code>counit</code>이라 부르고, <code>η</code>는 <code>unit</code>이라 부르기도 합니다.</p>
<h2 id="요약">요약</h2>
<p><code>C</code>, <code>D</code> 둘이 얼마나 같은데?</p>
<ul>
<li>둘이 완전히 같아.<br />
(완전히 같다는 정의하기 무척 어려운 거란 생각이 듭니다. 하지만, 전 티없이 맑은 정의를 원하는 것이 아니라, 현실 문제를 모델링할 때 문제 없을 정도의 정밀함만 있으면 됩니다.)</li>
<li>isomorphism으로 같아.<br />
<code>C</code>, <code>D</code> 둘은 다르지만, isomorphism으로 같게 볼 수 있는 것</li>
<li>Natural isomorphism이 있는 관계야.<br />
<code>C</code>, <code>D</code> 둘은 다르고, isomorphism도 없지만, 둘 간의 펑터를 <code>id</code>와 같게 볼 수 있게 하는 Natural isomorphism이 있는 관계야</li>
<li><code>C</code>, <code>D</code> 둘은 다르고, isomorphism도 없고, Natural isomorphism인 펑터 합성도 없지만, Adjunction관계의 펑터 합성이 있는 관계야.</li>
</ul>
<p>아래는 과연 현실에서 <strong>자연 동형</strong>이 어떤 직관으로 나타날까 고민하다 나온 상상입니다. 아래는 우선 <code>G∘F</code>만 보겠습니다.</p>
<figure>
<img src="../images/adjunction.jpg" alt="동형, 자연동형이 있는 관계, Adjunction이 있는 관계" /><figcaption aria-hidden="true">동형, 자연동형이 있는 관계, Adjunction이 있는 관계</figcaption>
</figure>
<p>동형, 자연동형, Adjunction은 그림에서 빨간 변형에 따라 구분이 되는 것으로 생각하고 있습니다. (동일한 일이 <code>F∘G</code>에도 일어난다고 가정해 주세요.)</p>
<ul>
<li>빨간 변형이 없다면 <strong>C와 D는 동형</strong></li>
<li>빨간 변형을 <strong><em>항상 예측할 수 있다면, 혹은 항상 알 수 있다면, C와 D사이에는 ID_C와 자연 동형인 펑터 G∘F 합성이 존재</em></strong>. 자연 동형이라면 <code>ID_C</code>나 <code>ID_D</code>에서 역으로 <code>F∘G</code>나 <code>G∘F</code>를 찾을 수도 있어야 하니 얼마나 변형됐는지 정보를 잃어버리면 안됩니다.</li>
<li>빨간 변형을 버리거나 참조해서, 어떻게든 수긍할만한 새로운 변형 생성을 허락한다면 <strong>C와 D는 Adjunction관계인 펑터F, G 합성이 존재</strong></li>
</ul>
<p>※ 변형이 일어났다는 말은, 곧 <code>F</code>가 <code>x1</code>이란 정보를 잃어버리면서 온다는 얘기로 보입니다.</p>
<p>아마도 이런 인포멀한 접근이, 전공 선수분들한테는 의미가 없을지도 모르겠습니다. 전 현실 문제를 보고, 펑터로 이리 저리 변환을 하는데, 어떤 경우가 보이면 Adjunction을 이용해 모델링해야겠다란 생각이 들 수 있도록 하는 게 목표입니다.</p>
<p>참고. 다음 글은 찾은 자료 중, 직관에 대한 설명이 가장 많이 등장하는, 제 입맛에 딱 맞는 글입니다. 예시를 벡터 스페이스로 들고 있어 그리 쉽지는 않지만, 딱딱한 정규 텍스트들보다는 좋았습니다.<br />
<a href="https://www.math3ma.com/blog/what-is-an-adjunction-part-1">What is an Adjunction? Part 1 (Motivation) - math3ma</a><br />
<a href="https://www.math3ma.com/blog/what-is-an-adjunction-part-2">What is an Adjunction? Part 2 (Definition) - math3ma</a></p>
<p>Sun Nov 26 10:22:33 PM KST 2023 작성 중…</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
