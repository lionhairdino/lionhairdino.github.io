<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">

<head>
  <script>
    (function () {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark') {
        document.documentElement.classList.add('dark-mode');
        console.log(savedTheme);
      }
    })();
  </script>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>lionhairdino - Adjunction을 만드는 두 Adjoint 펑터로 모나드 표현하기</title>
  
  <meta name="description" content="카테고리 이론에서 모나드를 설명하는 방법 중 하나인 Adjoint Functor를 비수학적으로 해석합니다." />
  <meta property="og:description" content="카테고리 이론에서 모나드를 설명하는 방법 중 하나인 Adjoint Functor를 비수학적으로 해석합니다." />
  
  <link rel="stylesheet" type="text/css" href="../css/default.css" />
  <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
  <link rel="shortcut icon" href="../favicon.ico" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
  <link rel="manifest" href="../site.webmanifest" />
  <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
  <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
  <meta name="msapplication-TileColor" content="#ff7500" />
  <meta name="theme-color" content="#ffffff" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Adjunction을 만드는 두 Adjoint 펑터로 모나드 표현하기" />
  <meta property="og:site_name" content="Lionhairdino" />
  <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-11-16-adjoint.html" />
  
  <meta property="og:image" content="https://lionhairdino.github.io/images/adjunction_triangle.jpg" />
  
  
  <meta name="keywords" content="Monad, Functor, Identity, Natural Transformation, Isomorphic, Isomorphism, haskell, 하스켈, 함수형, Functional">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-E9WZ6VXGHP');
  </script>
  <script src="../script/copycode.js"></script>

  <script src="../script/darkmode.js"></script>
  <script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
  <meta name="fediverse:creator" content="@lionhairdino@mastodon.social" />
  <link rel="alternate" type="application/rss+xml" title="상상 하스켈 - Lionhairdino" href="rss.xml" />
</head>

<body>
  <div id="header">
    <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
      <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
    </div>
    <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
      <a href="../">lionhairdino</a>
      <a href="../about.html">about</a>
      <!--<a href="/archive.html">archive</a>-->
    </div>
    <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
      <div style="display:inline-block;vertical-align: top;padding-top: 5px"></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:18px;border:none" src="../images/bluesky.svg"></a>
      </div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://discordapp.com/users/lionhairdino#7687"><img style="width:20px;border:none" src="../images/discord.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://x.com/lionhairdino"><img style="width:15px;border:none" src="../images/X.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://linkedin.com/in/lionhairdino-l-baaa54244"><img style="width:20px;border:none" src="../images/linkedin.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://github.com/lionhairdino"><img style="width:20px;border:none" src="../images/github.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://www.threads.net/@linohairdino"><img style="width:20px;border:none" src="../images/threads.svg"></a></div>
    </div>
    <div>
      <div style="display:inline-block;width:180px;">
        <div class="gcse-searchbox-only"></div>
        <div><button id="theme-toggle">
            <script>
              const savedTheme = localStorage.getItem('theme');
              if (savedTheme === 'dark')
                document.write("LIGHT");
              else
                document.write("DARK");
            </script>
          </button></div>
      </div>
    </div>
    <div>
      여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다. 여기 글을 처음 읽는 분은, 먼저 <a href="warning.html">주의문</a>을 꼭 읽어보세요.
    </div>
  </div>
  <div class="js-toc-content">
    <h1>Adjunction을 만드는 두 Adjoint 펑터로 모나드 표현하기</h1>
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on November 16, 2023
    
</div>

<p><strong><em>주의</em></strong> - 아래 내용은 <strong><em>유사 수학</em></strong>이란 지적을 들은 적이 있습니다. 여기 설명이 어떤 분들이 보기에는 유사 수학일 수 있습니다. 애초에, 수학적인 의미보다는 개념이 가지고 있는 어떤 아이디어가 프로그래밍에, 하스켈에 녹아든 건지 찾는 게 목표로, 굳이 유사 수학이 아니라고 밀어 붙이진 않겠습니다. 주제는 수학에서 가져온 것이지만, 수학적인 의미를 찾는 분들을 위한 글이 아닙니다. 아마도 수학 전공이나, PL 전공분들이 보기에 적당하지 않은 상상, 그리고 당연히 오류가 있을 수 있습니다.</p>
<p>현재의 제 수학 배경으론 완벽히 이해하기엔 무리가 있지만, 적정선까지 이해를 하면, 함수형 프로그래밍으로 현실을 모델링할 때 분명 힘이 될 개념이라 생각합니다. 하스켈 프로그램은 하나의 거대한 모노이드로 만들어지니, 무언가를 같거나, 조금 다른 걸 우겨서라도 같다고 보는 테크닉이 중요합니다. 모나드는 (이펙트가 추가 되며) 조금 달라진 걸 원래의 것과 같게 볼 수 있는 방법에 대한 얘기였습니다. Adjunction도 두 개의 무언가가 얼마나 같은 가를 포멀하게 얘기하는 하나의 방법입니다. 둘이 연관성이 있을 거라 예측할 수 있습니다.
참고 - <a href="../posts/2022-03-25-beforeMonad.html">모나드, 같음 - m (m a)와 m a는 얼마나 다를까?</a></p>
<p>카테고리 이론에 대한 글을 남기는 건, 어설퍼서 잘 안하는데, 재미난 상상이 떠올라 남깁니다. 아래가 궁금하지 않은 분들은 읽을만한 글이 아닙니다. 항등, 동형, 펑터, 자연 변환에 대해 간단히 짚고 가긴 하지만, 부족한 설명들이니, 다른 정식 텍스트들을 통해 제대로 알아두시면 좋습니다.</p>
<ul>
<li>왜 두 개의 펑터로, 얼마나 같은지를 표현할까?</li>
<li>두 개가 얼마나 같은지를 따지는데 왜 자연 동형 얘기가 나올까?</li>
<li>왜 <code>ϵ</code>과 <code>η</code>의 화살표 방향이 반대일까?</li>
<li>모나드와 어떤 연관성이 있을까?</li>
</ul>
<p><code>=</code>을 쓸만큼 같지 않으면 <code>~</code>도 쓰고, <code>≃</code>, <code>⋍</code>, <code>≅</code>, …(<code>=</code>과 여러 기호의 조합)을 써서 그래도 어찌 보면, 어느 정도는 같게 볼 수 있다고 말하는 개념들이 많습니다. Adjunction도 그들 중 하나입니다.</p>
<p>다시 한 번 말하지만, 수학 카테고리 이론의 Adjunction을 정교하게 공부하려는 분에게 어울리는 글이 아닙니다.</p>
<p><span class="citation" data-cites="todo">@todo</span>: 영어 용어와 우리말 용어가 마구잡이로 섞여있다. 한 쪽으로 통일해야 하지 않을까?</p>
<h2 id="얼마나-같은-걸까">얼마나 같은 걸까</h2>
<p>모나드를 해석하면서, 이펙트가 섞여 있는 것들 타입을 맞춰 나가는 훈련을 했으니, “같다”는 개념에 약간의 지식이 생겼겠지 하고 붙었습니다. 하지만, 동형, 자연 변환 등의 기본 용어 조차, 어렵사리 어떤 동작을 하는지만 알지, 의미를 충분히 알지 못하고 있구나를 느꼈습니다. 역시, “같다”는 개념은 어려운 주제 같습니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>F∘G   = , ~=, -&gt;  id_D   </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>G∘F   = , ~=, -&gt;  id_C  (나중에 얘기하겠지만, 이건 -&gt;는 안되고 &lt;-여야 합니다.) </span></code></pre></div>
<p>위에 식 중 어떤 걸 만족하냐에 따라 <code>C</code>와 <code>D</code>의 조금씩 다른 관계를 표현할 수 있습니다. 여기에 숨은 뜻을 보기 위해 아래 질문들을 먼저 고민해 봤습니다.</p>
<p>isomorphic인 것과 homomorphic 중 isomorphic이 아닌 것들의 차이는 뭘까요? 구조는 유지하며 변환해 갔지만, 다시 처음으로 돌아오지 못한다입니다.(역연산이 존재하지 않음) 어떤 경우에 처음으로 돌아오지 못할까요? collapse 됐다거나, 새로운 뭔가가 추가 됐다거나 해서 처음 정보를 잃어버리거나 관계 없는 경우에 돌아 갈 수 없지 않을까 추측하고 있습니다. 처음을 잃어버려도 필요한 정보는 살아 있는 가장 간단한 경우를 예를 들면, <code>0</code>포함 자연수들에서 <code>1+2</code>의 결과로 <code>3</code>을 받았을 때, <code>3</code>만 보고선 <code>1+2</code>의 결과인지 <code>1+1+1</code>, <code>3+0</code>, …인지 알 수 없습니다. 하지만, 필요한 정보는 <code>3</code>이기 때문에 처음 출발지를 잃어버려도 상관없습니다. Writer 모나드의 로그 누적을 보면 <code>"this is log"</code>에서 <code>"this is"</code>가 먼저 쌓였는지 <code>"this"</code>가 먼저 쌓였는지 알 수 없습니다. 하지만 필요한 건 최종 전체 로그이니, 어떻게 쌓였는지 몰라도 상관없습니다. Reader 모나드의 경우 외부 스코프의 상수값을 두 번 읽어오나, 한 번 읽어오나 차이가 없으니, 몇 번을 읽었는지 알 필요가 없습니다. Maybe의 경우 기존에 없던 <code>Nothing</code>이 추가 되어 돌아갈 수 없습니다. 세상엔 이 정도로만 같으면, 이 정도의 관계만 있으면 되는 경우가 무수히 많습니다.</p>
<p><code>id</code>와 자연 동형인 것과, <code>id</code>로 변환해주는(처럼 볼 수 있게 해주는) 자연 변환이 있는 것의 차이가 뭘까요?<br />
카테고리가 동형인가를 알아보려면, 둘 사이에 <code>id</code>펑터 역할을 할 수 있는 펑터 조합이 있는가를 봅니다.<br />
펑터 조합이 <code>id</code>펑터와 동형인지 보려면, 자연 동형인가를 알아봅니다.(만일 없다면, 여기서 제약을 조금 낮춰 자연 동형과 비슷하게 볼 수 있는 방법을 찾는데, 방법이 찾아지면 동형 관계는 아니지만, 그보다는 좀 약한 Adjunction이 (펑터가) 있는 관계라 합니다.)<br />
그럼, 자연 변환이 동형인가를 보려면? 계속 뎁스가 들어가며 관계를 보면, 무한히 관계를 표현하는 개념이 나와야 될 것 같지만, 자연 변환 동형은 자연 동형을 이루는 각 성분들이 모두 동형인가를 봅니다.<br />
카테고리에선 대상 언급 없이 모든 걸 풀어나가니, 같음도 마찬가지로, 대상을 보지 않고 정의합니다. 모피즘이 되는 것들이 <code>id</code> 모피즘과 같아지는지, 동형과 같거나 비슷하게 만들 방법이 있는지 등을 찾아 봅니다.</p>
<p>모르는 것 투성이라 글로 정리하는 게 의미있을까 싶어 계속 미루고 있었는데, 약간 기록할만한 상상이 생겨 정리했습니다.</p>
<p>얼마나 같은가란 말이 이상하지 않나요? 같으면 같고, 다르면 다르지, 어느 정도 같다는 건 그냥 다르다란 말 아닌가요? 다르지만, 일부가 같다면, 아예 전부 다른 것과는 별도로 써먹을데가 있습니다. 가진 정보가 두 가지인데, 이 중 하나는 같고, 다른 하나는 다르다면, 둘 다 다른 것과는 달리 볼 수 있습니다.</p>
<p>비유하자면, 10가지 정보가 모두 같으면 동형,<br />
필요한 9개는 다 같고, 관심 없는 나머지 1개는 같은지 다른지 관심 없으면 준동형,<br />
필요한 9개 중 8개는 같고, 하나는 다르면 Adjunctions 관계의 펑터가 있는 관계<br />
이런 느낌입니다. 그래도 10개 중 8개는 같으니, 닮았다 할 수 있고, 아예 다른 것과는 다르니 이 걸 위한 형식화를 해보자 같습니다. 너무 둘이 다르면 의미가 없는 경우가 많습니다. 어디까지나 비유입니다.</p>
<h2 id="adjoint-adjunction-단어-뜻">Adjoint, Adjunction 단어 뜻</h2>
<p><code>Ad</code>(무엇과 가까이, 어디를 향해, 무엇과 관련하여) - <code>Joint</code>(jungere 결합하다)<br />
<code>Ad</code> - <code>Junction</code> “closely connected, joined, united”를 뜻하는 라틴어 Adjunction</p>
<p>일상 생활에서도 가끔 영어 자체로 만나는 용어입니다. 고속도로와 고속도로가 만나서, 한 고속도로에서 다른 고속도로로 옮겨 갈 수 있는 연결 지점을 Junction(JC, 우리말로는 분기점)이라 부릅니다. Ad는 보통 도움을 주는것에 붙입니다. verb, adverb 처럼요. Adjunction은 연결을 도와주는 무언가일거라 상상하면 되겠습니다.</p>
<p>Adjoint 용어를, 무슨 뜻으로 붙인 건지 명확하게 정의하는 곳은 못 찾았습니다. 보통 둘이 특별한 관계가 있다는, 매우 추상적인 설명으로 (불친절하게) 끝나는 자료가 대부분입니다. (안하니만 못한 말 같은 이런 말로 용어 사용을 설명하다니!) 거의 같은 말이지만, 조금 더 구체적인 느낌을 주게 말하자면, 적당한 펑터 짝을 고르면, 자연 변환 두 가지를 동원해 두 카테고리를 꽤 닮은 꼴로 만들 수 있을 때, 각 각을 오른 쪽, 왼 쪽 Adjoint 펑터라 하고, 연결을 도와주는 자연 변환 두 가지와 합쳐 Adjunction이라 부릅니다. 두 카테고리 사이에 Adjunction을 두면 isomorphic보단 약하지만, 어찌 보면 그런대로 같다고 볼 수 있게 됩니다. 카테고리를 오가게 하는 두 펑터를 합친다고 딱 Isomorphism이 되는 건 아닌데, 그렇다고 관계가 별로 없다고 보기엔, 적당한 상황에선 Isomorphism과 비슷한 걸로 만드는 역할을 하니 붙일 이름이 필요하지 않았을까 싶습니다. 하나의 카테고리를 다른 카테고리와 (isomorphic보단 덜하지만) 강하게 연결할 때 쓰는 무언가입니다.</p>
<p>둘이 같다를 둘이 <strong>연결junction</strong>할 수 있다는 메타포로 바라보면 수긍가는 용어입니다. 서로 다른 크기의 파이프 둘을 연결할 때 쓰는 커넥터입니다.</p>
<figure>
<img src="../images/adjunction_arrow_meaning8.jpg" alt="Ad Junction!" />
<figcaption aria-hidden="true">Ad Junction!</figcaption>
</figure>
<p>※ 명사냐 형용사냐로 갈릴 뿐, Adjoint와 Adjunction은 뜻 자체는 거의 같은 뜻으로 쓰입니다.</p>
<p>아래 용어들은 몇 번을 봤던 개념들인데, 다 알고 있다 생각했는데, 의외로 혼란스러운 부분이 많았습니다. 항등원은 어떤 연산에 대해서 정의되는데, 항등 함수와 항등 펑터, 항등 자연 변환들은 어떤 “연산”에 대해 정의된 것인가부터, 텍스트마다 <code>F</code>, <code>id_F</code>를 펑터, 항등 펑터, 항등 자연 변환 표현으로 혼용해서 쓰는 바람에 더 혼란스러웠습니다. 항등 뭐뭐들은 정의와 성질을 혼동하기도 했습니다. 정식 정의들이 아니라 Adjunction을 이해하는데 필요한 아이디어만 정리했습니다.</p>
<p>Adjunction 정의 방법이, universal morphisms을 쓰는 것, Hom-set을 쓰는 것, counit-unit을 쓰는 것 세 가지가 있는데, 여기서는 세 번째 counit-unit 으로 정의하는 걸 뜯어 봅니다.</p>
<p>추측 - 둘이 같다, 둘이 isomorphic하다, 둘이 Adjunction이다.. 식으로 쓰나 했는데, Adjunction은 두 카테고리가 사이에 두어, 두 카테고리를 연결할 때 도와주는 도구 같은 겁니다.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>두 카테고리는 Isomorphism이 있는 Isomorphic 관계</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>두 카테고리는 Adjunction이  있는     ~      관계 -- 따로 ~에 들어가는 용어는 없나 봅니다.</span></code></pre></div>
<p>식으로 말하면 되는 듯 합니다.</p>
<h2 id="펑터functor">펑터Functor</h2>
<p>카테고리에선 대상을 매핑하는 동작은 모피즘, 카테고리를 매핑하는 동작은 펑터라 부릅니다. 함수가 한 가지만 매핑한다면, 펑터는 오브젝트도, 모피즘도, 모피즘 합성도 모두 매핑(카테고리를 매핑)해야 합니다. 참고 - <a href="../posts/2023-03-09-functor.html">한 번쯤 나올 법 했는데, 아직 없었던 펑터 이야기</a></p>
<h2 id="동형isomorphic">동형isomorphic</h2>
<p>텍스트들의 설명으론,
&gt; “구조가 같은 두 대상” 사이에서 “모든 구조를 보존하는 사상”을 isomorphism이라 합니다.</p>
<p>개인적으론 매우 마음에 들지 않는 설명입니다. 이미 구조가 같은 대상이라 얘기했는데, 그럼 보존됐다고 보는 게 당연한, 같은 말을 두 번 한 듯한 문장입니다. 전체 구조는 다른데, A가 가진 구조와 동일한 구조가 B에 있으면 Homomorphic이라 합니다. 전체 구조까지 같아서 이름만 다를 뿐, 같은 것으로 볼 수 있는 건 isomorphic이라 합니다. 둘이 전체 구조가 다르더라도, 둘을 일대일 대응으로 오갈 수 있게 해주는 isomorphism이 있으면(<strong>upto isomorphism</strong>), isomorphic이라고 말합니다.<br />
한 시스템에서 어떤 상태가 어디에서 출발해서 어떤, 어떤 값을 거쳐 어디에 도달하는 상황을 생각하면, 이를 모델링한 곳에서도 항상 동일한 경로로 변경이 되어, 모델링 한 것으로 현실을 완벽히 추적할 수도 있고, 거꾸로 현실에서 모델링한 것이 어떻게 값이 변해갈지 완벽히 추적할 수 있는 걸 말합니다. 두 시스템의 상태가 완전히 <strong>일대일 대응</strong>으로 어느 한 쪽을 알면, 다른 한 쪽도 알 수 있는 iso(같은)morphic(모양)이라 합니다.</p>
<p><code>homo-</code> 는 <code>same</code>을 의미하고, <code>iso-</code>는 <code>equal</code>을 의미한다고 합니다.<br />
<code>same</code>은 <code>identity</code>를 보는 것이고, <code>equal</code>은 <code>equality</code>를 본다고 합니다. 동어 반복 같은 설명입니다.</p>
<p>“today’s exchange rate 1 dollar is <strong>equal</strong> to 0.91 euros. but they are not the <strong>same</strong> thing”<br />
구글링으로 여러 설명을 찾아 봐도 딱히 명쾌하단 느낌을 주는 설명이 없습니다.</p>
<p>대수에선 위 예문과 좀 다른듯 한데, 제 경험적으로 느끼는 건, 내가 주목하는, 필요로하는 구조는 같고, 그 외는 같을 수도, 다를 수도 있는 (거의 비슷한) 것에는 <code>homo-</code>를 붙이고, 모든 구조가 같아 일대일 대응이 되어 (역변환이 되는 것) 서로 바꿔칠 수 있는 것, 이름만 다르지 전혀 구별할 수 없는 것에는 <code>iso-</code>를 붙입니다. 물론 “upto isomorphism”일 때 얘깁니다.</p>
<h2 id="항등원identity">항등원Identity</h2>
<p>어떤 연산에 항등원Identity(Element)이라면, 항등원과 연산하면 원래 값이 바뀌지 않는, 다른 말로 하면 해당 연산과 만났을 때 <strong>아무 일도 일어나지 않는</strong> 걸 항등원이라 합니다. 대수학 정의를 보면<br />
<code>e_L * a = a</code> 이 성립하면 좌항등원<br />
<code>a * e_R = a</code> 이 성립하면 우항등원<br />
이 둘이 모두 성립하면 그제서야 항등원이라 합니다. (추가적으로 따라야 하는 법칙들이 몇 개 있습니다.)<br />
참고 - <a href="../posts/2022-12-12-CommutativeAssociativeIdentity.html#%ED%95%AD%EB%93%B1%EC%9B%90">결합 법칙, 교환 법칙, 항등원, 합성</a></p>
<p>※ 잡소리 - 연산은 인자만큼 대상을 변환하는데, 어떤 인자로 변환을 시도했더니 변환되지 않더라에서, 이 인자를 연산의 고유한 특성을 가리키는 “Identity”로 부르고 있습니다. 수많은 연산 중에, 이 연산을 가리킬 수 있는 고유 특성이 될까요? <code>0</code>이라는 Identity를 가진 연산은 <code>+</code>뿐이 없는 걸까요? 자연수에 연산을 적용한 걸 각각 나눈다면, 여기 팀은 <code>0+0+0</code>, <code>0+1+0</code>, <code>0+2+0</code>… 모두 이 모양을 가지고 있습니다. 이 팀의 Identity는 <code>0+   +0</code>이라는 뜻일까요?</p>
<h2 id="항등-함수identity-function">항등 함수Identity Function</h2>
<p><code>id_X: X -&gt; X</code><br />
모양은 <code>X</code>를 넣어주면 변형, 변환 없이 그대로 <code>X</code>가 나오는 함수입니다. 정식 정의는 다른 텍스트들을 참고해 주시고, 제가 눈여겨 보는 것은 다음 성질입니다.<br />
좌항등원, 우항등원처럼 임의의 함수 <code>f: X -&gt; Y</code>와 합성<code>(⋅)</code>이라는 연산에 대해<br />
<code>f ⋅ id_X = f</code><br />
<code>id_Y ⋅ f = f</code><br />
성질을 만족해야 합니다. 잘 보면 <strong>id_X와 id_Y 두 가지</strong>가 나옵니다. 단일 값인 <code>1</code>같은 값의 더하기 연산에 대한 항등원은 <code>1 + 0 = 0</code>, <code>0 + 1 = 0</code> 으로 하나의 값인 <code>0</code>이 항등원이었지만, 함수는 <strong>한 가지 정보</strong>를 가지고 있는 값이 아닙니다. <strong>두 가지 정보 X, Y</strong>를 갖고 있는 <code>X -&gt; Y</code>란 함수의, <strong>함수 합성(연산)</strong>에 대한 항등원 역할을 하는 건, <strong>두 가지</strong>를 봐야 한다고 예측할 수 있습니다. 시작점과 끝점이 있는(방향이 존재하는) 것의 좌항등원, 우항등원을 봐야 하니, 두 가지가 나올 수 밖에 없습니다.</p>
<p>만일 <code>f: X -&gt; Y</code> 함수라면,<br />
<code>f ⋅ id_X</code>를 하려면 <code>id_X: X -&gt; X</code> 타입일테고,<br />
<code>id_Y ⋅ f</code>를 하려면 <code>id_Y: Y -&gt; Y</code> 타입이 되어야 합성 할 수 있습니다.<br />
타입 일치를 보면서, 그냥 당연하다고 넘어가면 되겠지만, 전 두 가지 정보가 있는 것의 연산에서 항등원은 두 가지를 봐야 한다는 것에 눈이 갔습니다. 하스켈에서는 폴리모픽으로 정의해서 <code>id :: a -&gt; a</code> 하나로 표현만 할 수 있지만, <code>(⋅)</code> 연산에 대해 항등 함수 성질을 만족하려면 <code>id_X</code>, <code>id_Y</code> 두 개의 항등 함수가 있어야 합니다.</p>
<h2 id="항등-펑터identity-functor">항등 펑터Identity Functor</h2>
<p>Identity 펑터는 뭘 의미할까요? (Identity 모피즘과 구별) 어떤 연산에 Identity라는 걸까요?<br />
함수가 함수 합성이란 연산에 대해 항등원을 찾았듯이, 펑터 합성 <code>(∘)</code>에 대한 항등원입니다. 함수 합성 <code>(⋅)</code>과 구별하기 위해 속이 빈 동그라미로 표기하겠습니다.<br />
카테고리 <code>C</code>, <code>D</code>가 있을 때<br />
정의는 <code>id_C: C -&gt; C</code> 모양에 <code>C</code>에 있는 모든 대상<code>X</code>에 대해 <code>id_C(X) = X</code> 이고, 모든 모피즘 <code>f</code>에 대해 <code>id_C(f) = f</code> 이고,<br />
펑터 <code>F</code>와 합성해서 다음을 성질을 만족하면<br />
<code>F: C -&gt; D</code><br />
<code>id_D ∘ F = F = F ∘ id_C</code><br />
<code>id_C</code>, <code>id_D</code> 들을 항등 펑터라 합니다. 항등 성질을 찾을 때, 좌 우를 봐야 하니 자연히 두 가지가 나옵니다.</p>
<p>어설프게 펑터, 항등원, 항등 함수를 차례로 짚으면서 온 이유가, 어떤식으로든 펑터로 <strong>항상 같음</strong>(항등)을 말하려면 <strong>두 가지</strong> 정보가 필요하다는 걸 보기 위해서입니다.</p>
<p>어떤 타입의 대상이 작업(펑터)을 거친 후에도 같은 타입으로 돌아 오는 모노이드로 만들려면, 원래부터 <strong>같다는 개념 자체가 두 가지 정보를 필요</strong>로 하고, 펑터 두 개로 표현할 수 있는 게 당연하다로 이어지는 상상입니다. 다 작성한 후에, 아 잘 못 생각했구나 라고 할 수도 있는, 아직까지는 그저 상상입니다.</p>
<h2 id="자연-변환natural-transformation">자연 변환Natural Transformation</h2>
<p><code>F: C -&gt; D</code><br />
<code>G: C -&gt; D</code><br />
두 펑터를 매핑하는 <code>η: F -&gt; G</code>(혹은 두 줄 화살표 <code>η: F =&gt; G</code>)를 자연 변환이라 합니다. ()펑터는 <strong>대상</strong>과 <strong>모피즘</strong>을 모두 매핑하는 동작을 가지고 있습니다. 이런 동작을 가진 작업 둘을 매핑하므로, 한 가지 정보들을 매핑하는 함수와는 달리 다음 성질을 추가적으로 만족합니다.<br />
<code>X</code>, <code>Y</code>는 카테고리 <code>C</code>의 대상object, <code>f: X -&gt; Y</code>는 모피즘</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>F(X) --- F(f) ---&gt; F(Y)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a> |                  |</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>η_x                η_y</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a> |                  |</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a> V                  V</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>G(X) --- G(f) ---&gt; G(Y)</span></code></pre></div>
<p>(<span class="citation" data-cites="todo">@todo</span>: 그림으로 대체할 것)</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>η_y⋅F(f) = G(f)⋅η_x</span></code></pre></div>
<p>말로 풀면(상상하면) 자연 변환은 <strong>두 펑터가 얼마나 다른가</strong>를 나타내는 모피즘입니다.<br />
<code>F</code>로 변경한 <code>F(f)</code>를 적용하고, <code>η</code>로 보정한 것과<br />
<code>η</code>보정을 먼저하고, <code>G</code>로 변경한 <code>G(f)</code>를 적용한 것이 같습니다.</p>
<p>상상 - 하나의 <code>f</code>를 변형해서 <code>F(f)</code>와 <code>G(f)</code> 만들었을 때, 둘은 어떤 관계가 있을까요? 최종 결과값 <code>F(Y)</code>와 <code>G(Y)</code>를 봐서는 별다른 관계가 없어 보이지만, 한 뿌리(<code>f</code>)를 변형한 두 가지(펑터의 결과)는 어떤식으로든 관계가 있지 않을까요?</p>
<p>자연 변환이 앞뒤로 붙는 걸 유심히 봐 둬야 합니다. 펑터는 함수와 마찬가지로 정의역domain, 치역codomain 두 가지 정보를 가지고 있습니다. 이렇게 시작과 끝이 있는 걸, 얼마나 다른지 보려면, 출발지는 얼마나 다른지, 도착지는 얼마나 다른지 두 가지를 봐야 합니다. 위 식은</p>
<p><strong><em>“F(f)를 적용하고, 도착지를 수정한 것 = 출발지를 수정하고 G(f)를 적용한 것”</em></strong></p>
<p>을 나타냅니다.</p>
<p>여기에 짚고 넘어가야 하는 뜻이 있습니다. 만일 <code>F</code>의 공역과, <code>G</code>의 공역이 같고, <code>F(f)</code>에 대응하는 <code>G(f)</code>가 반드시 있어야 가환할 수 있습니다. 자연 변환의 대상이 되는 두 펑터는 공역이 같아야 합니다. 나중 화살표가 뒤집어진 이유를 볼 때 필요합니다.</p>
<p><code>F(X)</code>에서 <code>G(Y)</code>로 가는 모피즘은 두가지가 나왔습니다.</p>
<ol type="1">
<li><code>η_y∘F(f)</code></li>
<li><code>G(f)∘η_x</code></li>
</ol>
<p>두 개의 결과는 같습니다. 여기엔 재밌는 직관이 있습니다. 단순하게 <code>a-&gt;b</code> 모피즘을 <code>a</code>에서부터 거리를 재는 것과 비유해 보겠습니다. 대상의</p>
<ol type="1">
<li>거리를 재고, 기준점을 옮기나,</li>
<li>기준점을 옮기고, 거리를 재거나</li>
</ol>
<p>결과가 같다는 말과 비슷합니다. 원래부터 거리를 잰다는 행동에는 <strong>기준점을 정하는 것부터 시작</strong>인 걸 생각해 보면, 당연한 결과입니다. 다시 말해, 거리를 재는 행동, 즉 <code>a-&gt;b</code> 모피즘은 기준점 <code>a</code>를 옮겨서 <code>b</code>로 간 경우와, <code>a</code>는 그대로 두고 <code>b</code>를 옮긴 경우가 같은 동작일 경우가 나올 수 밖에 없습니다. 모든 숫자는 <code>0</code>에서부터 거리를 잰 값입니다. <code>1</code>은 <code>0-&gt;1</code>, <code>2</code>는 <code>0-&gt;2</code>… 로 볼 수 있다는 말입니다. <strong><em>세상의 모든 값은 사실은 컴퓨테이션으로 볼 수 있다</em></strong>라고 해서 좋은 소리를 못들은 적이 있는데요. 자연 변환이 하는 얘기가 이 말이 아닌가 조심스럽게 남겨 봅니다. 모든 대상을 비교할 때는 기준점부터 같은가를 확인하고, 같은 기준점에서 같은 거리에 있는가를 봐야지 같다고 말할 수 있습니다. <code>기준점</code>, <code>떨어진 거리</code>, <code>방향</code> 이렇게 3가지가 맞아야지만 “같다”라고 얘기할 수 있습니다.</p>
<p><span class="citation" data-cites="todo">@todo</span> 아직은 Adjunction의 두 자연 변환이 화살표가 뒤집어진 이유에 대한 직관에 도달하기엔 좀 미흡하다.</p>
<p>※ 펑터가 대상이 되는 펑터 카테고리에선 모피즘이 자연변환입니다.</p>
<p>※ 같은 둘의 자연 변환을 보겠습니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>F(X) --- F(f) ---&gt; F(Y)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a> |                  |</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>id_X               id_Y</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a> |                  |</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a> V                  V</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>F(X) --- F(f) ---&gt; F(Y)</span></code></pre></div>
<p><code>id_Y∘F(f) = F(f)∘id_X</code>가 나왔습니다.<br />
<code>X-&gt;Y</code>의 항등 함수를 볼 때, 나왔던 식입니다.</p>
<pre><code>id_X ----&gt; F(f) ----&gt; id_Y</code></pre>
<p>모피즘은 강조했듯이 한가지 정보가 아닙니다. <code>a-&gt;b</code>는 <code>a</code>, <code>b</code> 그리고 <code>-&gt;</code> 방향까지 세가지의 정보가 있습니다. 이들이 같은가 볼 때는 역시 세 가지를 모두 봐야 합니다.</p>
<p><code>id_X</code>,<code>id_Y</code>, 합성<code>∘</code> 순서</p>
<p>조금 억지스럽지만, 기준점을 확인(<code>id</code>)하고, 거리를 재든, 거리를 재고 기준점을 확인하든 차이가 없다는 얘깁니다.</p>
<p>모피즘의 비교에 있어 정말 잘 만든 표현 방법 같습니다.</p>
<h2 id="항등-자연-변환identity-natural-transformation">항등 자연 변환Identity Natural Transformation</h2>
<p>카테고리 <code>C</code>, <code>D</code><br />
펑터 <code>F: C -&gt; D</code><br />
항등 자연 변환 <code>id_F(F) -&gt; F</code><br />
펑터 <code>F</code>를 변환해도 <code>F</code>가 나오는 자연 변환입니다. 항등 자연 변환도 역시 왼 쪽, 오른 쪽을 봐야 합니다.</p>
<p>※ 텍스트들이 <code>id_F</code>가 자연 변환인지, 펑터인지 딱 짚어서 말해주지 않는 경우가 많습니다. 심지어 그냥 <code>F</code>로 쓰고 자연 변환을 뜻할 때도 있고, 항등 자연 변환을 뜻할 때도 있습니다. 알아서 잘 보는 수밖에 없다고 합니다.</p>
<h2 id="자연-동형natural-isomorphic">자연 동형Natural Isomorphic</h2>
<p>위의 자연 변환 가환 다이아그램에서 자연 변환 <code>η</code>의 동작을 보면, 시작지를 변형하는 <code>η_x</code>와, 도착지를 변형하는 <code>η_y</code>가 따로 있습니다. 이들 각 각이 모두 역 매핑이 존재한다면, 즉 <code>η_x_inverse</code> , <code>η_y_inverse</code>가 있어, <code>η</code>의 모든 “성분component”들이 isomorphic일 때, 자연 동형이라 합니다. 이럴 때 <code>η</code>를 isomorphism of functors라고도 부릅니다.</p>
<p><code>F</code>와 <code>G</code>는 다르지만, <code>η</code>가 있으면 <code>F</code>와 <code>G</code>는 구별할 수 없는 “같은” 펑터입니다.</p>
<p>이제 슬 본론으로 들어갈 준비를 마친 것 같습니다. 위 용어 설명들은 텍스트에 나오는 정확한 내용들이 아니라 조금씩 상상이 들어가 있습니다. Adjunction에서 <strong>같음</strong> 개념을 볼 때,</p>
<p>왜 <code>F</code>, <code>G</code> 두 펑터의 합성을 들여다 보는지,<br />
<code>F∘G = id_D</code>가 아니고, <code>G∘F = id_C</code>가 아니라서, <code>F</code>와 <code>G</code>의 합성 <code>F∘G</code>와 <code>G∘F</code>가 isomorphism 역할을 못 한다면,<br />
<code>ϵ(F∘G) = id_D</code>와 <code>η(G∘F) = id_C</code> 있으면 될 것 같은데, 왜 <code>G∘F = η(id_C)</code>가 있는지 보기 위한 사전 생각 스트레칭들입니다.</p>
<h2 id="adjoint-펑터">Adjoint 펑터</h2>
<p>※ 여기서는 Adjunction을 만드는 두 Adjoint 펑터가 만나서 모나드가 되는 것만 보려고 합니다. 결론부터 말하면, Adjunction도 결국 얼마나 같게 볼 수 있는가에 관한 얘기입니다.</p>
<p>우리말 번역으론 “수반 함자”라고 합니다. 隨伴 따를 수, 짝 반 : 어떤 사물 현상에 따라서 함께 생기는 것. 안타깝게도 전 번역이 딱히 더 익숙하지도, 더 구체적인 감을 주지도 않습니다.</p>
<p><code>C</code>,<code>D</code>는 카테고리, <code>F</code>,<code>G</code>는 펑터</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">F</span><span class="op">:</span> <span class="dt">C</span> <span class="ot">-&gt;</span> <span class="dt">D</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="dt">G</span><span class="op">:</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">C</span></span></code></pre></div>
<p><code>F∘G = id_D</code>이고, <code>G∘F = id_C</code>이면 카테고리<code>C</code>와 카테고리<code>D</code>는 동형isomorphic입니다. 조금 더 풀어서 얘기하면, 어딘가의 펑터 합성식에 <code>id_D</code>가 등장한다면, 아무런 추가 작업 없이 그냥 <code>F∘G</code>를 쓸 수 있습니다. 그런데, 현실에선 이렇게 딱 동형이 아닐 때도 의미가 있는 경우가 많습니다. Adjunction은 딱 동형은 아니지만 어찌 어찌하면 동형처럼 보일 때에 관한 얘기입니다.</p>
<p><code>F</code>와 <code>G</code>를 써서 Adjunction을 만들려면 필요한 <code>(ϵ, η)</code>는 다음과 같은 두 개의 자연 변환Natural Transformation으로 이루어진 순서쌍이라고 합니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>epsilon ϵ<span class="op">:</span> <span class="dt">F</span>∘<span class="dt">G</span> <span class="ot">=&gt;</span> id_D</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>eta     η<span class="op">:</span> id_C <span class="ot">=&gt;</span> <span class="dt">G</span>∘<span class="dt">F</span></span></code></pre></div>
<p>여기까지가 보통 텍스트들 서두에서 볼 수 있는 내용입니다. 참고-<a href="https://ko.wikipedia.org/wiki/%EC%88%98%EB%B0%98_%ED%95%A8%EC%9E%90">Wiki - Adjoint Functor</a>. 당연하게도 비수학인이 봐서 이해할만한 자료는 거의 없습니다. 이제부터는 대부분 제 상상입니다.</p>
<p>상상해보면, <code>ϵ</code>, <code>η</code>가 없으면 <code>F∘G</code>를 <code>id_D</code>처럼, <code>id_C</code>를 <code>G∘F</code>처럼 볼 수 없지만, <code>ϵ</code>, <code>η</code>의 도움을 받으면(보정한다면) <code>F</code>와 <code>G</code>의 합성으로 <code>id_D</code>, <code>id_C</code>와 같은 일을 할 수 있습니다.<br />
<code>F∘G</code>가 <code>id_D</code>가 아닌데, <code>ϵ</code>으로 살짝 보정하면 <code>id_D</code> 동작을 하고,<br />
<code>G∘F</code>가 <code>id_C</code>가 아닌데, <code>η</code>로 살짝 보정하면 <code>id_C</code> 동작을 한다고<br />
보면 순조롭게 넘어 갈 수 있을 것만 같습니다.</p>
<h3 id="ϵ과-η의-화살표가-반대">ϵ과 η의 화살표가 반대</h3>
<p>하지만, <code>η</code>가 <strong><em>화살표 방향이 반대</em></strong>입니다. <code>G∘F</code>를 주면 <code>id_C</code>를 돌려주는 게 아니라, <code>id_C</code>를 주면 <code>G∘F</code>를 돌려줍니다.</p>
<p>만일<br />
<code>F∘G</code>가 아무 조치 없이 <code>id_D</code>가 되고,<br />
<code>G∘F</code>가 아무 조치 없이 <code>id_C</code>가 되면<br />
카테고리 <code>C</code>와 <code>D</code>는 isomorphic합니다.</p>
<p><code>C</code>와 <code>D</code>가 딱 isomorphic하진 않지만,
<code>F∘G</code>가 <code>id_D</code>와 같지 않은데, <code>F∘G ~= id_D</code>가 있고,<br />
<code>G∘F</code>가 <code>id_C</code>와 같지 않은데, <code>G∘F ~= id_C</code>가 있어 자연 동형이면<br />
<code>C</code>와 <code>D</code>를 isomorphic<strong>처럼</strong> 볼 수 있게 됩니다.</p>
<p>지금부터는 거의 모두 상상입니다. <strong>틀린 걸로 확인되면 모두 지울 예정입니다.</strong></p>
<p>(너무 길어져, 이 부분만 따로 떼어 글을 올렸습니다. <a href="../posts/2023-12-05-adjunction_arrow_meaning.html">Adjunction에서 η와 ϵ의 화살표 방향이 반대인 이유</a>)</p>
<h3 id="시작점으로-다시-돌아오면-동형">시작점으로 다시 돌아오면 동형</h3>
<p>자연 변환은 한 카테고리에서 다른 카테고리로 가는 펑터를 변환하는데, 이 때 변환한 값도 원래의 카테고리들을 벗어나지 않습니다. <code>F∘G</code> 합성의 정의역, 치역을 보면 <code>id_D</code>와 같은 <code>D -&gt; D</code>로 원래 것과 같습니다. 사실은 <code>D -&gt; C -&gt; D</code>로 무려 현재 카테고리를 벗어났다가 돌아 오고 있지만, <code>id_D</code>와 같은 동작을 하게끔 하려는 게 목적입니다. 이 걸 척학적이라고 해야 할지, 인문적이라 해야 할지 모르지만, 그동안 “isomorphic하다” 라고 생각한 것들이, 시작과 끝을 제외하면 무슨 복잡한 일을 하고 있을 수도 있다는 생각이 듭니다. 컴퓨터의 computation과 달리 시간이란 양이 존재하지 않는 수학 세계에서는 얼마나 오래 걸리는 작업을 하든, 시작과 끝만 같다면 같은 것이니까요. 과정은 중요하지 않고, 결과만 같으면 같은 것입니다.</p>
<p>처음 Adjunction을 보고 떠올린 상상이, “달나라를 다녀와도 돌아 올 수만 있다면, 아무일도 일어나지 않은 걸로 해 줄게.” 입니다.</p>
<p>지금까지는 “같음”의 정도는 완전히 같음(이 건 수학적 정의를 모릅니다.) &gt; 동형Isomorphic &gt; 준동형Homomorphic 정도의 구분을 하고 있었는데, Homomorphic 중에 Adjunction이 있는 관계를 특징지을 수 있습니다.</p>
<h3 id="id와-동형isomorphic은-아니지만-준동형homomorphic">id와 동형isomorphic은 아니지만 준동형homomorphic</h3>
<p>우선, 여기선 같음의 기준을 Isomorphic으로 잡고 얘기를 이어가겠습니다.<br />
<code>F∘G</code> 펑터 합성에서 <code>id_D</code>펑터로는 갈 수 있지만 돌아오지 못하는 자연 변환이 있고, <code>G∘F</code> 펑터 합성에서 <code>id_C</code>펑터로 갈 수 있는데, 돌아오지 못하는 자연 변환이 있는 경우를 생각해 보겠습니다. 돌아오지 못한다는 건, 무언가 처음의 정보를 잃어버렸다는 얘기입니다. 하지만, 잃어버린 정보가 그다지 필요한 정보가 아니었다면, 무시하고 같게 볼 수 있을 정도의 관계일 경우도 있습니다. 조금씩 틀어진 걸 보정하려면 언뜻 생각하기에 아래 자연 변환이 있으면 될 것처럼 보입니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ϵ'<span class="op">:</span> <span class="dt">F</span>∘<span class="dt">G</span> <span class="ot">-&gt;</span> id_D   </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>η'<span class="op">:</span> <span class="dt">G</span>∘<span class="dt">F</span> <span class="ot">-&gt;</span> id_C   </span></code></pre></div>
<h3 id="isomorphic인지-보려면-fgf와-f의-관계-gfg와-g의-관계를-보면-된다">isomorphic인지 보려면 F∘G∘F와 F의 관계, G∘F∘G와 G의 관계를 보면 된다</h3>
<p>대부분의 텍스트에선 따로 설명없이 <code>F∘G∘F</code>, <code>G∘F∘G</code>가 등장하는데, 왜 이들이 조건에 등장하는지 말해주지 않고 시작하는 자료들이 많습니다. (Universal property로 접근하면 등장 이유가 좀 더 잘 보이긴 합니다.)<br />
카테고리에선 대상이 뭔지 관심 없습니다. 두 카테고리가 isomorphic인지 본다면, 한 대상에서 출발해서 돌아온 대상이 같은 걸 보는 게 아니라, 둘 사이를 오갈 수 있는 펑터 <code>F</code>와 펑터 <code>G</code>가 있을 때, <code>F</code>의 경우 <code>F</code>로 갔다가, <code>G</code>로 <strong>돌아온 대상이 같은 가 보는 게 아니라, 돌아온 대상에 또 F를 적용했을 때, 동작이 변하지 않는 걸</strong> 보는 겁니다. 이 걸 식으로 표현하면 <code>F</code>에서 <code>F∘G∘F</code>로 갔다가 <code>F</code>로 돌아 올 수 있고, <code>G</code>에서 <code>G∘F∘G</code>로 갔다가 <code>G</code>로 돌아올 수 있냐를 보는 식으로 표현합니다. 그럼, 대상을 전혀 언급하지 않을 수 있습니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>F∘G∘F = F</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>G∘F∘G = G</span></code></pre></div>
<p>아무 작업 없이 위 식이 성립하면 isomorphic입니다. 딱 isomorphic은 아니지만, 특정 작업으로 관계를 isomorphic과 비슷하게 만들면, 특정 조건하에선 isomorphic<strong>처럼</strong> 볼 수 있습니다. 과연 위에 두 자연 변환 <code>ϵ'</code>,<code>η'</code>으로 가능한지 따라 가 보겠습니다.</p>
<h3 id="화살표가-반대-방향인-이유-일부-삭제-예정">화살표가 반대 방향인 이유 (일부 삭제 예정)</h3>
<p>별도로 정리한 글을 보시는 게, 좀 더 이해하기 편합니다. <a href="../posts/2023-12-05-adjunction_arrow_meaning.html">Adjunction에서 η와 ϵ의 화살표 방향이 반대인 이유</a></p>
<figure>
<img src="../images/adjunction_triangle.jpg" alt="F∘G∘F, G∘F∘G" />
<figcaption aria-hidden="true">F∘G∘F, G∘F∘G</figcaption>
</figure>
<p>카테고리 이론은 다이아그램 체이싱을 하며 대체(가환)commute 경로를 찾는 작업이 기본이라 합니다. 대수에서 <code>왼 쪽 = 오른 쪽</code> 식과 같은 의미입니다. 빨간색 화살표들이 서로 commute하도록 만드는 게 목표입니다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>나∘가 = id_F 자연 변환</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>라∘다 = id_G 자연 변환</span></code></pre></div>
<ul>
<li>(가)자연 변환에는 <code>F -&gt; F∘G∘F</code> 변환이 들어가야 하고,</li>
<li>(나)자연 변환에는 <code>F∘G∘F -&gt; F</code> 변환이 들어가야 하고.</li>
<li>(다)자연 변환에는 <code>G -&gt; G∘F∘G</code> 변환이 들어가야 하고,</li>
<li>(라)자연 변환에는 <code>G∘F∘G -&gt; G</code> 변환이 들어가야 합니다.</li>
</ul>
<p>위 식이 성립하게 만들기 위해, 현재 가지고 있는 유일한 변환 <code>ϵ'</code>, <code>η'</code>을 활용해 보겠습니다.<br />
<code>*</code>은 자연 변환 수평 합성, <code>1F</code>는 <code>F</code>에서, <code>1G</code>는 <code>G</code>에서 항등 자연 변환을 뜻합니다.</p>
<ul>
<li>(가)에는 <code>1F * (id_C -&gt; G∘F)</code> 자연 변환이 들어가야 하는데, 우리 손엔 반대 모양 <code>η': G∘F -&gt; id_C</code>만 있습니다. <strong>실패</strong></li>
<li>(나)에는 <code>(F∘G -&gt; id_D) * 1F</code> 자연 변환이 들어가야 하는데, 마침 <code>ϵ': F∘G -&gt; id_D</code>가 딱 이 모양입니다. <strong>성공</strong></li>
<li>(다)에는 <code>(id_C -&gt; G∘F) * 1G</code> 자연 변환이 들어가야 하는데, 마찬가지로 우리 손엔 없습니다. <strong>실패</strong></li>
<li>(라)에는 <code>1G * (F∘G -&gt; id_D)</code> 자연 변환이 들어가야 하는데, 마침 <code>ϵ': F∘G -&gt; id_D</code>가 딱 이 모양입니다. <strong>성공</strong></li>
</ul>
<p>※ 자연 변환 수평 합성Natural Transformation Horizontal Composition<br />
<code>F</code>에서 항등 자연 변환 <code>1_F</code>를 그냥 <code>F</code>로 표기한 곳도 있습니다. 혹시 제가 모르는 표기 방법이나 내용이 있나 했는데, 맥락에 따라 알아서 해석해야 된다고 합니다. (<span class="citation" data-cites="Ailrun님">@Ailrun님</span> 감사합니다) 자연 변환 합성은 당연히 자연 변환끼리 합성하는 것입니다. 자연 변환 수평 합성의 결과는 자연 변환입니다. 아래 그림의 결과 자연 변환 <code>F =&gt; F∘G∘F</code>를 펑터 <code>F</code>에 적용하면 <code>F∘G∘F</code>를 얻습니다. (수평합성은 마치 튜플자리에 맞는 것끼리만 자연 변환을 적용하는 느낌입니다. 이 무슨 인포멀한 말이냐 하면, 자연변환 <code>1F * η</code>을 <code>F∘id_C</code> 합성 펑터에 적용하면, <code>1F</code>는 <code>F</code>에, <code>η</code>는 <code>id_C</code>에 적용해서 최종 합성된 펑터 <code>F∘G∘F</code>를 얻습니다.)</p>
<figure>
<img src="../images/nt_hComposition.JPG" alt="자연 변환 수평 합성 Natural Transformation Horizontal Composition" />
<figcaption aria-hidden="true">자연 변환 수평 합성 Natural Transformation Horizontal Composition</figcaption>
</figure>
<p><code>왼 쪽 = 오른 쪽</code> 둘을 같게 만들 때, 꼭 한 쪽만 변형할 필요는 없습니다. 아래처럼 놓고 다시 한 번 체이싱을 해보겠습니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>ϵ''<span class="op">:</span> id_D <span class="ot">=&gt;</span> <span class="dt">F</span>∘<span class="dt">G</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>η''<span class="op">:</span> id_C <span class="ot">=&gt;</span> <span class="dt">G</span>∘<span class="dt">F</span></span></code></pre></div>
<ul>
<li>(가)에서 원하는 모양과 <code>η''</code>이 딱 맞고, <strong>성공</strong></li>
<li>(나)에서 원하는 모양과 <code>ϵ''</code>은 반대입니다. <strong>실패</strong></li>
<li>(다)에서 원하는 모양과 <code>η''</code>이 딱 맞고, <strong>성공</strong></li>
<li>(라)에서 원하는 모양과 <code>ϵ''</code>은 반대입니다. <strong>실패</strong></li>
</ul>
<p>결국 Adjunction 텍스트에 나오는 서로 반대 방향의 자연 변환 <code>ϵ'</code>과 <code>η''</code>을 다음처럼 준비하면 다이아그램 체이싱에 성공할 수 있습니다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>ϵ<span class="op">:</span> <span class="dt">F</span>∘<span class="dt">G</span> <span class="ot">=&gt;</span> id_D</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>η<span class="op">:</span> id_C <span class="ot">=&gt;</span> <span class="dt">G</span>∘<span class="dt">F</span></span></code></pre></div>
<p>위 그림을 보면 <code>F∘G∘F</code>에서 앞에 <code>F</code>와 뒤에 <code>F</code>의 색을 달리 했습니다. 제 눈엔 독특한 특징으로 보이는데 아직 속 뜻은 잘 못 찾고 있습니다. <code>F</code>와 같아지려면, 앞에 <code>F</code>가 살아남아도 되고(<code>G∘F</code>를 <code>id_C</code>로), 뒤에 <code>F</code>가 살아 남아도(<code>F∘G</code>를 <code>id_D</code>로) 되는 상황입니다. Adjunction이 가능한 이유가 여기에 있다고 상상하고 있습니다.</p>
<p><span class="citation" data-cites="todo">@todo</span> 혹은 <code>F∘G∘F</code>에서 앞에 <code>F</code>와 뒤에 <code>F</code>를 반드시 처음의 <code>F</code>, 마지막 <code>F</code>와 연관지을 필요 없다고 본다면, 색깔은 무의미합니다. 아직 고민 중입니다.</p>
<blockquote>
<p>이 번 글을 정리한 목적은 바로 이 특징 때문입니다. 속 뜻, 직관이 뭘까에 대한 <strong>상상</strong>입니다.<br />
아래 <span class="citation" data-cites="Ailrun님">@Ailrun님</span> 답을 힌트로, 생각 저글링을 해봤습니다.</p>
<p>독특한 특징1<br />
<code>F∘G</code>를, <code>G∘F</code>를 연관짓는 툴(<code>ϵ</code>,<code>η</code>)은 가지고 있지만, <code>F</code>, <code>G</code> 단독으로 연관 짓는 툴은 없습니다. 그런데, 마침 보고 있는 대상은 <code>F∘G∘F</code>와 <code>G∘F∘G</code>입니다. 우연일까요?</p>
<p>톡특한 특징2<br />
<code>F∘G = id_D</code>에 내포되어 있는 조건(정보)을 쪼개보면(분해)<br />
<strong>(1) F∘G -&gt; id_D</strong> 자연변환이 있다.<br />
<code>(2) id_D -&gt; F∘G</code> 자연변환이 있다.<br />
<code>(3)</code> 둘이 합치면 처음으로 돌아가는 매핑이다.</p>
<p><code>G∘F = id_C</code>도 마찬가지로<br />
<code>(4) G∘F -&gt; id_C</code> 자연변환이 있다.<br />
<strong>(5) id_C -&gt; G∘F</strong> 자연변환이 있다.<br />
<code>(6)</code> 둘이 합치면 처음으로 돌아가는 매핑이다.</p>
<p>그런데 여기 여섯 개 중 <code>(1)</code>,<code>(5)</code>만 뽑아 위 삼각형 다이아그램 체이싱이 가능합니다. 동형이라면, 갈 때 썼던 펑터의 역펑터로 왔을텐데, 마치 올 때는 다른 집 역평터를 빌려서 돌아오고 있습니다. 우연일까요?</p>
<p>id스런 동작을 못하는 F∘G 와 G∘F는 무슨 의미일까요?<br />
</p>
<p>여기 상상에 쓰인 아이디어는 <strong><em>우리가 하나라고 보고 있는 조건이 사실은, 여러 정보로 분해factorize할 수 있는 것일 수도 있다</em></strong>입니다.</p>
<p>(1)만 있고, (2)가 없다는 얘기는 (1) 동작을 하며 잃어버리거나 추가되는 정보가 있다는 얘기입니다. (4)도 마찬가지입니다. 두 번이나 정보 변형이 일어났는데, 처음과 같다고 보는 상황입니다.</p>
<p>Thu Nov 30 05:01:22 PM KST 2023 작성 중… <span class="citation" data-cites="todo">@todo</span></p>
<p>다른 글에서, 모든 값을 <code>id</code>가 적용된 Computation으로 보자는 생각을 얘기했었는데, Adjunction도 비슷한 느낌으로 본다면, <code>F</code> 펑터는 <code>id_D∘F∘id_C</code>로 볼 수 있고, <code>G</code>펑터는 <code>id_C∘G∘id_D</code>로 볼 수 있습니다.</p>
</blockquote>
<p>모나드에서는 <code>return</code>이 번뜩이는 센스라 생각했는데, Adjunction에선 화살표 반대가 그런 듯 합니다.</p>
<p>과연, 화살표 반대 방향은 위처럼 쫓아가다 나온 것인지, 아니면 내포된 속 뜻이 있어, 단 번에 서로 반대 방향의 자연 변환을 준비해야 되는 걸 알았는지 지금은 모르겠습니다. 속 뜻에 대한 질문에 <span class="citation" data-cites="Ailrun님으로부터">@Ailrun님으로부터</span> 아래 같은 답을 받았습니다.</p>
<blockquote>
<p><span class="citation" data-cites="Ailrun">@Ailrun</span>:<br />
<code>f∘g = id</code>, <code>g∘f = id</code>가 가능하면, <code>g</code>의 정의역domain과 치역codomain이 <strong>같은 수준의 정보를 가지고 있습니다</strong>.<br />
만약에 둘 다를 아래와 같이 정의하면</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>ϵ: F∘G =&gt; id_D</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>η: G∘F =&gt; id_C -- 원래 정의는 id_C =&gt; G∘F</span></code></pre></div>
<p><code>F∘G</code>나 <code>G∘F</code>가 <code>id</code>에 비해서 훨씬 “약한” 녀석이어도 (함수로 따지자면 <code>id_C</code>나 <code>id_D</code>라는 치역보다 훨씬 적은 정보만을 가지고 있어도) 얼마든지 두 자연 변환을 줄 수 있기에 <code>C</code>와 <code>D</code>의 강한 관계를 나타내는 대표자로서 <code>F</code>와 <code>G</code>를 쓰기 힘듭니다.<br />
마찬가지로 반대로만 정의하면</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>ϵ: id_D =&gt; F⋅G -- 원래 정의는 F∘G =&gt; id_D</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>η: id_C =&gt; G⋅F</span></code></pre></div>
<p><code>id_C</code>에는 포함되지 않는 아무 온갖 쓸데없는 추가 정보를 포함하고 있어도, 문제가 없기 때문에 또 제약이 너무 약하다고 할 수 있습니다.</p>
</blockquote>
<p>둘 중 하나 방향을 뒤집게 되면, 추가적인 제약이 들어있는 것과 같습니다. 위의 경우는 <code>id_C</code>, <code>id_D</code> 만큼의 정보(혹은 같은 양의 정보?)를 <code>F</code>와<code>G</code>의 합성도 가지고 있다는 얘기가 숨어 있다고 볼 수 있습니다.</p>
<p>결론은, 카테고리 <code>C</code>,<code>D</code>는 펑터<code>F</code>, <code>G</code>, 자연 변환<code>ϵ</code>, <code>η</code>가 있으면(Adjunction이 있으면) 같은 것처럼 볼 수 있을 정도로 같다(다르다)입니다.</p>
<p>※ <code>ϵ</code>은 <code>counit</code>이라 부르고, <code>η</code>는 <code>unit</code>이라 부릅니다.</p>
<h2 id="모나드와-연관성">모나드와 연관성</h2>
<p>정의만 읽어서 알 수 있는 공통점은, Adjunction, 모나드 둘 다 정보를 잃어버리면서도 같은 것이라 우기는 개념입니다. <code>ϵ</code> 과 <code>η</code>만 있다면, <code>F</code>와 <code>F∘G∘F</code>와 <code>F∘G∘F∘G∘F</code>,… 들을 모두 같은 척하고 볼 수 있습니다. 어딘가에서 모노이드와의 연관성이 나올 것으로 추측할 수 있습니다. (모나드는 <code>M</code>, <code>M∘M</code>, <code>M∘M∘M</code>,…들을 모두 같은 척하고 볼 수 있었습니다.)</p>
<p>참고. 프로그래머가 카테고리 이론 맛을 보려면, 바르토즈 밀레프스키 박사님을 피해갈 수 없습니다.<br />
<a href="https://bartoszmilewski.com/2016/04/18/adjunctions/">Adjunction - Bartoz Milewski</a><br />
위 링크를 보면, 하스켈 의사 코드로 표현하고 있는데,</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>η<span class="ot">_d ::</span> d <span class="ot">-&gt;</span> (<span class="dt">R</span> ∘ <span class="dt">L</span>) d</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>ϵ<span class="ot">_c ::</span> (<span class="dt">L</span> ∘ <span class="dt">R</span>) c <span class="ot">-&gt;</span> c</span></code></pre></div>
<p>를 자연 변환이 잘 보이게 아래처럼 보고 읽었습니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>η<span class="ot">_d ::</span> <span class="dt">Id_D</span> d <span class="ot">-&gt;</span> (<span class="dt">R</span> ∘ <span class="dt">L</span>) d <span class="co">-- Id_D -&gt; R∘L</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>ϵ<span class="ot">_c ::</span> (<span class="dt">L</span> ∘ <span class="dt">R</span>) c <span class="ot">-&gt;</span> <span class="dt">Id_C</span> c <span class="co">-- L∘R -&gt; Id_C</span></span></code></pre></div>
<p><code>R∘L</code>을 <code>m</code>으로, <code>L∘R</code>을 <code>w</code>(<code>m</code>을 뒤집은)로 놓으면,<br />
<code>unit</code>은 모나드의 <code>return : a -&gt; m a</code><br />
<code>counit</code>은 코모나드의 <code>extract : w a -&gt; a</code><br />
가 됩니다.</p>
<p>모든 adjoint 펑터 쌍은 모나드와 코모나드를 정의합니다. 모든 모나드와 코모나드는 adjoint 쌍으로 분해factorize할 수 있는데, 반드시 유니크한 하나의 쌍으로 나오지 않을 수 있습니다.</p>
<p>늘상 모나드를 쓰지만, Adjunction은 거의 쓰지 않는 이유가, adjoint 펑터 쌍으로 분해하면, Hask 카테고리를 벗어나는 무언가를 표현해야 할 때가 있어 안 쓰입니다. 하스켈에선 엔도펑터만 등장하는 Adjunction만 표현할 수 있습니다.</p>
<h3 id="예시">예시</h3>
<p>Adjunction으로 모나드를 표현할 수 있다는 말은, <code>F, G, unit, counit</code>을 적절히 섞어 <code>return</code>과 <code>join (혹은 bind)</code>를 만들 수 있다는 말입니다. 많이들 예시를 드는 <code>State</code>를 살펴 보겠습니다.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span>{<span class="ot">runState ::</span> s <span class="ot">-&gt;</span> (a, s)}</span></code></pre></div>
<p>adjoint 펑터 두개를 찾아야 하는데, 굉장한 이론을 갖다 대기 전에 직관을 보겠습니다. <code>State</code>모나드가 하는 일은,</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>(가)상태 s를 받아서</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>-- 결과값 a와 같이 끌고 다니기 위해</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>(나)a와 s를 2튜플로 만듭니다.</span></code></pre></div>
<p>이렇게 직관적으로 두 단계로 나눌 수 있습니다. 코드로 쓰면 (가)<code>s -&gt;</code>, (나) <code>(, s)</code>입니다. 더 변환이나 수정없이 바로 (가)가 Left adjoint <code>G</code>펑터고, (나)가 Right adjoint <code>F</code>펑터입니다. 웬일로 직관하고 조금도 빗나감 없이 딱 맞아 떨어집니다.</p>
<blockquote>
<p>상상<br />
모나드에서 모노이드의 이항연산을 두 단계로 쪼개 보던 거랑 연결됩니다. 모든 모나드가 아니라 <strong>하스켈의 모나드</strong>들은 (나)Right adjoint가 <code>한 카테고리에서 일어나는 펑터 합성</code>인 Adjunction들로만 보면 될 것 같습니다.</p>
</blockquote>
<p><code>State</code>가 한 번 적용되어 있는 <code>C</code>와 <code>State∘State</code>가 적용되어 있는 <code>D</code>로 놓고,<br />
<code>C: s-&gt;(a,s)</code>와 <code>D: s-&gt;(s-&gt;(a,s),s)</code> (<code>runState</code>와 람다는 생략)<br />
<code>G: a-&gt;(s-&gt;a)</code>, <code>F: a -&gt;(a,s)</code>, ※ 정보가 많은 쪽에서 적은 쪽으로 가는 걸 <code>G</code>로 둡니다<br />
이제 정의를 따라가 보겠습니다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>(s-&gt;d) &lt;----G-----   d</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  |                  |</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  V                  V</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  c    -----F----&gt; (c,s)</span></code></pre></div>
<p><code>c</code>를 <code>(s-&gt;d)</code>로 두면 <code>(s-&gt;d) -&gt; (s-&gt;d)</code><strong>=&gt;</strong><code>d -&gt; ((s-&gt;d), s)</code><br />
<code>unit</code>은 <code>id_C a    =&gt;    a -&gt; ((s-&gt;a), s)</code></p>
<p><code>d</code>를 <code>(c,s)</code>로 두면 <code>(s-&gt;(c,s)) -&gt; c</code><strong>=&gt;</strong><code>(c,s) -&gt; (c,s)</code><br />
<code>counit</code>은 <code>(s -&gt; (a,s)) -&gt; a    =&gt;     id_D a</code></p>
<p><code>return</code>은 그냥 <code>unit</code>입니다.</p>
<p><code>bind</code>는 (다)<code>m</code>과, <strong>m을 추가하는 함수</strong>를 받아, 적용한 뒤 (라)<code>counit</code>을 적용하면 됩니다.<br />
(다) 작업을 실행한 후에는 <code>s-&gt;(s-&gt;(a,s), s)</code> 모양이고, 여기에 (라)를 적용하면,</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>           s -&gt; (   s -&gt; (a,s)   , s   )</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>--                  ^^^^^^^^^^</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>-- counit은 이 것만 꺼내고 다른 건 다 지우는 자연 변환입니다.</span></code></pre></div>
<p><code>s -&gt; (a,s)</code>만 남습니다. <code>State</code>펑터가 적용된 것에, <code>State</code>펑터를 한 번 더 적용후 <code>counit</code>을 쓰면 <code>State</code>펑터를 한 번만 적용한 것으로 돌아올 수 있습니다.</p>
<p><code>unit = return</code>과 <code>counit</code>만 보이고, <code>join</code>은 안보였는데, “<strong>State펑터를 한 번 더 적용후</strong> counit”이 바로 <code>join</code>입니다.</p>
<p>참고 - 바르토즈 박사님이 질문올린 쓰레드입니다. <a href="https://stackoverflow.com/questions/4697320/monads-as-adjunctions">Monads as adjunction - stackoverflow</a></p>
<h2 id="adjunctions-과-hom-sets">Adjunctions 과 Hom-Sets</h2>
<ul>
<li>Q. 왜 hom-sets를 볼까? 그냥 지금 까지 보던 <code>a -&gt; b</code> 모피즘을 보면 안되는 걸까? 보통 <code>C</code>카테고리에 있는 두 대상 <code>a</code>, <code>b</code>사이의 <code>a -&gt; b</code> 사상이라 하면, 특정 사상 <strong>하나</strong>만을 뜻하는 것이 아니지 않나? <code>a -&gt; b</code>만 해도 폴리모픽하게 정의한 모양일텐데, 이 것과 hom-sets 차이는? 준동형 사상 집합이란 뜻일텐데, 모피즘이 항상 준동형 사상은 아니지 않나? <span class="citation" data-cites="todo">@todo</span><br />
※ Hom-Sets는 Homomorphism Sets로, 이름은 준동형 사상 집합이지만, 꼭 준동형 사상이 아니더라도 두 대상 사에에 존재하는 모든 모피즘을 지칭할 때 씁니다.?</li>
<li>Q. 위 정의와 마찬가지로, Adjunctions를 모르는 사람이, 처음 Adjunctions를 정의하면서는 화살표를 뒤집어야겠다는 생각을 왜 했을까? <span class="citation" data-cites="todo">@todo</span></li>
</ul>
<p>hom-sets의 자연 동형으로 Adjunctions을 정의할 수 있습니다. universal construction과 밀접하게 연결 됩니다. 여러 구성 절차construction로 <strong>분해factorize</strong>될 수 있는 고유한 사상이 있다는 말을 들으면, 어떤 집합과 hom-set간의 매핑이 있구나라고 생각하면 됩니다.?</p>
<p>자연 변환은 모피즘과 가환 다이어그램을 매핑합니다.</p>
<p>분명한 목적을 알려 주면 상상하는데 도움이 됩니다. 목표는 <code>C</code>와 <code>D</code>가 동형인가를 보기 위한 게 목표지만, 최종 목표 전에 중간 목표를 이렇게 잡을 수 있습니다. <code>C</code>에 있는 <code>L d -&gt; c</code> 모피즘과 <code>D</code>에 있는 <code>d -&gt; R c</code> 모피즘을 동형, 혹은 자연 동형으로 볼 수 있는가 입니다.</p>
<p><code>C</code>에서 <code>L d</code>와 임의의 <code>c</code>를 잡으면, 그 둘 사이에 모피즘이 반드시 하나만 있는 게 아닙니다. 하나도 없을 수도, 여러 개일 수도 있습니다. 이 걸 hom-set <code>C(L d, c)</code>로 표현합니다. 이 hom-set의 도착지인 <code>c</code>를 <code>R c</code>로 <code>D</code>의 대상 중 하나와 매핑하면 아래같은 가환 다이아그램이 나옵니다.</p>
<p><span class="citation" data-cites="todo">@todo</span> Hom-set으로 Adjucntion 정의하는 그림 추가</p>
<p><code>L, L d -&gt; c, R</code>로 가는 길과, <code>d -&gt; R c</code>로 가는 길이 commute함이 보입니다. 이렇게, <code>C(L d, c)</code>와 <code>D(d, R c)</code> 사이에 isomorphism이 있으면 <code>L</code>, <code>R</code>로 Adjunction을 만들 수 있습니다.</p>
<p>카테고리 <code>C</code>에서 카테고리 <code>Set</code>으로 가는 펑터 <code>(가)</code>, <code>(나)</code> 사이의 <strong>자연 변환</strong>과 (각 <code>c</code>마다, hom-set을 대상으로 갖고 있는 <code>Set</code> 카테고리의 hom-set 하나와 매핑한다고 볼 수 있으니, <code>C -&gt; Set</code> 평터입니다.)</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>c -&gt; C(L d, c) 펑터(가) -------- φ 자연변환 --------&gt; c -&gt; D(d, R c) 펑터(나)</span></code></pre></div>
<p>카테고리 <code>D</code>에서 카테고리 Set으로 가는 펑터 <code>(다)</code>, <code>(라)</code> 사이의 <strong>자연 변환</strong></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>d -&gt; C(L d, c) 펑터(다) -------- Ψ 자연변환 --------&gt; d -&gt; D(d, R c) 펑터(라)</span></code></pre></div>
<p><code>φ</code>와 <code>Ψ</code>가 서로의 역invertible이 된다고 합니다.</p>
<p><code>L</code>, <code>R</code> 두 펑터 조합이 <code>C</code>, <code>D</code>에 있는 모피즘(여기선 hom-set)에 대해서 <code>Id</code>스런 일을 할 수 있게, 두 모피즘의 차이를 자연 변환으로 나타내려는 게 목적입니다.</p>
<blockquote>
<p>Q. 자연 변환은 정의역과 치역이 같아야 하는데, <code>φ</code>와 <code>Ψ</code>는 도메인이 다르지 않나?<br />
A. 도착지 hom-set <code>C(L d, c)</code>, <code>D(d, R c)</code>는 카테고리 <code>Set</code>의 대상이라 보고, <code>C</code>카테고리의 대상<code>c</code>와 <code>Set</code>카테고리의의 대상을 매핑한 펑터 사이의 자연 변환은 결국 <code>Set</code>카테고리의 모피즘입니다. 마찬가지로 <code>d</code>와 <code>Set</code>을 매핑하는 펑터 사이의 모피즘도 <code>Set</code>카테고리의 모피즘입니다. 이 둘 모피즘 모두 <code>Set</code>에 있으니 합성할 수 있습니다. 합성한 것이 isomorphism이 되면, 돌고 돌아왔지만 <code>C</code>와 <code>D</code>를 isomorphic처럼 볼 수 있게 됩니다.</p>
</blockquote>
<blockquote>
<p><strong>카테고리</strong>가 같은가(얼마나 닮았나)를 보려면, 둘 사이를 오가는<br />
<strong>펑터 조합</strong>이 <code>Id_C</code>, <code>Id_D</code>와 같은 <strong>동형</strong>인지를 보고, 없다면,<br />
<strong>펑터 조합</strong>과 <code>Id_C</code>, <code>Id_D</code> 사이의 <strong>자연 동형</strong>인가 봅니다. 없다면,<br />
<strong>펑터 조합</strong>과 <code>Id_C</code>, <code>Id_D</code>들을 같게 만들 수 있는 <strong>자연 변환</strong>이 있는가 봅니다.<br />
지금 제 수준으로 보기엔, 카테고리 이론은 결국 자연 변환 놀음 같습니다.</p>
</blockquote>
<p>※ <code>c</code>가 모두 출력 쪽에 있을 땐 covariant 펑터라 하고, <code>d</code>는 모두 입력 쪽에 있으니 contravariant 펑터라 합니다. 여기서 급하게 알아야 될 건 아닐 겁니다. 참고 - <a href="../posts/2022-11-10-coContraVarint.html">Covariant, Contravariant, Positive, Negative</a></p>
<p>hom-set을 이용한 정의를 쫓아가면 <code>η: G∘F &lt;- Id_C</code>가 화살표가 당연하게 뒤집혀져 있어야 하는 게 보이긴 하나, 아직도 찜찜합니다. 처음, Adjunction 개념을 세운 학자는 왜 이런 생각을 했을까요? 첫 번째 방식의 정의를 쫓아가 보면, 화살표가 뒤집힌 것만 나오는 게 아닙니다. 여러가지 조합이 가능한데, 왜 하필 그 중 Adjunction 인 것에만 이름을 붙였을까요?</p>
<p>글이 길어져 별도의 글로 올렸습니다. <a href="../posts/2023-12-05-adjunction_arrow_meaning.html">Adjunction에서 η와 ϵ의 화살표 방향이 반대인 이유</a></p>
<h2 id="요약">요약</h2>
<p><code>C</code>, <code>D</code> 둘이 얼마나 같은데?</p>
<ul>
<li>둘이 완전히 같아.<br />
(완전히 같다는 정의하기 무척 어려운 거란 생각이 듭니다. 하지만, 전 티없이 맑은 정의를 원하는 것이 아니라, 현실 문제를 모델링할 때 문제 없을 정도의 정밀함만 있으면 됩니다.)</li>
<li>isomorphism으로 같아. (upto isomorphism)<br />
<code>C</code>, <code>D</code> 둘은 다르지만, isomorphism으로 같게isomorphic 볼 수 있는 것
※ “그 시스템에서 <code>F</code>는 upto isomorphism으로 유니크해” 이렇게 한글인 척 하는 영어 문장들을 가끔 만납니다. 시스템에 조금씩 다른 <code>F</code>, <code>F'</code>, <code>F''</code>,… 들이 존재하지만, 이들을 isomorphic하게 볼 수 있는 isomorphism이 있으면, 결국 이들은 다 같은isomorphic 걸로 보고, 하나만unique 있는 것처럼 볼 수 있다는 말입니다.</li>
<li>Natural isomorphism이 있는 관계야.<br />
<code>C</code>, <code>D</code> 둘은 다르고, isomorphism도 없지만, 둘 간의 펑터 <code>F</code>, <code>G</code> 합성을 <code>G∘F</code>는 <code>Id_C</code>펑터와, <code>F∘G</code>는 <code>Id_D</code>펑터와 같게 볼 수 있게 하는 Natural isomorphism이 있는 관계야</li>
<li><code>C</code>, <code>D</code> 둘은 다르고, isomorphism도 없고, Natural isomorphism인 펑터 합성도 없지만, 펑터 합성을 Natural isomorphism과 <strong>비슷하게(같게)</strong> 볼 방법(변환 방법)이 존재하는 Adjunction이 있는 관계야.</li>
</ul>
<p>둘이 얼마나 같은지, 얼마나 밀접한 관계인지를 표현할 수 있는 Adjunction이란 툴이 하나 더 생겼습니다.</p>
<p>※ 아래는 과연 현실에서 동형과 달리 <strong>자연 동형</strong>이 어떤 직관으로 나타날까 고민하다 나온 상상입니다. 아래는 <code>G∘F</code>만 보겠습니다.</p>
<figure>
<img src="../images/adjunction.jpg" alt="동형, 자연동형이 있는 관계, Adjunction 있는 관계" />
<figcaption aria-hidden="true">동형, 자연동형이 있는 관계, Adjunction 있는 관계</figcaption>
</figure>
<p>동형, 자연동형, Adjunction이 있는 관계는 그림에서 빨간 변형에 따라 구분이 되는 것으로 상상하고 있습니다. (동일한 일이 <code>F∘G</code>에도 일어납니다.)</p>
<ul>
<li>빨간 변형이 없다면 <strong>C와 D는 동형</strong></li>
<li>빨간 변형을 <strong><em>항상 정확히 알 수 있고, 되돌릴 수 있다면, C와 D사이에는 ID_C와 자연 동형인 펑터 G∘F 합성이 존재</em></strong>.<br />
자연 동형이라면 <code>Id_C</code>나 <code>Id_D</code>에서 역으로 <code>F∘G</code>나 <code>G∘F</code>를 찾을 수도 있어야 하니 얼마나 변형됐는지 정보를 잃어버리면 안됩니다.</li>
<li>빨간 변형을 버리거나 참조해서, <strong><em>어떻게든 수긍할만한 새로운 변형 생성을 허락</em></strong>한다면 <strong>C와 D는 Adjoint관계인 펑터F, G 합성이 존재</strong>하는, 혹은 Adjunction이 존재하는 관계.</li>
</ul>
<p>※ 변형이 일어났다는 말은, 곧 <code>F</code>가 <code>x1</code>이란 정보를 잃어버리면서 온다는 얘기로 보입니다.</p>
<p><code>ϵ</code>과 <code>η</code>는 <code>id</code>들과 일대일 대응이 아닙니다. 무언가 정보를 잃어버리면서 <code>Id</code>와 비슷한 일을 합니다. 모나드와 마찬가지로 쓸모 없는 정보를 잃어버리거나 합치면서 같은 모양이 가능한 것들이 있다면, Adjunction으로 모델링을 시도해 볼 수 있습니다.</p>
<p>아마도 이런 인포멀한 접근이, 전공 선수분들한테는 의미가 없을지도 모르겠습니다. 전 현실 문제를 보고, 펑터로 이리 저리 변환을 하는데, 어떤 경우가 보이면 Adjunction을 이용해 모델링해야겠다란 생각이 들 수 있도록 하는 게 목표입니다.</p>
<p>참고. 다음 글은 찾은 자료 중, 직관에 대한 설명이 가장 많이 등장하는, 제 입맛에 딱 맞는 글입니다. 예시를 벡터 스페이스로 들고 있어 그리 쉽지는 않지만, 딱딱한 정규 텍스트들보다는 좋았습니다.<br />
<a href="https://www.math3ma.com/blog/what-is-an-adjunction-part-1">What is an Adjunction? Part 1 (Motivation) - math3ma</a><br />
<a href="https://www.math3ma.com/blog/what-is-an-adjunction-part-2">What is an Adjunction? Part 2 (Definition) - math3ma</a></p>
<p>참고. 하스켈 코드로 Adjunction 보기<br />
<a href="https://www.stephendiehl.com/posts/adjunctions.html">From Adjunctions to Monads - Stephen Diehl</a><br />
<a href="https://chrispenner.ca/posts/adjunction-battleship">Adjunctions And Battleship</a></p>
<p>Mon Nov 27 03:45:47 PM KST 2023 작성 중</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
  </div>
  <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
  <div id="footer">
    © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
  </div>
  <script>
    tocbot.init({
      tocSelector: '.js-toc',
      contentSelector: '.js-toc-content',
      headingSelector: 'h2, h3',
      hasInnerContainers: true,
    });
  </script>
</body>

</html>
