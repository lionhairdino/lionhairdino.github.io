<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>lionhairdino - CPS 스타일 - Continuation Passing Style</title>

<meta name="description" content="프로그램의 다음 흐름이 어디로 갈지 명시적으로 지정하는 함수형과 어울리는 패턴입니다. 정의를 큰 어려움 없이 좇아가다 보면 callcc에서 멈칫하게 됩니다." />
<meta property="og:description" content="프로그램의 다음 흐름이 어디로 갈지 명시적으로 지정하는 함수형과 어울리는 패턴입니다. 정의를 큰 어려움 없이 좇아가다 보면 callcc에서 멈칫하게 됩니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="favicon.svg" />
        <link rel="icon" type="image/png" href="../Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="../Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="CPS 스타일 - Continuation Passing Style" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io" />

<meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

<meta name="keywords" content="cps, continuation passing style, cont monad, 모나드, callcc">
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../">lionhairdino</a> 
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
        </div>

        <div id="content">
            <h1>CPS 스타일 - Continuation Passing Style</h1>

            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on July 28, 2020
    
</div>

<p>아이디어는 “<em>함수가 결과를 리턴하지 않고, 바로 이어질 함수를 같이 넘겨서, 항상 작업이 끝나면 이어진 함수로 넘어가도록 만들자</em>” 입니다.</p>
<p>아래 설명에 <em>준비</em>란 말이 나오면, 언젠가 나중에 인자를 받으면 실행하게될 함수를 뜻합니다. 함수 뭉치를 바라 볼 때, 준비상태로 보면 한 결 이해가 편할 때가 있습니다.</p>
<p><a href="../posts/2020-07-03-freeMonad.html">Free 모나드</a>와 같이 보면 모나드 개념을 얻는데 도움이 됩니다.</p>
<h3 id="목차">목차</h3>
<ul>
<li><a href="#함수형에선-함수를-바꾸고-명령형에선-값을-바꾼다">함수형에선 함수를 바꾸고, 명령형에선 값을 바꾼다.</a></li>
<li><a href="#cont-모나드">Cont 모나드</a></li>
<li><a href="#그냥-함수-모나드와-뭐가-다를까">그냥 함수 모나드와 뭐가 다를까?</a></li>
<li><a href="#callcc">callCC</a></li>
<li><a href="#break">Break!</a></li>
</ul>
<h2 id="함수형에선-함수를-바꾸고-명령형에선-값을-바꾼다.">함수형에선 함수를 바꾸고, 명령형에선 값을 바꾼다.</h2>
<p>명령형 프로그램에서는 계산이 진행될 때마다 상태를 갱신해서 최종 결과를 만들어냅니다. 함수형에서는 상태가 없기 때문에 단계별 계산이 어떻게 표현 될까요? 상태를 따로 두는게 아니라, 함수가 함수를 감싸도록 해서 상태를 그 즉시 다른 함수에 입력으로 넣어주면(<em>함수를 합쳐 놓으면</em>) 상태를 저장하는 작업이 필요 없습니다.</p>
<p>함수란, 필요한 입력이 모두 주어지면 그 때 작업이 시작되어서 결과를 만들어내는 “할 일”을 뜻합니다. 함수<em>만</em> 있을 때는 아무런 일이 일어나지 않습니다. 함수에 <em>입력을 주는 순간</em> 일은 시작됩니다.</p>
<p>명령형에서는 값(상태)을 변화시켜 가며 작업이 진행되지만, 함수형에서는 할 일을 모두 합쳐 놓는 작업을 진행하고, 마지막에 값을 주어 작업을 시작합니다.</p>
<p>스포이드로 잉크 한 방울을 물에 딱 떨어뜨리면 확 퍼지듯이, 먼저 함수를 엮어 놓고 제일 바깥쪽 함수에 인자를 넣는 순간 함수 뭉치가 주욱 실행됩니다.</p>
<p>좀 더 구체적인 느낌이 오도록 예를 들면,</p>
<p>(1+), (2+), (3+) 작업이 있고, 여기에 0을 넣어서 최종 결과를 받는다면,</p>
<p>명령형에서는</p>
<p>결과를 저장할 변수 r을 만들고,</p>
<ol type="1">
<li>0을 받아서, 0 (1+) 을 실행해서 1을 r에 넣고,</li>
<li>r값을 꺼내서 다음 작업에 넣어주면 1 (2*) 를 실행해서 3을 r에 넣고,</li>
<li>r값을 꺼내서 다음 작업에 넣어주면 3 (3-) 을 실행해서 6을 돌려줍니다.</li>
</ol>
<p>r값을 계속 변화시켜 가며 작업을 진행합니다.</p>
<p>함수형에서는</p>
<ol type="1">
<li>(1+) 작업과 (2*) 작업을 합친 작업 (1+(2* _ ))를 만들고,</li>
<li>(1+(2* _ )) 작업과 (3-) 작업을 합친 작업 (1+(2*(3- _)))을 만들고,</li>
<li>이 작업에 0을 넣어서 6을 만들어 돌려줍니다.</li>
</ol>
<p>명령형에서는 값(상태)이 변하고, 함수형에서는 함수(할 일 목록)가 변합니다.</p>
<p>위 개념을 그대로 코드로 옮겨 보겠습니다.<br />
(1+), (2*), (3-) 작업을 엮어 아래 모양으로 만들어야 합니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>\r <span class="ot">-&gt;</span> <span class="dv">3</span><span class="op">-</span> (<span class="dv">2</span><span class="op">*</span> (<span class="dv">1</span><span class="op">+</span> r))</span></code></pre></div>
<p><em>주의 - 여기 예시는 단순 함수 컴포지션으로 해결이 되지만, 한 단계의 결과가 바로 다음의 결과에 영향을 주는게 아닐 경우 단순 컴포지션으로 해결할 수 없습니다.</em></p>
<p>좀 더 일반화해서, 이전 단계의 결과가 영향을 주든 안주든, 다음 작업이 이전 작업을 품는 모양을 만들기 위해, <em>이어지는 작업으로 뭘 할지 인자로 넘기도록</em> 할 수 있습니다. 작업이 끝난 후 결과를 리턴하는게 아니라, 결과를 이어지는 함수의 인자로 넘기는 모양이 됩니다. 이 걸 함수 외부에서 하는게 아니라, 함수 내부에서 항상 할 수 밖에 없게 만들면 다음과 같습니다.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>func1 x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> x</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>func2 x <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> x</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>func3 x <span class="ot">=</span> <span class="dv">3</span> <span class="op">-</span> x</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ot">func1_cps ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- func1_cps x nextfunc = nextfunc $ func1 x 를 람다 함수로 표기하면</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>func1_cps x <span class="ot">=</span> \nextfunc <span class="ot">-&gt;</span> nextfunc <span class="op">$</span> func1 x</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- x를 받아 작업을 하고, 결과를 바로 리턴하는게 아니라, </span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- 나중에 함수를 받아서 적용할 준비가 된 상태, 즉 함수를 반환합니다.</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="ot">func2_cps ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>func2_cps x <span class="ot">=</span> \nextfunc <span class="ot">-&gt;</span> nextfunc <span class="op">$</span> func2 x </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="ot">func3_cps ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r </span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>func3_cps x <span class="ot">=</span> \nextfunc <span class="ot">-&gt;</span> nextfunc <span class="op">$</span> func3 x </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>cps x <span class="ot">=</span> \k <span class="ot">-&gt;</span> func1_cps x (\x' <span class="ot">-&gt;</span> func2_cps x' (\x'' <span class="ot">-&gt;</span> func3_cps x'' k))</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> (cps <span class="dv">1</span>) <span class="fu">print</span> <span class="co">-- print는 \k 매개 변수를 통해 품고 품은 모양의 가장 안쪽으로 들어가는 걸 눈여겨 보세요.</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="dv">1</span></span></code></pre></div>
<p>마지막 cps 함수 모양을 보면 람다가 람다를 품는 식으로 엮여 있는데, 액션들이 많아지면 보기 편하진 않습니다. 그런데, 품는 모양이 익숙하지 않나요? 맞습니다. 모나드입니다. 하스켈에서 늘 그렇듯, <em>역시나 모나드 패턴</em>을 써서 동일한 기능을 단순하게 표기할 수 있습니다. 모나드로 cps를 다르게 구현하는게 아닌, 위 람다를 품은 람다를 보기 좋은 형태로 표기하는 역할만 합니다. Control.Monad.Trans.Cont 라이브러리에 <code>Cont</code> 모나드가 정의되어 있습니다.</p>
<p><code>Cont</code> 모나드는 <code>\k -&gt; func1_cps x (\x' -&gt; func2_cps x' (\x'' -&gt; func3_cps x'' k))</code> 모양의 코드를 좀 더 보기 좋게 만들어주는 모나드입니다.</p>
<p>※ 참고로 <code>(a -&gt; r) -&gt; r</code> 타입의 함수로 가장 많이 만나는 함수가 <code>($)</code> 커링 상태입니다. 값을 받아서 함수를 적용하는게 아니라, 값은 이미 갖고 있고, 함수를 받으면 이 값에 적용 후 결과를 돌려주는 함수입니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> (<span class="op">$</span> <span class="dv">3</span>) (<span class="op">+</span><span class="dv">2</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span></span></code></pre></div>
<p><code>($ 3)</code>은 함수를 받아서 <code>3</code>에다 적용 후 결과를 돌려줍니다.<br />
<code>Cont</code> 모나드의 <code>return</code>이 이 함수를 이용해 정의되어 있습니다.</p>
<h2 id="cont-모나드">Cont 모나드</h2>
<p><code>(a -&gt; r) -&gt; r</code> 타입을 체이닝(품고 품게)하기 위해 바인드를 정의하는데, GHC가 이 바인드를 고를 수 있도록 <code>(a -&gt; r) -&gt; r</code> 타입을 래핑해서 새로운 타입을 만들어야 합니다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="ot">=</span> <span class="dt">Cont</span> ((a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r)</span></code></pre></div>
<p>이 타입을 엮을 바인드를 정의합니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cont ::</span> ((a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">runCont ::</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Moand</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> x <span class="ot">=</span> cont (<span class="op">$</span> x)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  s <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> cont <span class="op">$</span> \c <span class="ot">-&gt;</span> runCont s</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>                 <span class="op">$</span> \x <span class="ot">-&gt;</span> runCont (f x) c</span></code></pre></div>
<p><code>Cont</code> 모나드를 이용하면, <code>do</code> 표기로 람다를 품은 람다를 숨길 수 있습니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>func1_cont x <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> func1 x <span class="co">-- 일반 함수를 CPS 스타일로 쓰기 위해 Cont로 래핑합니다.</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>func2_cont x <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> func2 x</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>func3_cont x <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> func3 x</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>cont x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> func1_cont x</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  z <span class="ot">&lt;-</span> func2_cont y</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  func3_cont z</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runCont (cont <span class="dv">1</span>) <span class="fu">print</span> <span class="co">-- 위와 마찬가지로 print는 품고 품은 모양의 가장 안쪽으로 들어갑니다.</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="dv">1</span></span></code></pre></div>
<p>모나드 정의를 풀어 보겠습니다. 바인드를 풀기 전에 <code>return</code>을 보면</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> x <span class="ot">=</span> cont (<span class="op">$</span> x)</span></code></pre></div>
<p>값을 먼저 넣어서 <code>Cont</code> 타입을 만들어 놓으면, 나중에 함수를 받아 값에 적용할 준비를 합니다.</p>
<p>그럼, 다음으로 바인드를 풀어 보겠습니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> cont (\c <span class="ot">-&gt;</span> runCont s (\x <span class="ot">-&gt;</span> runCont (f x) c))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 설명하기 좋게 함수, 변수명을 바꾸면</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>action <span class="op">&gt;&gt;=</span> nextf <span class="ot">=</span> cont (\lastFunc <span class="ot">-&gt;</span> runCont action (\actionResult <span class="ot">-&gt;</span> runCont (nextf actionResult) lastFunc))</span></code></pre></div>
<p>위에 나왔던 cps 예시 코드를 비교를 위해 두 개만 엮는 모양으로 다시 쓰면,</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>cps x <span class="ot">=</span> \k <span class="ot">-&gt;</span> func1_cps x (\x' <span class="ot">-&gt;</span> func2_cps x' k)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 설명하기 좋게 함수, 변수명을 바꾸면</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>cps x <span class="ot">=</span> \lastFunc <span class="ot">-&gt;</span> func1_cps x (\func1Result <span class="ot">-&gt;</span> func2_cps func1Result lastFunc)</span></code></pre></div>
<p>바인드 정의가 조금 감이 오지 않나요?</p>
<p><code>&gt;&gt;=</code>의 첫 번째 인자 <code>s</code>는 <code>Cont</code> 타입, 두 번째 인자 <code>f</code>는 <code>a -&gt; Cont r a</code> 타입.<br />
<code>Cont</code> 값을 <code>runCont</code>로 벗겨내면 “<em>나중에 함수를 받아서 적용할 값이 있는 상태</em>”가 됩니다.<br />
<code>runCont s</code>는 함수를 받을 상태가 되고, 여기에 <code>(\x -&gt; ...)</code> 함수를 넘기면 <em>s에 들어 있는 값</em>에 <code>(\x -&gt; ...)</code> 를 적용하게 됩니다.<br />
<code>f</code>를 <code>x</code>에 적용하면 다시 <code>Cont</code> 값이 나오고,<br />
이 걸 <code>runCont</code>로 다시 벗겨서 외부에서 들어 올 <em>함수를 적용할 준비</em>를 해놓습니다.<br />
구체적으로 무슨 일을 하는지 감이 잘 오는 해석은 아닙니다.</p>
<p>구체 값을 넣어 어떻게 진행하는지 다시 보겠습니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>func1_cont <span class="dv">1</span> <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> func2_cont a</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>cont (\c <span class="ot">-&gt;</span> runCont (func1_cont <span class="dv">1</span>) (\x <span class="ot">-&gt;</span> runCont ((\a <span class="ot">-&gt;</span> func2_cont a) x) c))</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- runCont (func1_cont 1) 의 결과 2를 준비한 상태에 (\x ...) 를 넘기면 ------(A)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>cont (\c <span class="ot">-&gt;</span> runCont ((\a <span class="ot">-&gt;</span> func2_cont a) <span class="dv">2</span>) c)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- ((\a -&gt; func2_cont a) 2) 를 풀면 </span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- (func2_cont 2) 의 결과는 4 ------(B)</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>cont (\c <span class="ot">-&gt;</span> runCont (cont (<span class="op">$</span> <span class="dv">4</span>)) c)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>cont (\c <span class="ot">-&gt;</span> (<span class="op">$</span> <span class="dv">4</span>) c)</span></code></pre></div>
<p><code>c</code>로 함수를 받아 <code>4</code>에 적용할 준비를 마친 상태가 되었습니다. 중간 과정에 보면 (A)에서 첫 번째 액션, (B)에서 두 번째 액션이 이어서 준비되는게 보입니다. <a href="../posts/2020-07-03-freeMonad.html">Free 모나드 포스트</a>를 보신분은 비슷한 모양이 여기서도 보일겁니다.</p>
<h2 id="그냥-함수-모나드와-뭐가-다를까">그냥 함수 모나드와 뭐가 다를까?</h2>
<p>함수 모나드</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>comp <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> (\f <span class="ot">-&gt;</span> f <span class="dv">1</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> (\f <span class="ot">-&gt;</span> f <span class="dv">2</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> a <span class="op">+</span> b</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> comp (<span class="op">+</span><span class="dv">2</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="dv">7</span></span></code></pre></div>
<p>Cont 모나드</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">conts ::</span> <span class="dt">Cont</span> r <span class="dt">Integer</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>conts <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> cont (\f <span class="ot">-&gt;</span> f <span class="dv">1</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> cont (\f <span class="ot">-&gt;</span> f <span class="dv">2</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> a <span class="op">+</span> b</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runCont conts (<span class="op">+</span><span class="dv">2</span>)</span></code></pre></div>
<p>결과값으로 뭐가 나올까요?<br />
<code>1 + 2</code>, <code>2 + 2</code> 를 더해 <code>7</code>이 나올까요? 아닙니다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">&lt;-</span> cont (\f <span class="ot">-&gt;</span> f <span class="dv">1</span>) <span class="co">-- a는 1</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">&lt;-</span> cont (\f <span class="ot">-&gt;</span> f <span class="dv">2</span>) <span class="co">-- b는 2</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> <span class="op">$</span> a <span class="op">+</span> b <span class="co">-- ($ 3)으로 외부에서 함수를 받아 3에 적용합니다.</span></span></code></pre></div>
<p><code>runCont</code>로 <code>(+2)</code>를 넣어주면 <code>($ 3) (+2) = 5</code> 가 됩니다.</p>
<p>예를 들어 <code>f x = x + 1</code>을 cps 액션으로 만들면, <code>f x = return $ x + 1</code><br />
이 액션은 <code>x + 1</code> 이라는 작업을 하고 결과를 나중에 받는 함수에 넘길 준비를 합니다.<br />
위 예시는 따로 작업은 없고, 상수 <code>1</code>, 상수 <code>2</code>를 가지고 있을 뿐입니다. 그래서 <code>a</code>에는 <code>1</code>, <code>b</code>에는 <code>2</code>가 들어갑니다.</p>
<p><em>runCont로 넣어준 함수는 모든 액션들에 적용되는게 아니라, 마지막에 실행되는 함수입니다.</em></p>
<p><code>Cont</code> 모나드 액션은 함수(다음에 할 작업)를 받아 적용할 인자들을 준비하는 것과 같습니다. <code>Cont</code> 모나드의 바인드는 이들 액션을 품고 품은 모양으로 만드는 역할을 합니다. 실제 바인드가 동작하는 모습을 보면 순서대로 작업이 실행되는게 보입니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>c <span class="ot">-&gt;</span> cont (\f <span class="ot">-&gt;</span> f <span class="dv">1</span>) <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> cont (\f <span class="ot">-&gt;</span> f <span class="dv">2</span>) <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span> cont (<span class="op">$</span> (a <span class="op">+</span> b)) c</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 보기 쉽게 Cont 안에 들어 있는 준비된 인자만 보이게 (..1..), (..2..), (..a+b..)로 바꿔보겠습니다. </span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>cont <span class="op">$</span> \c <span class="ot">-&gt;</span> runCont ( cont (<span class="op">..</span><span class="dv">1</span><span class="op">..</span>))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>     <span class="op">$</span> \x <span class="ot">-&gt;</span> runCont ( (\a <span class="ot">-&gt;</span> cont (<span class="op">..</span><span class="dv">2</span><span class="op">..</span>) <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span> cont (<span class="op">..</span>a<span class="op">+</span>b<span class="op">..</span>)) x) c</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>\c <span class="ot">-&gt;</span> (<span class="op">..</span><span class="dv">1</span><span class="op">..</span>) <span class="op">$</span> (\x <span class="op">...</span>) <span class="co">-- cont의 바인드는 액션속에 있는 준비된 인자를 다음 액션에 넣어주는 역할을 합니다.</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>\c <span class="ot">-&gt;</span> (\x <span class="op">...</span>) <span class="dv">1</span> <span class="co">-- 첫 번째 액션이 가지고 있던 인자 1이 x로 들어갑니다.</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>\c <span class="ot">-&gt;</span> runCont ( (\a <span class="ot">-&gt;</span> cont (<span class="op">..</span><span class="dv">2</span><span class="op">..</span>) <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span> cont (<span class="op">..</span>a<span class="op">+</span>b<span class="op">..</span>)) <span class="dv">1</span> ) c <span class="co">-- a에 넘어온 1이 들어갑니다.</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>\c <span class="ot">-&gt;</span> runCont ( cont (<span class="op">..</span><span class="dv">2</span><span class="op">..</span>) <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span> cont (<span class="op">..</span><span class="dv">1</span><span class="op">+</span>b<span class="op">..</span>) )  c </span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>\c <span class="ot">-&gt;</span> runCont ( cont <span class="op">$</span> \c2 <span class="ot">-&gt;</span> runCont (cont (<span class="op">..</span><span class="dv">2</span><span class="op">..</span>)) <span class="op">$</span> x2 <span class="ot">-&gt;</span> runCont ((\b <span class="ot">-&gt;</span> cont (<span class="op">..</span><span class="dv">1</span><span class="op">+</span>b<span class="op">..</span>)) x2) c2 ) c </span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>\c <span class="ot">-&gt;</span> runCont ( cont <span class="op">$</span> \c2 <span class="ot">-&gt;</span>      (<span class="op">..</span><span class="dv">2</span><span class="op">..</span>) <span class="op">$</span> x2 <span class="ot">-&gt;</span> runCont ((\b <span class="ot">-&gt;</span> cont (<span class="op">..</span><span class="dv">1</span><span class="op">+</span>b<span class="op">..</span>)) x2)     c2 ) c </span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>\c <span class="ot">-&gt;</span> runCont ( cont <span class="op">$</span> \c2 <span class="ot">-&gt;</span>      runCont ((\b <span class="ot">-&gt;</span> cont (<span class="op">..</span><span class="dv">1</span><span class="op">+</span>b<span class="op">..</span>)) <span class="dv">2</span>)     c2 ) c</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- 두 번째 액션이 가지고 있던 인자 2가 x2로 들어갑니다.</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>\c <span class="ot">-&gt;</span> runCont ( cont <span class="op">$</span> \c2 <span class="ot">-&gt;</span> runCont (cont (<span class="op">..</span><span class="dv">1</span><span class="op">+</span><span class="dv">2</span><span class="op">..</span>)) c2 ) c <span class="co">-- b에 2가 들어갑니다.</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>\c <span class="ot">-&gt;</span> runCont ( cont <span class="op">$</span> \c2 <span class="ot">-&gt;</span> c2 (<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>) ) c </span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>\c <span class="ot">-&gt;</span> <span class="op">$</span> c (<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>) <span class="co">--c2에 c가 들어갑니다.</span></span></code></pre></div>
<p><code>Cont</code> 모나드를 이런식으로 쓰진 않습니다. 이해를 돕기 위해 만든 조금은 억지스러운 예시입니다.</p>
<h2 id="callcc">callCC</h2>
<p><code>Cont</code> 모나드를 익힐 때 <code>callCC</code>가 걸림돌이었습니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">callCC ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m b) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>callCC f <span class="ot">=</span> <span class="dt">ContT</span> <span class="op">$</span> \c <span class="ot">-&gt;</span> runContT (f (\x <span class="ot">-&gt;</span> <span class="dt">ContT</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> c x)) c</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- 실제 라이브러리에는 위와 같이 ContT 트랜스포머로 구현되어 있습니다.</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- 여기서는 트랜스포머를 빼고, 아래 Cont를 이용한 정의를 쓰겠습니다.</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="ot">callCC ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>callCC f <span class="ot">=</span> cont <span class="op">$</span> \h <span class="ot">-&gt;</span> runCont (f (\a <span class="ot">-&gt;</span> cont <span class="op">$</span> \_ <span class="ot">-&gt;</span> h a)) h</span></code></pre></div>
<p><code>Cont</code> 체인에 놓여 있는 액션은 순서대로 실행됩니다. 그런데 <code>callCC</code>로 감싸면 실행 흐름이 달라집니다. <em>callCC가 상황에 따라 continuation을 끊습니다.</em> 어떻게 그럴까요?</p>
<p><code>callCC</code>가 받는 인자 <code>f</code>의 타입은</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a </span></code></pre></div>
<p><code>Cont</code> 값을 만드는 함수를 받아서 <code>Cont</code> 값을 돌려 줍니다. <code>(a -&gt; Cont r b)</code> 함수에 <code>a</code>만 넣어줘도 <code>Cont</code> 값이 나오는데, 왜 한 번 더 감쌌을까요? 보통 <code>a</code>와 <code>a -&gt; b</code> 함수를 같이 받아 필터를 거친 후 함수를 적용하곤 하는데, <code>f</code>는 <code>a</code>를 받지 않습니다. 함수만 받으면 <code>Cont</code> 값이 나오므로, “<code>f</code>안에 <code>a</code>가 있다”고 짐작할 수 있습니다. <code>callCC</code>는 <em>함수만 받으면 Cont 값을 만들 준비가 되어 있는 함수</em>를 인자로 받습니다. 아래 예시의 <code>(\k ..)</code> 함수들입니다. k로 <code>a -&gt; Cont r b</code> 함수를 받을겁니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runCont ( callCC <span class="op">$</span> \k <span class="ot">-&gt;</span> cont (\f <span class="ot">-&gt;</span> f <span class="st">&quot;ok&quot;</span>) ) <span class="fu">id</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;ok&quot;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runCont ( callCC <span class="op">$</span> \k <span class="ot">-&gt;</span> k <span class="st">&quot;ok&quot;</span>) <span class="fu">id</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;ok&quot;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runCont ( callCC <span class="op">$</span> \k <span class="ot">-&gt;</span> <span class="kw">do</span> k <span class="st">&quot;first&quot;</span>; <span class="fu">return</span> <span class="st">&quot;second&quot;</span> ) (<span class="op">++</span> <span class="st">&quot; end&quot;</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;first end&quot;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runCont ( callCC <span class="op">$</span> \k <span class="ot">-&gt;</span> <span class="kw">do</span> <span class="fu">return</span> <span class="st">&quot;first&quot;</span>; <span class="fu">return</span> <span class="st">&quot;second&quot;</span> ) (<span class="op">++</span> <span class="st">&quot; end&quot;</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;second end&quot;</span></span></code></pre></div>
<p><code>first end</code> 결과가 나온 코드를 보면, <code>return "second"</code>는 실행되지 않습니다. <em>아이디어는 continuation을 받아서 버리는 겁니다.</em> 아마도 <code>callCC</code> 중에 <code>\_ -&gt; ...</code> 모양의 코드가 있을 거라 짐작할 수 있습니다. <code>callCC</code>를 풀어 보겠습니다. <code>callCC</code> 정의에 <code>(\k ..)</code> 함수를 넣으면</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>cont <span class="op">$</span> \h <span class="ot">-&gt;</span> runCont ((\k <span class="ot">-&gt;</span> <span class="kw">do</span> k <span class="st">&quot;first&quot;</span>; <span class="fu">return</span> <span class="st">&quot;second&quot;</span>) (\a <span class="ot">-&gt;</span> cont <span class="op">$</span> \_ <span class="ot">-&gt;</span> h a)) h</span></code></pre></div>
<p><em>k에 <code>(\a -&gt; cont $ \_ -&gt; h a) :: a -&gt; Cont r b</code> 를 넣으면</em></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>cont <span class="op">$</span> \h <span class="ot">-&gt;</span> runCont (<span class="kw">do</span> (\a <span class="ot">-&gt;</span> cont <span class="op">$</span> \_ <span class="ot">-&gt;</span> h a) <span class="st">&quot;first&quot;</span>; <span class="fu">return</span> <span class="st">&quot;second&quot;</span>) h</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>cont <span class="op">$</span> \h <span class="ot">-&gt;</span> runCont (<span class="kw">do</span> cont <span class="op">$</span> \_ <span class="ot">-&gt;</span> h <span class="st">&quot;first&quot;</span>; <span class="fu">return</span> <span class="st">&quot;second&quot;</span>) h</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                         <span class="op">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span></code></pre></div>
<p>밑 줄 표시한 부분의 바인드를 풀어 보겠습니다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">--바인드 정의</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>s <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> cont <span class="op">$</span> \c <span class="ot">-&gt;</span> runCont s <span class="op">$</span> \x <span class="ot">-&gt;</span> runCont (f x) c</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- do가 가린 바인드를 드러내면</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>cont <span class="op">$</span> \_ <span class="ot">-&gt;</span> h <span class="st">&quot;first&quot;</span> <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="st">&quot;second&quot;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> cont <span class="op">$</span> \c <span class="ot">-&gt;</span> runCont (cont <span class="op">$</span> \_ <span class="ot">-&gt;</span> h <span class="st">&quot;first&quot;</span>) <span class="op">$</span> \x <span class="ot">-&gt;</span> runCont ((\_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="st">&quot;second&quot;</span>) x) c</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>                                                  <span class="op">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>                                                  <span class="co">-- 이 부분이 \_ 로 들어가므로 모두 버려집니다.</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> cont <span class="op">$</span> \c <span class="ot">-&gt;</span> h <span class="st">&quot;first&quot;</span></span></code></pre></div>
<p>코드를 모두 합쳐 보면</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runCont (cont <span class="op">$</span> \h <span class="ot">-&gt;</span> runCont ( cont <span class="op">$</span> \c <span class="ot">-&gt;</span> h <span class="st">&quot;first&quot;</span> ) h) (<span class="op">++</span> <span class="st">&quot; end&quot;</span>)</span></code></pre></div>
<p>정리하면, <code>callCC</code>는 “continuation을 만드는 함수를 받아서 continuation을 만들어내는 작업”을 인자로 받습니다. <code>callCC</code> 정의를 보면</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>callCC f <span class="ot">=</span> cont <span class="op">$</span> \h <span class="ot">-&gt;</span> runCont (f (\a <span class="ot">-&gt;</span> cont <span class="op">$</span> \_ <span class="ot">-&gt;</span> h a)) h</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>                                   <span class="op">^^^^^^^^^^^^^^^^^^^^^^^^</span></span></code></pre></div>
<p><code>f</code>는 continuation을 만드는 함수를 받는데, 여기에 continuation을 버리는 모양을 만드는 함수를 넘깁니다. <code>a</code>값을 받으면 <code>cont $ \_ -&gt; h a</code> 을 만듭니다. 보통 다른 continuation 들은 <code>cont $ \h -&gt; h a</code> 모양으로 인자로 받은 함수를 내부에 적용하면서 continuation을 이어가는데, 여기선 <code>\_</code> 로 받아서 버립니다.</p>
<p>원래 작업은 <code>\k -&gt; do k "first"; return "second"</code> 인데, 여기 <code>k</code>에 <code>(\a -&gt; cont $ \_ -&gt;h a)</code>를 넣어 작업을 변형합니다. <code>k</code>가 실행되면 continuation을 끊게 되고, <code>k</code>가 실행되지 않으면 <code>return "second"</code>가 실행됩니다.</p>
<h2 id="break">Break!</h2>
<p><code>callCC</code>가 조건에 따라 continuation을 끊는break 코드입니다.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Cont</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Cont.Class</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>func1 x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>func2 x <span class="ot">=</span> x <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="ot">func1_cont ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> r <span class="dt">Int</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>func1_cont x <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> func1 x</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="ot">func2_cont ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> r <span class="dt">Int</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>func2_cont x <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> func2 x</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="ot">contFuncs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>contFuncs <span class="fu">init</span> <span class="ot">=</span> runCont </span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>  ( <span class="kw">do</span> </span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">&lt;-</span> func1_cont <span class="fu">init</span>; </span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    func2_cont b</span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>  ) <span class="fu">print</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a><span class="ot">callccFuncs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> r <span class="dt">Int</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>callccFuncs <span class="fu">init</span> <span class="ot">=</span> runCont </span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>  ( </span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>    callCC <span class="op">$</span> \k <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>      when (<span class="fu">init</span> <span class="op">==</span> <span class="dv">1</span>) <span class="op">$</span> k <span class="op">$</span> func1_cont <span class="fu">init</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> <span class="op">$</span> func2_cont <span class="fu">init</span></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>  ) <span class="fu">id</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>  contFuncs <span class="dv">1</span> <span class="co">-- 1 + 1 - 1 = 1</span></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> r1 <span class="ot">=</span> runCont (callccFuncs <span class="dv">1</span>) <span class="fu">id</span></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> r1 <span class="co">-- 1 + 1 = 2</span></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> r2 <span class="ot">=</span> runCont (callccFuncs <span class="dv">2</span>) <span class="fu">id</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> r2 <span class="co">-- 2 - 1 = 1</span></span></code></pre></div>
<p>전체 작업을 <code>callCC</code>로 감싸 놓으면 아래 코드 모양을 만들 수 있습니다. 연결, 연결 되서 실행되는 체인인데, 특정 조건과 맞으면 실행이 끝나는 코드입니다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>callCC <span class="op">$</span> \breakfunc <span class="ot">-&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  a조건과 맞으면 breakfunc</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  b조거과 맞으면 breakfunc</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<hr />
<p>참고<br />
<a href="https://cms2.ks.ac.kr/riet/contents/20190304/%ED%95%A8%EC%88%98%ED%98%95%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98%20Continuation%EC%9D%84%20%EC%9D%B4%EC%9A%A9%ED%95%9C%20%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4.pdf">변석우님 - 함수형 프로그래밍의 Continuation을 이용한 흐름제어</a><br />
<a href="https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style" class="uri">https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style</a><br />
<a href="http://guruma.github.io/posts/2018-11-18-Continuation-Concept/" class="uri">http://guruma.github.io/posts/2018-11-18-Continuation-Concept/</a></p>

<div id="disqus_thread" style="padding-top:40px"></div>
<script>

var disqus_config = function () {
this.page.url = 'https://lionhairdino.github.io/posts/2020-07-28-ContinuationPassingStyle.html';
this.page.identifier = 'posts/2020-07-28-ContinuationPassingStyle.markdown';
};
(function() {
var d = document, s = d.createElement('script');
s.src = 'https://lionhairdino.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
        </div>
        <div id="footer">
            © 2021 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
