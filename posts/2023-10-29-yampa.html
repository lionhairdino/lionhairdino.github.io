<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - 얌파 Yampa (작성 예정)</title>

        <meta name="description" content="lionhairdino - 얌파 Yampa (작성 예정)" />
        <meta property="og:description" content="하스켈 함수형 프로그래밍" />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="얌파 Yampa (작성 예정)" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-10-29-yampa.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

      <meta name="keywords" content="FRP, Functional Reactive, haskell, 하스켈, 함수형, Functional">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
<meta name="fediverse:creator" content="@lionhairdino@mastodon.social">
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:20px;border:none" src="../images/bluesky.svg"></a></div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>얌파 Yampa (작성 예정)</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on October 29, 2023
    
</div>

<p>Tue Nov 14 08:08:18 PM KST 2023 스케치 중…</p>
<p><a href="https://github.com/ivanperez-keera/Yampa">ivanperez-keera / Yampa</a><br />
<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.8016&amp;rep=rep1&amp;type=pdf&amp;rct=j&amp;q=yampa%20arcade&amp;ei=p2b6TPv4HMOBlAe0luW4DA&amp;usg=AFQjCNEIW_IZQ9qAg-Jc8RbGfx9981RJBw&amp;sig2=k1V5vp6kH16B3U0-wNV00w">The Yampa Arcade</a><br />
<a href="https://github.com/ivanperez-keera/SpaceInvaders">ivanperez-keera / SpaceInvaders</a><br />
<a href="https://yampa-book.readthedocs.io/en/latest/index.html">Yampa Book</a></p>
<p>Arrowized FRP</p>
<p>Arrow 인터페이스를 이용해서 FRP 프레임워크 구현</p>
<h2 id="signal-sf-signal-function">Signal, SF (Signal Function)</h2>
<p>얌파는 두 가지 핵심 개념을 기반으로 만들었다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 시그널 </span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Signal</span> α ≃ <span class="dt">Time</span> <span class="ot">-&gt;</span> α</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- 시그널 함수 </span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="dt">SF</span> α β ≃ <span class="dt">Signal</span> α <span class="ot">-&gt;</span> <span class="dt">Signal</span> β</span></code></pre></div>
<p>Reactive-Banana에서는 Conal Elliot 논문과 같은 Behavior (<code>t -&gt; a</code>)와 Event (<code>(t,a)</code>)에서 시작했다. <del>얌파는 “특정 시간에만 존재하는 Event” 즉, <code>(Time, Event)</code> 모양이 없다. Behavior와 Event를 최대한 비슷하게 표현(모델링)한다면,</del></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Behavior</span> <span class="ot">=</span> [b, b, b, b, b, <span class="op">...</span>] <span class="co">-- [ Just b,  Just b, Just b,  Just b, ...]</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Event</span>    <span class="ot">=</span> [_, _, e, _, e, <span class="op">...</span>] <span class="co">-- [Nothing, Nothing, Just e, Nothing, ...]</span></span></code></pre></div>
<p>이런 모양으로 표현할 수도 있다. 아마도 얌파에선 이런 방식으로, <code>Signal</code> 하나로 둘 모두를 표현하지 않았을까?<br />
( ※ 연속 시간을 음이 아닌 실수로 표현한다. )<br />
<code>SF</code> 해석을 어떻게 하면 좋을까? <code>Signal α</code>란 걸 주면 <code>Signal β</code>로 바꿔놓는 함수다.
<code>Time</code>을 주면 <code>α</code>를 내어 줄 준비를 하고 있었는데, 이를 변환 <code>β</code>를 내어주게 변환한다. 어떻게 변환할지는 이를 받아가는 모피즘, 즉 런타임의 동작을 봐야 한다.</p>
<p><code>(Signal α, Signal β)</code></p>
<p>위와 같이 쓴다면, <code>(,)</code>는 이를 만나는 모피즘들이 모두 별 일을 하지 않는다. 그저 단순히 두 개의 정보를 “함께” 가지고 있다는 뜻이다. <code>SF</code>는 <code>(,)</code>자리에 <code>(-&gt;)</code>를 넣어 정의했다. <code>(-&gt;) (Signal α) (Signal β)</code>, 나중 <code>SF</code>와 만나는 Runner들이 이 걸 실행하든, 다른 것과 합성하든 할 것이다. 뭘 할지는 그들에게 달렸다.<br />
프로그램 플로우 차트로 비유하자면, 마치 라인이 <code>Signal</code>이고, 박스 요소들이 <code>SF</code>로 볼 수 있다고 한다. <code>SF</code>는 어찌 됐든 함수를 래핑해 놨으니, <code>SF</code>만을 위한 컴비네이터들을 만들어 쓸 거라고 예측할 수 있다.</p>
<h2 id="arr">arr</h2>
<p><code>SF</code>는 <code>(t -&gt; a) -&gt; (t -&gt; b)</code>타입의 함수를 래핑한 타입이다. <code>(a -&gt; b)</code> 함수를 <code>SF</code>로 만들어 보자. 서명 모양이 딱 <a href="../posts/2023-10-29-yampa.html">요네다 임베딩</a>이다.
&gt; <code>Nat(Hom(-,a), Hom(-,b)) ~= (Hom(-,b)) a</code><br />
&gt; 모피즘 모양으로 다시 쓰면 <code>(x -&gt; a) -&gt; (x -&gt; b) ~= a -&gt; b</code></p>
<p><code>f :: a -&gt; b</code> 함수를 받아서, 어떻게 <code>SF{ (s :: t -&gt; a) -&gt; (h :: t -&gt; b) }</code> 로 바꿀까? 요네다를 안다면 둘은 같은 정보를 가지고 있다는 건 바로 보이긴 하는데, 실제 구현은 어떻게 될까?</p>
<blockquote>
<p>함수를 변환하는 연습을 해보자.</p>
<ol type="1">
<li>일단 <code>a</code>를 결정하려면 <code>s</code>에 <code>t</code>를 넣어줘야 한다.<br />
<code>a = s t</code></li>
<li><code>a</code>를 결정했으니, <code>f</code>를 적용할 수 있다.<br />
<code>b = f (s t)</code></li>
<li><code>b</code>가 나왔다. 최종 결과는 <code>t</code>를 받아서 <code>b</code>를 돌려주는 함수다.<br />
<code>\t -&gt; f (s t)</code></li>
<li>이제 마지막으로 <code>s</code>를 받도록 만들면 된다.<br />
<code>\s -&gt; \t -&gt; f (s t)</code></li>
</ol>
</blockquote>
<p>※ <a href>The Yampa Arcade - 3.2 Composing Signal Functions</a> 참고</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">arr ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">SF</span> a b</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>arr f <span class="ot">=</span> \s <span class="ot">-&gt;</span> \t <span class="ot">-&gt;</span> f (s t)</span></code></pre></div>
<p>이제 일반 함수를 <code>arr</code>을 써서 <code>SF</code>세상으로 리프팅할 수 있다. 요네다하고도 맞아 떨어지고, <code>a -&gt; b</code>라는 함수의 의미 - <code>a</code>가 먼저 일어나면, 그 것에 의존해서 <code>b</code>가 일어난다는 직관하고도 맞아 떨어진다. 요네다 식 자체가 가지고 있는 뜻이, 원래부터 이 의미로 보인다. 마치 시간의 개념이 없던 수학식에 시간 개념을 불어 넣는 느낌이다. 이제 막 요네다를 공부해서 어설프게 다 적용하고 있는지도 모르겠다. 직관적으로 해석하면, 시간에 따라 <code>a</code>가 일어나는 함수를 받아서 <code>b</code>가 일어나는 함수로 바꿔 놓았다.</p>
<p>※ <a href="../posts/2021-05-07-callbackTraining.html">함수가 들어있는 데이터 타입의 펑크터 만들기</a> 참고</p>
<hr />
<p><a href="https://reasonablypolymorphic.com/blog/yampa-frp/index.html">FRP in Yampa: Part1 - Reasonably Polymorphic</a></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">controller ::</span> <span class="dt">SF</span> () <span class="dt">Controller</span></span></code></pre></div>
<p>첫번 째 인자 <code>()</code>는, 컨트롤러 값을 얻기 위해서 아무 것도 넣어 줄 필요가 없다는 뜻.</p>
<p>얌파 프리미티브 중에 하나 <code>(delay)</code><br />
<code>(&gt;&gt;&gt;)</code> SF 합성 컴비네이터</p>
<pre><code>aState :: SF () Bool
aStateTwoSecondsAgo :: SF () Bool

integral :: (Fractional s, VectorSpace a s) =&gt; SF a a</code></pre>
<p><code>integral</code>: rectangle 규칙을 써서 통합</p>
<p>transformer 우리말로 번역하면 변환기 정도 되겠다.
SF는 연속 시그널 변환기다.
머릿속이 모호한 이유는 바로 “연속” 때문이다. 연속이란 개념을 어떻게 처리했을까?
무한 재귀 정의를 봤을 때와 마찬가지다. 무한하게 정의했다고, 무한하게 “동작”을 매 순간, CPU 틱을 소진하며 계속 동작 하고 있는 것이 아니다. 모든 대상들은 모피즘을 만나야 의미가 생긴다. 무한 정의들은 무한히 동작하지만, 어느 순간에, 혹은 어느 순간 까지만 필요하다는 모피즘을 반드시 파트너로 가지고 있다.<br />
아마도 이 연속이란 개념도 그러할 것이다. 시그널 <code>Time -&gt; α</code>는, 함수로 되어있다. 이 상태론 <code>α</code>를 알 수 없다. 원하는 시간을 넣어주는 파트너와 만날 것이다. 그 파트너가 언제, 어떤 <code>Time</code>값으로 찾아 올지 모르니, 특정 시간에만 존재하는 값이 아니라, <strong>모든 시간에 대응하는 값이 있다</strong>라는 개념을 표현한다면, 함수가 제격이다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Event</span> a</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Event</span> a</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">NoEvent</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">after ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">SF</span> a (<span class="dt">Event</span> b)</span></code></pre></div>
<p>시간과 <code>b</code>를 받아 시그널 함수를 돌려준다. 이 시그널 함수는 언젠가 <code>t-&gt;a</code>함수를 받아서, <code>t-&gt;Event b</code>로 변환한다. <code>Event</code>는 마치 <code>Maybe</code>와 비슷하다. <code>Event</code>가 있거나 없거나다. 5초 후에 알람을 맞춘다면, <code>after 5 () :: SF a (Event ())</code>로 두면 된다. Runner가 <code>5</code>가 되는지 검사하는 함수를 넣어 줄거라 추측할 수 있다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">edge ::</span> <span class="dt">SF</span> <span class="dt">Bool</span> (<span class="dt">Event</span> ())</span></code></pre></div>
<p><code>after 5 ()</code>는 5초 후에 시그널 함수가 동작한다면, edge는 입력 Bool값이 바뀌면 시그널 함수를 동작시킨다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">hold ::</span> a <span class="ot">-&gt;</span> <span class="dt">SF</span> (<span class="dt">Event</span> a) a</span></code></pre></div>
<p><code>SF</code> 함수들을 <code>&gt;&gt;&gt;</code>로 모두 연결해 놓으면서 프로세스가 완성된다. Runner가 이들을 받아서 어떤 식으로 정리해서 동작시킬지는 아직 설명하지 않는다. 그러니, SF 함수가 머릿속에서 모호하게 남아 있다. 실제 구현을 보여주진 않더라도, 어떤 아이디어가 동작할지는 얘기해줘야 하지 않을까?</p>
<p>혼자 상상해 보자. Runner는 어떤 일을 하게 될까?
<code>(Time -&gt; α) -&gt; (Time -&gt; β)</code> 뭉치를 받아서 뭘 하면 될까?
오른쪽 화살표가 눌리면, 그 것으로 끝이 아니다.
누군가는 그 걸 가져가 좌표값을 오른 쪽으로 바꿔 놓으면,
누군가는 그 걸 받아 화면을 다시 그려야 한다.</p>
<p>이 건 그동안 리스너를 콜백으로 넘겨주던 패턴과 다르지 않다.
어떤 식으로든 누가 누구를 리스닝할지는 지정해야 한다.
지정하는 방식에 분명 차이가 있을 것이다.</p>
<p>개개의 개체들이 리스너를 관리했다면, 총감독을 두어 관리 할 수도 있을 것이다.
이 때, Free 모나드와 비슷하게 체인을 엮은 구조로 만들어 두고 이를 총감독이 관리한다는 것 아닐까?
파이프에 이벤트 흐름이 흘러가게 두고,
누가 리스닝할지 모르지만, 이벤트에 이름을 붙여 파이프에 넣는 것이다. 그런데, 파이프에 흐름이 하나만 있는 건 아니다. 몇 개의 흐름이 있던 상관 없다. 총감독은 이 흐름들을 모두 지켜보고 있다.
내가 어떤 이벤트를 리스닝할지는 파이프에게만 알려주면 된다. 파이프가 총감독이다. 이 걸 의미하는 것일까?
SF는 이 파이프 안에서 “단위”처럼 동작하는 것 같다. 이벤트를 리스닝 한 후의 결과도 SF다.
A가 이런 이벤트를 발생 시키면,
B가 받아서 어떤 작업을 하는 것으로 끝나는 게 아니라,
B도 이어지는 이벤트를 발생 시키는 것이다.
이 걸 이벤트가 “변환”된 것으로 표현한다.
마치 모든 흐름은 파이프 안에서 이루어지고, 그저 잠깐 잠깐 상태를 바깥에서 지켜 볼 뿐이다.</p>
<p>어떤 것이 어떤 것의 영향을 받는다면, “동시”라는 개념은 존재하지 않는다. 의존성이 있다면 순서는 반드시 정해진다.</p>
<p>엘리엇의 FRP의 핵심 키워드는 “연속”이다. 연속을 어떻게 모델링할 것인가다. 가장 프리미티브한 모양을 t-&gt;α로, 함수로 시작한다. 생각해보면, 연속을 표현하는데 이 거만한 게 있을까 싶다.
SF는 이벤트가 흘러갈 경로를 만드는 프리미티브다.
파이프 안에는</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>SF ----&gt; SF ----&gt; SF ----&gt;...</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>            SF ----&gt; SF ----&gt; SF ----&gt;...</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    SF ----&gt; SF -+--&gt; SF ----&gt;...</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                 |</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>                 +----&gt; SF ----&gt; ...</span></code></pre></div>
<p>이 존재한다.</p>
<p>엘리엇과 후닥이 Functional 반응 애니메이션을 내놓은지 20년이 지났다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reactimate ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="co">-- 초기 액션</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>                      <span class="ot">-&gt;</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> m (<span class="dt">DTime</span>, <span class="dt">Maybe</span> a))  <span class="co">-- 입력 sensing 액션</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                      <span class="ot">-&gt;</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m <span class="dt">Bool</span>) <span class="co">-- Actuation (출력 처리) 액션</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                      <span class="ot">-&gt;</span> <span class="dt">SF</span> a b</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>                      <span class="ot">-&gt;</span> m ()</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>reactimate <span class="fu">init</span> sense actuate (<span class="dt">SF</span> {sfTF <span class="ot">=</span> tf0}) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    a0 <span class="ot">&lt;-</span> <span class="fu">init</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (sf, b0) <span class="ot">=</span> tf0 a0</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    loop sf a0 b0</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    loop sf a b <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>      done <span class="ot">&lt;-</span> actuate <span class="dt">True</span> b</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>      unless (a <span class="ot">`seq`</span> b <span class="ot">`seq`</span> done) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        (dt, ma') <span class="ot">&lt;-</span> sense <span class="dt">False</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> a'        <span class="ot">=</span> fromMaybe a ma'</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>            (sf', b') <span class="ot">=</span> (sfTF' sf) dt a'</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        loop sf' a' b'</span></code></pre></div>
<p>IO 액션을 써서 새로운 입력을 받고, 출력을 내보내는 <code>SF</code> 함수를 무한히 실행하는 함수입니다. SF 코드 덩어리의 runner쯤 되겠습니다.</p>
<p>컴비네이터
Time
Lifting
Integration
Choice
Behavior Switching
Snapshot</p>
<p><a href="https://lambdor-net.readthedocs.io/learn.html">Learning Yampa and Functional Reactive Programming</a></p>
<ul>
<li>모든 걸 Signal의 조합combination으로 모델링하면, 모든 곳에 시간 개념이 존재하게 된다.</li>
<li>reactimate는 프로그램을 입력IO(sense), 시그널 함수(SF), 출력IO(actuate)로 나눈다.</li>
<li>Switch들로 리액티브 시스템을 동적으로 변형할 수 있다.</li>
<li>동적으로 시스템에 등장하는 오브젝트 모음을 제어하라면 delayed parallel switch (<code>dpSwtich</code>) 시그널 함수를 쓴다.</li>
<li>입력 이벤트는 <code>route</code>를 통해 오브젝트들을 타고 전파된다.</li>
<li><code>route</code>는 전체 오브젝트 컬렉션을 추론해서 logical 이벤트를 생산한다.? (충돌 검출 같은 걸 말한다.)</li>
<li><code>killOrSpawn</code> 시스템에 등장 및 제거해야 하는 모든 이벤트를 모아 하나의 큰 함수 합성으로 만든다.</li>
<li>In the Space Invaders example gameCore :: IL Object -&gt; SF (GameInput, IL ObjOutput) (IL ObjOutput) is actually embedded in the function core :: … -&gt; SF GameInput (IL ObjOutput) which acts as the intermediate between sense and actuate (this is not mentioned in the Yampa Arcade paper)</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>FRP.Yampa.embed<span class="ot"> ::</span> <span class="dt">SF</span> a b <span class="ot">-&gt;</span> (a, [(<span class="dt">DTime</span>, <span class="dt">Maybe</span> a)]) <span class="ot">-&gt;</span> [b]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">--                   |        |           |</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">--       run할 시그널 함수    |           |</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">--                          초기값        |</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">--                          (time, Nothing | Just nextValue)</span></span></code></pre></div>
<p>입력 시그널을 위해 초기 입력 샘플과 샘플링 리스트, 그리고 시그널 함수를 인자로 받아 출력 샘플을 만들어 냅니다. <code>reactimate</code>의 순수 함수 버전입니다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> <span class="op">$</span> embed time (<span class="dt">Nothing</span>, [(<span class="fl">1.0</span>, <span class="dt">Nothing</span>), (<span class="fl">0.2</span>, <span class="dt">Nothing</span>), (<span class="fl">0.03</span>, <span class="dt">Nothing</span>)])</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> <span class="op">$</span> embed time (<span class="dv">123</span>, [(<span class="fl">1.0</span>, <span class="dt">Just</span> <span class="dv">234</span>), (<span class="fl">0.2</span>, <span class="dt">Just</span> <span class="dv">345</span>), (<span class="fl">0.03</span>, <span class="dt">Just</span> <span class="dv">456</span>)])</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> <span class="op">$</span> embed identity (<span class="dv">123</span>, [(<span class="fl">1.0</span>, <span class="dt">Just</span> <span class="dv">234</span>), (<span class="fl">0.2</span>, <span class="dt">Just</span> <span class="dv">345</span>), (<span class="fl">0.03</span>, <span class="dt">Just</span> <span class="dv">456</span>)])</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> <span class="op">$</span> embed identity (<span class="dv">537</span>, [(<span class="fl">1.0</span>, <span class="dt">Nothing</span>), (<span class="fl">0.2</span>, <span class="dt">Nothing</span>), (<span class="fl">0.03</span>, <span class="dt">Just</span> <span class="dv">123</span>)])</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> <span class="op">$</span> embed (constant <span class="dv">537</span>) (<span class="dt">Nothing</span>, [(<span class="fl">1.0</span>, <span class="dt">Nothing</span>), (<span class="fl">0.2</span>, <span class="dt">Nothing</span>), (<span class="fl">0.03</span>, <span class="dt">Nothing</span>)])</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> <span class="op">$</span> embed (constant <span class="dv">537</span>) (<span class="dv">123</span>, [(<span class="fl">1.0</span>, <span class="dt">Just</span> <span class="dv">234</span>), (<span class="fl">0.2</span>, <span class="dt">Just</span> <span class="dv">345</span>), (<span class="fl">0.03</span>, <span class="dt">Just</span> <span class="dv">456</span>)])</span></code></pre></div>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
