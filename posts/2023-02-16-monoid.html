<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - 비수학인이 해석한 모노이드 - 모노이드가 왜 중요할까?</title>

        <meta name="description" content="수학 용어인 모노이드에서, 비수학인이 필요한 정보만 빼내서, 혹은 프로그래머 시각에서 보는 제 멋대로 상상 글입니다." />
        <meta property="og:description" content="수학 용어인 모노이드에서, 비수학인이 필요한 정보만 빼내서, 혹은 프로그래머 시각에서 보는 제 멋대로 상상 글입니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="비수학인이 해석한 모노이드 - 모노이드가 왜 중요할까?" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-02-16-monoid.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

      <meta name="keywords" content="monoid, monad, 모노이드, 모나드, 일반화, 특수화, oid">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>비수학인이 해석한 모노이드 - 모노이드가 왜 중요할까?</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on February 16, 2023
    
</div>

<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">임시 오픈 2023.2.25\</td>
</tr>
<tr class="even">
<td style="text-align: left;">이 글은 잘 못된 접근이라는 지적을 받은 글입니다.\</td>
</tr>
<tr class="odd">
<td style="text-align: left;">상상하며 쓴 글로, 지인분께 질문을 드리게 위해 임시 오픈합니다.\</td>
</tr>
<tr class="even">
<td style="text-align: left;">우연히 검색으로 들어 오셨다면, 틀린 상상이 궁금한 분만 보세요.</td>
</tr>
</tbody>
</table>
<p>완벽한 학문적 정의를 풀어쓰려는 글이 아닙니다. 비수학인인 프로그래머로서 관심을 가지는, 모노이드 속성에 관한 얘기입니다. 믿을만한 어디 텍스트를 읽고 생각을 정리한 글이 아니니, 매우 얼기 설기한 생각일 것으로 예상됩니다. “이렇게 이해, 혹은 <em>오해</em>를 하는 사람도 있구나” 정도로 읽어주세요. 오해로 판단된다면 꼭 댓글 부탁드립니다. 지금까지 아래처럼 설명한 자료를 본 적이 없으니, 틀릴 확률이 높습니다. 정확하지도 않은 글을 올리는 이유는, “정확하게 알고”싶어서 입니다.</p>
<p>“한 가지 모양으로 보자”</p>
<p>제가 생각하는 모노이드는 바로 위 문장에 관한 얘기입니다.</p>
<h2 id="모노이드monoid-단어">모노이드monoid 단어</h2>
<p>어미에 <code>~oid</code>가 붙으면, “딱 그 건 아닌데, 그 것 같은 것들”을 뜻합니다. <code>humanoid</code>, <code>android</code>, <code>roboid</code> 주로 인간을 흉내 내는 인간 같은 로봇에 붙는 말등으로 만났던 말입니다. 뭔가 <code>mono</code>는 아닌데, <code>mono</code>같은, <code>mono</code>로 볼 수 있는 무언간가 봅니다.</p>
<h2 id="수학에서-모노이드">수학에서 모노이드</h2>
<p>어떤 시스템에 이항 연산이 있고, 항등원이 존재하고, 이 이항 연산이 결합 법칙을 만족하고 닫혀 있으면 어떤 것이든 모노이드라 부릅니다.</p>
<p>(※ 이 정의만으론, 어떻게 함수형 프로그래밍과 연결되는지 알게되는데까지 정말 많은 시간과 노력이 필요합니다.)</p>
<h2 id="수학-모노이드-설명을-내가-필요한대로-해석">수학 모노이드 설명을 내가 필요한대로 해석</h2>
<p>여기서, 말을 잘 못하면 완벽한 해석을 주장하는 것으로 오해 받을 수 있어, 다음 말부터 조심스럽게 강조하고 이어 가겠습니다.</p>
<p>“지금 여기서 얘기하는 것이 모노이드의 모든 특징”</p>
<p>이란 말을 하고 싶은 게 아닙니다. 혹은, 이렇게 해석해야 한다는 주장도 아닙니다. 딱, 제가 프로그래밍할 때 필요한 정보만 꺼내보면, 혹은 프로그래밍 관점에서 모노이드의 정의를 해석하면 아래와 같은 특징을 잡아 낼 수 있다는 걸 말하는 중입니다.</p>
<p>“어떤 시스템이 있고, 이항 연산과 항등원이 존재해서 이 시스템에 있는 구성 요소는 모두 <em>이 연산이 쓰인 한 가지 모양으로 표현</em>할 수 있다”</p>
<p>이 말을, 사례를 들어 풀어 보면 다음과 같습니다.</p>
<h2 id="자연수-더하기-모노이드">자연수, 더하기 모노이드</h2>
<p><code>0</code>이 없는 자연수 시스템이 있습니다. <code>1,2,3...</code><br />
그리고, 더하기 <code>(+)</code> 이항 연산이 있습니다.<br />
<code>2</code>는 <code>1</code>과 <code>1</code>을 더한 것으로 표현할 수 있습니다. <code>2 = 1 + 1</code><br />
<code>3</code>은 <code>1</code>과 <code>2</code>를, 혹은 <code>2</code>와 <code>1</code>을 더한 것으로 표현할 수 있습니다. <code>3 = 1 + 2</code></p>
<p>그럼 <code>1</code>을 더하기를 쓴 모양으로 표현하려면 어떻게 할까요?</p>
<p>지금 상황에선 표현할 방법이 없습니다.</p>
<p>여기에, <code>0</code>을 추가해 보겠습니다. <code>1</code>이나 <code>2,3,4...</code> 어떤 구성 요소에 더하기 <code>0</code>을 하면, 원래 숫자가 그대로 나옵니다. “아무 일도 일어나지 않습니다.” (추가적인 조건을 엄밀하게 만족하면 항등원Identity이라 부릅니다만, 섣부른 정의는 오해를 살 수 있으니, 정교한 정의는 추상 대수학등을 참고 해주시고, 여기서는 필요한 뜻만 보겠습니다.) 보통은 이런 설명만 강조하고 추가 설명은 없는 경우가 많습니다. 이 <code>0</code>을 이용하면 비로소 <code>1</code>도, 지금 새롭게 추가하는 <code>0</code>도 더하기를 쓴 모양으로 표현할 수 있게 됩니다.</p>
<p><code>1</code>은 <code>0</code>과 <code>1</code>을 더한 것으로 표현할 수 있습니다. <code>1 = 1 + 0</code><br />
<code>0</code>은 <code>0</code>과 <code>0</code>을 더한 것으로 표현할 수 있습니다. <code>0 = 0 + 0</code></p>
<p>시스템에 <code>0</code>을 추가하면서, <code>0</code>을 포함한 모든 구성 요소를 <code>a + a</code> 꼴로 표현할 수 있게 되었습니다. <code>0</code>이 있어, <em>모든 구성 요소를 하나의 모양으로 추상화</em>할 수 있게 되었습니다. 이 “추상화” 말이 불편한 분은, 모두 같은 모양으로 표현할 수 있게 됐다로 넘어가도 좋습니다.</p>
<p>모두 같은 모양으로 볼 수 있다는 건 대단한 특징입니다. 이 말을 타입으로 확장해 보겠습니다.</p>
<h2 id="반군subgroup과-차이">반군subgroup과 차이</h2>
<h3 id="반군">반군</h3>
<p>모노이드에서 항등원을 빼면 반군이 됩니다. 반군도 역시 이항 연산은 닫혀 있기에, 어떤 구성원 둘의 연산 결과도 다시 반군의 구성원이 됩니다. 자연수 <code>1,2,3,4,5...</code>있을 때 어떤 두 구성원을 골라도, 결과도 자연수가 됩니다.</p>
<h3 id="항등원">항등원</h3>
<p>여기에 항등원이 있으면 무슨 일이 생길까요?</p>
<p>“자기 자신도 연산이 들어간 모양으로 표현할 수 있습니다.”</p>
<p>아무 일도 일어나지 않는 항등원으로 자신을 표현하는 게 왜 필요할까요? 연산은 “변화”를 의미하는데, 이를 무력화 시킬 수 있는 항등원이 있으면, 프로그래밍에서 더 유용해지는 이유가 뭘까요?</p>
<p><code>1</code>과 <code>1 + 0</code>의 차이는 무엇일까요?
### 타입
<code>Maybe</code>타입을 정의하고 값 생성자 <code>Just</code> 혹은 <code>Nothing</code>으로 타입을 만들어 냅니다. 이렇게 만들어진 <code>Maybe a</code>의 <code>a</code>에 접근하려면 반드시 어떤 절차를 거쳐야 합니다. 타입은 “추가 절차”를 가지고 있습니다. 생성자도 하나의 계산식computation입니다. 위의 연산 <code>+</code>를 타입 안에 실어(넣어) 보겠습니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AddConstructor</span> x y <span class="ot">=</span> <span class="dt">AddConstructor</span> x y</span></code></pre></div>
<p>이 타입에는 <code>+</code>라는 절차를 넣어 뒀습니다. 안에 있는 값에 접근할 때는 언젠가는 이 절차를 거친 후 접근 할 겁니다. 아마도 <code>fmap</code>이 담당할 겁니다.</p>
<p><code>1 + 2</code>는 <code>AddConstructor 1 2</code>로 표현할 수 있습니다. <code>1 + 2</code>를 한 것에 <code>3 + 4</code>를 더한다면, <code>AddConstructor 1 2</code> 와 <code>AddConstructor 3 4</code>를 <code>AddConstructor</code>에 넘겨야 합니다. 계속 <code>AddConstructor</code>로 생성하는데 문제가 없게 하려면 <code>AddConstructor</code>는 인자로 <code>AddConstructor</code>를 받아야 합니다.</p>
<p>구성원을 전부 <code>AddConstructor</code> 타입으로 보려합니다. 자연수 전부를 <code>AddConstructor</code>로 보려합니다. 반군이라면, 다른 건 어찌 다 표현한다 처도 <code>1</code>은 <code>AddConstructor</code>로 표현할 방법이 없습니다. <code>1 + 1</code>에 다시 <code>1</code>을 더해 <code>3</code>을 표현하려면</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">AddConstructor</span> (<span class="dt">AddConstructor</span> <span class="dv">1</span> <span class="dv">1</span>) <span class="dv">1</span> <span class="co">-- error </span></span></code></pre></div>
<p>타입이 달라 할 수가 없습니다. 항등원이 있어야 비로소</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">AddConstructor</span> (<span class="dt">AddConstructor</span> <span class="dv">1</span> <span class="dv">1</span>) (<span class="dt">AddConstructor</span> <span class="dv">1</span> <span class="dv">0</span>) <span class="co">-- ok</span></span></code></pre></div>
<p>으로 표현할 수 있습니다.</p>
<p>“항등원이 있으면 구성원을 모두 하나의 타입으로 표현할 수 있습니다.”</p>
<h2 id="a---a-.-모노이드">a -&gt; a , (.) 모노이드</h2>
<p>구성 요소가 자연수같은 값이 아닌, 위 <code>AddConstructor</code>처럼 계산식compuation인 <code>a -&gt; a</code> 형태의 함수일 경우를 보겠습니다. 짧게 쓰기 위해 <code>a -&gt; a</code>를 <code>Func</code> 모양이라 부르겠습니다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Func</span> <span class="ot">=</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p><code>f, g, h ... :: Func</code> 라는 구성 요소들이 존재하고, 이들 사이의 관계를 표현하는 이항 연산 <code>(.)</code>이 있습니다. 이 연산은 먼저 들어온 함수를 적용현 결과를 다음 함수의 입력으로 넣어주는 함수입니다.</p>
<p><code>h = g . f</code><br />
<code>i = h . g</code><br />
…</p>
<p>반드시 더하기와 같은 동작을 할 필요는 없고, 어찌 됐든 구성 요소, 즉 모든 <code>Func</code> 함수는, <code>Func</code>들을 <code>(.)</code>로 엮은 걸로 표현할 수 있게 하고 싶습니다. (왜 이렇게 하고 싶냐는 결론에서 보겠습니다.) 어찌 됐든 지금은 <em>한 가지 모양으로 표현</em> 된다는 것만 보시기 바랍니다.</p>
<p>여기서도 더 이상 <code>(.)</code>을 쓴 모양으로 쪼개지지 않는 함수가 있다고 보겠습니다. 이런 경우에도 만일 “아무 것도 안함”이란 요소가 존재한다면, 위 자연수 경우처럼 <code>Func</code>가 구성 요소인 시스템의 모든 구성 요소를 <code>(.)</code> 모양으로 표현할 수 있습니다. 이 경우 자연수의 항등원과 같은 역할을, <code>id</code>함수가 합니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Func</span> <span class="ot">=</span> <span class="dt">Func</span> <span class="op">.</span> <span class="fu">id</span></span></code></pre></div>
<h2 id="a---m-a-가-구성-요소인-모노이드">a -&gt; m a 가 구성 요소인 모노이드</h2>
<p>구성 요소가 <code>a -&gt; a</code> 형태가 아니라, <code>a -&gt; m a</code> 형태의 구성 요소들이 있고 <code>(.)</code>이 있는 경우를 보겠습니다. 표현하기 편하게</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">M</span> <span class="ot">=</span> a <span class="ot">-&gt;</span> m a  </span></code></pre></div>
<p><code>M</code>이라 부르겠습니다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">M</span> <span class="ot">=</span> <span class="dt">M</span> <span class="op">.</span> <span class="dt">M</span></span></code></pre></div>
<p>즉, 모든 구성원을 연산을 앞에 두는 전위 표현식으로 쓰면 <code>(.) M M</code> 모양으로 보는 게 목표입니다.</p>
<p>처음 <code>M</code>을 적용하면 결과는 <code>m a</code>가 되고, 이를 두 번째 M의 입력으로 넣어 주면 결과는 <code>m (m a)</code>가 됩니다. 즉 <code>M :: a -&gt; m a</code>와 <code>M :: a -&gt; m a</code>를 <code>(.)</code>로 연산하니, 합성의 결과는 <code>a -&gt; m (m a)</code>가 돼버렸습니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">M</span> <span class="op">.</span> <span class="dt">M</span> <span class="ot">=</span> a <span class="ot">-&gt;</span> m (m a) <span class="co">-- 결과가 M :: a -&gt; m a 모양이 아닙니다.</span></span></code></pre></div>
<p>시스템의 모든 <code>M</code>을 <code>(.)</code>을 쓴 한 가지 모양으로 표현이 불가능한 상황입니다. 즉, 이 상태에선 모노이드가 아닙니다.</p>
<h3 id="join">join</h3>
<p>그런데, 여기에 <code>join :: m (m a) -&gt; m a</code>이란 함수가 있다면 어떻게 될까요? <code>(.)</code>을 적용 후 연이어 <code>join</code>을 적용하면 <code>a -&gt; m a</code>가 되니, 구성 요소들을 모두 <code>(.) 적용 후 join</code>로 표현할 수 있을 것처럼 보입니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">M</span> <span class="ot">=</span> <span class="dt">M</span> <span class="ot">`(.) 적용 후 join`</span> <span class="dt">M</span></span></code></pre></div>
<p>하지만, 아직 해결되지 않은 한 가지가 남아 있습니다.</p>
<h3 id="return">return</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">M</span> <span class="ot">=</span> <span class="dt">M</span> <span class="ot">`(.) 적용 후 join`</span> <span class="fu">id</span> </span></code></pre></div>
<p>이 되어야 하는데, <code>a -&gt; m a</code> 와 <code>id</code>에 <code>(.)</code>을 적용하면, 이 번엔 결과가 그 대로 <code>a -&gt; m a</code> 이어서 <code>join</code>을 적용할 수 없습니다. 그래서, <code>return :: a -&gt; m a</code>를 정의해서 <code>id</code>의 경우에는</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">M</span> <span class="ot">=</span> <span class="dt">M</span> <span class="ot">`(.) 적용 후 join`</span> (<span class="fu">return</span> <span class="fu">id</span>)</span></code></pre></div>
<p>이 되게 하면, 비로소 <code>id</code>를 포함한 모든 구성 요소를 한 가지 <code>(.) 적용 후 join</code> 모양으로 표현할 수 있게 되었습니다.</p>
<h2 id="생각-스트레칭---대상을-변환할-것인가-연산을-변환할-것인가">생각 스트레칭 - 대상을 변환할 것인가, 연산을 변환할 것인가</h2>
<p>2튜플 둘을 비교하는 함수가 있습니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Height</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Age</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ot">equal ::</span> (<span class="dt">Height</span>, <span class="dt">Age</span>) <span class="ot">-&gt;</span> (<span class="dt">Height</span>, <span class="dt">Age</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>equal x y <span class="ot">=</span> x <span class="op">==</span> y</span></code></pre></div>
<p>그런데, 현재는 키만 같으면 같은 것으로 보려 합니다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">equalH ::</span> (<span class="dt">Height</span>, <span class="dt">Age</span>) <span class="ot">-&gt;</span> (<span class="dt">Height</span>, <span class="dt">Age</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>equalH x y <span class="ot">=</span> <span class="fu">fst</span>(x) <span class="op">==</span> <span class="fu">fst</span>(y)</span></code></pre></div>
<p>이 번엔 나이만 같으면 같은 것으로 보려 합니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">equalA ::</span> (<span class="dt">Height</span>, <span class="dt">Age</span>) <span class="ot">-&gt;</span> (<span class="dt">Height</span>, <span class="dt">Age</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>equalA x y <span class="ot">=</span> <span class="fu">snd</span>(x) <span class="op">==</span> <span class="fu">snd</span>(y)</span></code></pre></div>
<p>둘이 유사하니, 같은지 비교하기 전에, 필요한 부분만 남기는 함수를 넘겨 아래와 같이 합칠 수 있습니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">F</span> <span class="ot">=</span> (<span class="dt">Height</span>, <span class="dt">Age</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">equal ::</span> <span class="dt">F</span> <span class="ot">-&gt;</span> (<span class="dt">Height</span>, <span class="dt">Age</span>) <span class="ot">-&gt;</span> (<span class="dt">Height</span>, <span class="dt">Age</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>equal f x y <span class="ot">=</span> f(x) <span class="op">==</span> f(y)</span></code></pre></div>
<p>이제 <code>equal</code>을 부를 때, <code>equal fst t1 t2</code> 혹은 <code>equal snd t1 t2</code>로 부르면 됩니다.</p>
<p>그럼, 튜플 전체를 비교하던, 원래 <code>f</code>를 받기 전 <code>equal</code>의 동작을 하게 하려면 어떻게 하면 될까요?</p>
<p><code>equal id t1 t2</code>로 부르면 됩니다.</p>
<p>하스켈은 커링이 되니 다음처럼 얘기할 수도 있습니다.</p>
<p><code>equal</code>을 부르지 않고, <code>equal fst</code>, <code>equal snd</code>, <code>equal id</code> 등으로 “변환”된 비교 함수로 쓰면 됩니다.</p>
<p>튜플 둘을 상황에 따라 비교하기 위해, 각 튜플을 변형 시키던 작업을, <code>equal</code>로 옮겼습니다. 값 자체를 변환하지 않고, 값을 비교하던 동작을 변환했다고 말 합니다.</p>
<h2 id="모나드는-모노이드의-일반화">모나드는 모노이드의 일반화</h2>
<p>눈치 채셨겠지만, 위는 알고 계신 바와 같이 바로 모나드입니다. <code>join</code>, <code>return</code> 의 도움을 받아 <code>M</code>과 <code>(.)</code>이 모노이드가 되는 걸 모나드라 합니다. ※ <code>join</code>과 <code>return</code>은 <code>(.)</code>란 함수를 변환하는 고차 함수로 카테고리 이론에선 <code>Natural Transform</code>이라 부릅니다.</p>
<p>그동안 봐왔던 모노이드를 바로 이 모나드로 표현할 수 있습니다.</p>
<p>바로 <code>Func</code>와 <code>(.)</code> 모노이드는 <code>return</code>과 <code>join</code>이 아무 것도 안하는 모나드에 해당하는 특수한 경우로 볼 수 있습니다.</p>
<h2 id="왜-한-가지-모양으로-보는-게-중요할까">왜, 한 가지 모양으로 보는 게 중요할까?</h2>
<p>금방 눈에 보이는 건, “연이은 Composition이 가능하다” 인데, 이 걸 조금 풀면 다음과 같이 말할 수도 있습니다.</p>
<p>함수형은 계속 함수가 함수를 감싸는 모양이 되는데, 만일 <code>m a</code>를 입력으로 받아야 하는 함수가 있고 모나드라면, 여기에는 <code>m a</code>도, <code>m (m a)</code>도, <code>m (m (m ...</code>도 넘길 수 있게 됩니다. 이 게 가능하게 되면 함수 합성을 덩어리, 덩어리로 쪼개어 모듈화가 가능해집니다.</p>
<p>하스켈로 얘기하면, <code>Maybe</code> 타입이 있는데, <code>job1</code>의 결과도 <code>Maybe</code>이고, <code>job2</code>의 결과도 <code>Maybe</code>이면 이 두 <code>job</code>을 <code>(.)</code>, <code>join</code>, <code>return</code> 으로 합성해서, 타입이 변하지 않은 <code>Maybe</code>타입의 <code>job</code>을 만들어 낼 수 있다는 말입니다.</p>
<p>어떤 함수가 <code>Action</code>을 받는다면 이 함수에는 (<code>join</code>혹은 <code>return</code>을 변형이라 표현했습니다.)</p>
<p><code>Action1</code> (변형 . 연산) <code>Action2</code></p>
<p>를 넘겨 줄 수도,</p>
<p><code>Action1</code> (변형 . 연산) <code>Action2</code> (변형 . 연산) <code>Action3</code> (변형 . 연산) <code>Action4</code> (변형 . 연산) <code>Action5</code></p>
<p>를 넣어 줄 수도 있게 됩니다. 결합 법칙을 만족하니, <code>Action</code> <code>1</code>,<code>2</code>를 먼저 묶고, <code>3</code>,<code>4</code>,<code>5</code>를 묶는다든지, <code>1</code>,<code>2</code>,<code>3</code>,<code>4</code>를 묶고, <code>5</code>를 묶는다든지 할 수도 있습니다. 함수형 프로그래밍의 구조 자체에 모노이드 개념이 깊이 들어가 있습니다.</p>
<p>(※ 여기서 얘기하는 모노이드, 모나드는 하스켈의 모노이드 클래스, 모나드 클래스를 말하는 게 아닙니다. 모노이드 “개념”을 함수형과 어떻게 붙이는가에 대한 얘기입니다. )</p>
<p>함수형 프로그래밍의 근간이 되는 중요한 특징 중 하나로 볼 수 있습니다.</p>
<h2 id="상상-혹은-잡소리">상상 혹은 잡소리</h2>
<p><code>0</code>을 포함한 자연수 집합의 구성원들을 더하기란 연산에 모두 의존하는 것으로 바라 보면, 하나의 구성원은 다른 구성원들과 더하기로 어떤 관계가 되는가로 나타낼 수 있습니다. 모든 구성원들은 항등원과 관계를 맺고, 다른 구성원들과 더하기 관계로 모두 나타낼 수 있습니다. <code>3</code>은 <code>2</code>와 <code>+1</code>의 관계가 있고, <code>1</code>과 <code>+2</code>의 관계가 있습니다. <code>2</code>는 <code>1</code>과 <code>+1</code>의 관계가 있습니다. 다른 것들과의 관계로 구성원을 표현할 수 있다고 볼 수 있습니다. 이렇게 모든 구성원을 표현할 수 있는 원자적인 요소로 <code>0</code>, <code>1</code>, <code>+</code>가 존재하는 것처럼 볼 수도 있습니다. 재귀 함수가 종료 조건을 갖듯이, 반복되는 관계로 표현할 때 항등원이 종료 조건이 되는 것으로 볼 수도 있습니다.</p>
<p>하스켈에서 모노이드, 모나드를 공부하며 꽂힌 개념이 바로 ’같음’입니다. 결과를 모두 <code>Maybe</code>로 만들어 같음을 만들어 간다고 볼 수도 있고, 결과를 모두 <code>Maybe 연산 Maybe</code>로 만들어 같음을 만들어 간다고 볼 수도 있습니다. 전 같음에 중요한 역할을 하는 연산을 끌어 들인 후자로 상상했습니다. <code>Maybe 연산 id</code>를 <code>Maybe</code>로 표기할 뿐입니다.</p>
<p>※ 여기서 제가 얘기한 ’같음’과 같은지는 잘 모르는데, ’같음’을 연구하는 학문이 Homotopy Type Theory라고 합니다. 매우 어렵다니, 비수학인이 눈길을 줄만한 건 아닌 것 같습니다.</p>
<h2 id="사족">사족</h2>
<p>항등원이 추상화(혹은 일반화) 도구로 유용하게 쓰일 수 있다라고 말하니, 여러 분들이 오개념이라 지적해 주셨는데, 그 내용이 일부 들어가 있습니다. 아직도 어느 부분이 오해를 하고 있는지 잘 모릅니다. 어차피, 제 블로그를 보는 분은 극 소수이긴 하나, 다시 한 번 위험성을 강조하겠습니다. 저처럼 추상 대수의 모노이드 설명만으론 궁금함이 해결되지 않는 분이, 어쩌다가 이 글을 본다면 같이 “상상하고 고민한다”는 생각으로 읽어 주시기 바랍니다. <em>정답을 전달하는 글이 아닙니다.</em></p>
<p>위는 엄밀하지 못하게 설명한 부분 투성입니다. 위와 갈은 관점으로 해석하는 글을 본 적이 없는 이유일지도 모릅니다. “틀렸을지도 모른다”는 주의문을 달고 자유롭게 글을 쓰는 블로그 수준의 글임을 감안해 주시기 바랍니다.</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
