<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - Lens - 펑크터의 독특한 활용</title>

        <meta name="description" content="하스켈의 레코드 데이터 구조가 가진 필드에 손쉽게 접근할 수 있게 해주는 라이브러리 렌즈" />
        <meta property="og:description" content="하스켈의 레코드 데이터 구조가 가진 필드에 손쉽게 접근할 수 있게 해주는 라이브러리 렌즈" />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Lens - 펑크터의 독특한 활용" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2021-05-13-lens.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/lens.png" />

      <meta name="keywords" content="Lens, 값 생성자 트릭, Traversal, traverse, haskell, 하스켈, 함수형, Functional">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
<meta name="fediverse:creator" content="@lionhairdino@mastodon.social">
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px"></div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:20px;border:none" src="../images/bluesky.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://discordapp.com/users/lionhairdino#7687"><img style="width:20px;border:none" src="../images/discord.svg"></a></div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다. 여기 글을 처음 읽는 분은, 먼저 <a href="warning.html">주의문</a>을 꼭 읽어보세요.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>Lens - 펑크터의 독특한 활용</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on May 13, 2021
    
</div>

<h3 id="목차">목차</h3>
<ol type="1">
<li><a href="#lens의-목적">Lens의 목적</a></li>
<li><a href="#템플릿이-만들어내는-대략적인-코드-모양">템플릿이 만들어내는 대략적인 코드 모양</a></li>
<li><a href="#traversals">Traversals</a></li>
<li><a href="#쥬스-만들기에-비유해-봤습니다">쥬스 만들기에 비유해 봤습니다</a></li>
<li><a href="#왜-펑크터가-들어가-있을까요">왜 펑크터가 들어가 있을까요?</a>
<ol type="1">
<li><a href="#펑크터-없이-구현">펑크터 없이 구현</a></li>
<li><a href="#펑크터가-필요한-이유">펑크터가 필요한 이유</a></li>
</ol></li>
</ol>
<figure>
<img src="../images/lens.png" alt="천재만 하스켈을 쓰는 건 아닙니다. 몸 좀 쓰면 안되나요?" />
<figcaption aria-hidden="true">천재만 하스켈을 쓰는 건 아닙니다. 몸 좀 쓰면 안되나요?</figcaption>
</figure>
<h2 id="lens의-목적">Lens의 목적</h2>
<p>예시 소스는 공식 튜토리얼에서 발췌했습니다.<br />
<a href="https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html" class="uri">https://hackage.haskell.org/package/lens-tutorial-1.0.4/docs/Control-Lens-Tutorial.html</a></p>
<p>우선 무엇을 위한 라이브러리인지부터 보겠습니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Atom</span> <span class="ot">=</span> <span class="dt">Atom</span> {<span class="ot"> _element ::</span> <span class="dt">String</span>,<span class="ot"> _point ::</span> <span class="dt">Point</span> } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">Point</span> {<span class="ot"> _x ::</span> <span class="dt">Double</span>,<span class="ot"> _y ::</span> <span class="dt">Double</span> } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">atom ::</span> <span class="dt">Atom</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>atom <span class="ot">=</span> <span class="dt">Atom</span> <span class="st">&quot;I am Atom&quot;</span> (<span class="dt">Point</span> <span class="fl">1.0</span> <span class="fl">2.0</span>)</span></code></pre></div>
<p><code>atom</code>에서 <code>_x</code>값이 필요하다면</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">spitX ::</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>spitX (<span class="dt">Atom</span> str (<span class="dt">Point</span> x y)) <span class="ot">=</span> x</span></code></pre></div>
<p><code>_x</code>에 값을 지정하려면</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">updateX ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> <span class="dt">Atom</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>updateX newX (<span class="dt">Atom</span> str (<span class="dt">Point</span> x y)) <span class="ot">=</span> <span class="dt">Atom</span> str (<span class="dt">Point</span> newX y)</span></code></pre></div>
<p><code>_x</code>에 함수를 적용해서 수정하려면</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fmapX ::</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>) <span class="ot">-&gt;</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> <span class="dt">Atom</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>fmapX f (<span class="dt">Atom</span> str (<span class="dt">Point</span> x y)) <span class="ot">=</span> <span class="dt">Atom</span> <span class="dt">Str</span> (<span class="dt">Point</span> (f x) y)</span></code></pre></div>
<p>그럼 나머지 요소들에도 같은 함수들이 필요할 거라 예상할 수 있습니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>spitElement</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>updateElement</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>fmapElement</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>spitY</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>updateY</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>fmapY</span></code></pre></div>
<p>데이터 타입이 다양한 깊이로 여러 값을 가지고 있을 때 매 번 패턴 매칭으로 접근하는 코드를 만들어야 합니다. 딱 봐도 프로그래머가 뭔 짓을 할 것만 같은 지루함이 보입니다. Lens는 바로 이 뭔 짓에 해당하는 라이브러리입니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Lens</span> <span class="kw">hiding</span> (element)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Lens.TH</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Atom</span> <span class="ot">=</span> <span class="dt">Atom</span> {<span class="ot"> _element ::</span> <span class="dt">String</span>,<span class="ot"> _point ::</span> <span class="dt">Point</span> } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">Point</span> {<span class="ot"> _x ::</span> <span class="dt">Double</span>,<span class="ot"> _y ::</span> <span class="dt">Double</span> } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(makeLenses '<span class="dt">'Atom</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(makeLenses '<span class="dt">'Point</span>)</span></code></pre></div>
<p>각 필드들에 바로 접근할 수있는 함수들을 여기선 렌즈라고 부릅니다. 하스켈 템플릿을 활용해 <code>Atom</code>과 <code>Point</code>를 위한 렌즈를 만듭니다. 그럼 다음처럼 필드에 접근 할 수 있습니다.</p>
<p><code>_x</code>값이 필요하다면</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>view (point <span class="op">.</span> x) atom</span></code></pre></div>
<p><code>_x</code>에 함수를 적용해서 수정하려면</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>over (point <span class="op">.</span> x) (<span class="op">+</span><span class="dv">1</span>)</span></code></pre></div>
<p>단 두 줄의 템플릿 코드로 생기는 혜택이 꽤 훌륭합니다.</p>
<h2 id="템플릿이-만들어내는-대략적인-코드-모양">템플릿이 만들어내는 대략적인 코드 모양</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Lens'</span> a b <span class="ot">=</span> <span class="kw">forall</span> f <span class="op">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f a)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="ot">element ::</span> <span class="dt">Lens'</span> <span class="dt">Atom</span> <span class="dt">String</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="ot">point   ::</span> <span class="dt">Lens'</span> <span class="dt">Atom</span> <span class="dt">Point</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="ot">x       ::</span> <span class="dt">Lens'</span> <span class="dt">Point</span> <span class="dt">Double</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="ot">y       ::</span> <span class="dt">Lens'</span> <span class="dt">Point</span> <span class="dt">Double</span></span></code></pre></div>
<p>언더바underscore가 붙은 필드당 하나의 렌즈가 만들어집니다. 렌즈는 여기서 언더바를 떼어낸 걸 이름으로 씁니다. 혹 템플릿을 쓸 수 없는 상황이면 아래와 같이 <code>lens</code> 함수를 써서 수작업으로 렌즈를 만듭니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lens ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Lens'</span> a b</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">point ::</span> <span class="dt">Lens'</span> <span class="dt">Atom</span> <span class="dt">Point</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>point <span class="ot">=</span> lens _point (\atom newPoint <span class="ot">-&gt;</span> atom { _point <span class="ot">=</span> newPoint })</span></code></pre></div>
<p>lens 라이브러리를 쓰지 않고, 만들면 제일 처음 봤던 코드와 비슷하게 나옵니다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">point ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (<span class="dt">Point</span> <span class="ot">-&gt;</span> f <span class="dt">Point</span>) <span class="ot">-&gt;</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> f <span class="dt">Atom</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>point k atom <span class="ot">=</span> <span class="fu">fmap</span> (\newPoint <span class="ot">-&gt;</span> atom { _point <span class="ot">=</span> newPoint }) (k (_point atom))</span></code></pre></div>
<p><code>x</code>, <code>point</code>는 모두 함수입니다. <code>point . x</code> 같은 스타일로 쓸 수 있게 됩니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- GHC가 (.) 쓰는데, Lens'을 만나면 다음처럼 추론합니다.</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(.) ::</span> <span class="dt">Lens'</span> a b <span class="ot">-&gt;</span> <span class="dt">Lens'</span> b c <span class="ot">-&gt;</span> <span class="dt">Lens'</span> a c</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">--        point    .    x     </span></span></code></pre></div>
<p>view와 같은 일을 하는 중위 연산자 <code>^.</code>를 정의해서 최대한 직관적으로 모양을 만듭니다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>(point <span class="op">.</span> x) atom <span class="ot">=</span> atom<span class="op">^.</span>point<span class="op">.</span>x </span></code></pre></div>
<p>여기까지만 알아도, 대부분의 렌즈 사용 코드는 이해할 수 있다고 합니다. 조금 더 들어가면</p>
<h2 id="traversals">Traversals</h2>
<p>참고 - <a href="../posts/2020-07-02-Context.html">Traversable</a></p>
<p>더 깊이가 있는 데이터 구조를 예를 들어 봅시다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Molecule</span> <span class="ot">=</span> <span class="dt">Molecule</span> {<span class="ot"> _atoms ::</span> [<span class="dt">Atom</span>] } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(makeLenses '<span class="dt">'Molecule</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="ot">molecule ::</span> <span class="dt">Molecule</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>molecule <span class="ot">=</span> <span class="dt">Molecule</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    { _atoms <span class="ot">=</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        [ <span class="dt">Atom</span> { _element <span class="ot">=</span> <span class="st">&quot;C&quot;</span>, _point <span class="ot">=</span> <span class="dt">Point</span> { _x <span class="ot">=</span> <span class="fl">2.0</span>, _y <span class="ot">=</span> <span class="fl">2.0</span> } }</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        , <span class="dt">Atom</span> { _element <span class="ot">=</span> <span class="st">&quot;O&quot;</span>, _point <span class="ot">=</span> <span class="dt">Point</span> { _x <span class="ot">=</span> <span class="fl">4.0</span>, _y <span class="ot">=</span> <span class="fl">4.0</span> } }</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p><code>Molecule^.atoms</code> 까지는 추측 되는데 그 다음은 어떻게 될까요? <code>Atom</code>이 하나가 아니라서 <code>traverse</code>를 써주고, 그 다음 <code>point</code>와 <code>x</code>에 접근합니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">shiftMoleculeX ::</span> <span class="dt">Molecule</span> <span class="ot">-&gt;</span> <span class="dt">Molecule</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>shiftMoleculeX <span class="ot">=</span> over (atoms <span class="op">.</span> <span class="fu">traverse</span> <span class="op">.</span> point <span class="op">.</span> x) (<span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<p>왜 <code>traverse</code>를 썼을까요? <code>fmap</code>을 쓰면 안됐을까요?<br />
<code>molecule^.atoms</code>로 <code>[Atom1, Atom2]</code> 까지는 도달했습니다. 그 다음 <code>point . x</code> 함수를 먹여야 하는데, <code>fmap</code>으로 먹이면 될 것 처럼 보입니다. 하지만 <code>fmap</code>을 쓰면 에러가 나고, <code>traverse</code>를 써야합니다.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> over ( <span class="fu">traverse</span> <span class="op">.</span> point <span class="op">.</span> x ) (<span class="op">+</span> <span class="dv">1</span>) <span class="op">$</span> [ <span class="dt">Atom</span> <span class="st">&quot;1&quot;</span> (<span class="dt">Point</span> <span class="fl">1.0</span> <span class="fl">2.0</span>), <span class="dt">Atom</span> <span class="st">&quot;2&quot;</span> (<span class="dt">Point</span> <span class="fl">3.0</span> <span class="fl">4.0</span>) ]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>[<span class="dt">Atom</span> {_element <span class="ot">=</span> <span class="st">&quot;1&quot;</span>, _point <span class="ot">=</span> <span class="dt">Point</span> {_x <span class="ot">=</span> <span class="fl">2.0</span>, _y <span class="ot">=</span> <span class="fl">2.0</span>}}</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>,<span class="dt">Atom</span> {_element <span class="ot">=</span> <span class="st">&quot;2&quot;</span>, _point <span class="ot">=</span> <span class="dt">Point</span> {_x <span class="ot">=</span> <span class="fl">4.0</span>, _y <span class="ot">=</span> <span class="fl">4.0</span>}}]</span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>t (<span class="fu">traverse</span> <span class="op">.</span> point <span class="op">.</span> x)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>(<span class="fu">traverse</span> <span class="op">.</span> point <span class="op">.</span> x)<span class="ot"> ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> f <span class="dt">Double</span>) <span class="ot">-&gt;</span> t <span class="dt">Atom</span> <span class="ot">-&gt;</span> f (t <span class="dt">Atom</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>t (<span class="fu">map</span> <span class="op">.</span> point <span class="op">.</span> x)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>(<span class="fu">map</span> <span class="op">.</span> point <span class="op">.</span> x)<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> f <span class="dt">Double</span>) <span class="ot">-&gt;</span> [<span class="dt">Atom</span>] <span class="ot">-&gt;</span> [f <span class="dt">Atom</span>]</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>t over</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="ot">over ::</span> <span class="dt">ASetter</span> s t a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>i <span class="dt">ASetter</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ASetter</span> s t a b <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Identity</span> t</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- Defined in ‘Control.Lens.Setter’</span></span></code></pre></div>
<p>필요한 정보를 찾아 <code>ASetter</code>까지 도달해서 보니 <code>map</code>을 썼을 때, <code>traverse</code>와는 달리 <code>f</code>가 리스트 컨텍스트 안에 들어가 있습니다. 일단 타입 서명들끼리 맞춰봐도 <code>map</code>은 안되는 걸 알 수 있습니다.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>t x</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ot">x ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> f <span class="dt">Double</span>) <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> f <span class="dt">Point</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>t point</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">point ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (<span class="dt">Point</span> <span class="ot">-&gt;</span> f <span class="dt">Point</span>) <span class="ot">-&gt;</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> f <span class="dt">Atom</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>t (point <span class="op">.</span> x)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>(point <span class="op">.</span> x)<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> f <span class="dt">Double</span>) <span class="ot">-&gt;</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> f <span class="dt">Atom</span></span></code></pre></div>
<p>모두 펑크터가 붙어 있긴 한데, 일단 <code>traverse</code>부터 보고 나중에 보겠습니다.<br />
위 서명을 보면 <code>(point . x)</code>는 <code>Atom</code> 하나에는 적용할 수 있는데, <code>Atom</code>이 리스트에 들어있으면 얼핏 생각하기엔 <code>traverse . point . x</code> 처럼 composition이 아니라 <code>traverse</code>의 인자로 <code>point . x</code>가 넘어가야 하지 않을까 생각이 듭니다. 일단 리스트를 해체해야 <code>point . x</code> 를 적용할 수 있을테니 말입니다.</p>
<p>그런데, <em>point 나 x는 인자가 하나인 함수가 아니라, 두 개인 함수입니다. 어떻게 컴포지션 하는 걸까요?</em></p>
<p>함수는 오른쪽 결합입니다. <code>a -&gt; b -&gt; c</code>는 <code>a -&gt; (b -&gt; c)</code>와 같고, 인자 하나 <code>a</code>를 받아서 <code>(b -&gt; c)</code>를 돌려주는 함수로 봐도 됩니다. <code>x</code>와 <code>point</code>를 괄호를 넣어 다시 써보면</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">x ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> f <span class="dt">Double</span>) <span class="ot">-&gt;</span> (<span class="dt">Point</span> <span class="ot">-&gt;</span> f <span class="dt">Point</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">point ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (<span class="dt">Point</span> <span class="ot">-&gt;</span> f <span class="dt">Point</span>) <span class="ot">-&gt;</span> (<span class="dt">Atom</span> <span class="ot">-&gt;</span> f <span class="dt">Atom</span>)</span></code></pre></div>
<p><code>x</code>, <code>point</code> 둘 다 어딘가에 바로 적용할 함수들이 아니라, 함수를 받아서 값을 바꿀 준비만 하는 함수입니다.<br />
그리고, 타입 서명을 보면 <code>x</code>의 결과와 <code>point</code>의 입력은 같은 타입이라 <code>point . x</code>가 가능합니다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Lens'</span> a b <span class="ot">=</span> <span class="kw">forall</span> f <span class="op">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f a)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ot">point ::</span> <span class="dt">Lens'</span> <span class="dt">Atom</span> <span class="dt">Point</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="ot">x     ::</span> <span class="dt">Lens'</span> <span class="dt">Point</span> <span class="dt">Double</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(.) ::</span> <span class="dt">Lens'</span> a b <span class="ot">-&gt;</span> <span class="dt">Lens'</span> b c <span class="ot">-&gt;</span> <span class="dt">Lens'</span> a c <span class="co">-- 타입 정의가 이렇다는게 아니라 이렇게 추론된다입니다.</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>point <span class="op">.</span><span class="ot"> x ::</span> <span class="dt">Lens'</span> <span class="dt">Atom</span> <span class="dt">Double</span></span></code></pre></div>
<p><code>Lens'</code> 타입과 <code>traverse</code>를 어떻게 composition할까요?</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">traverse</span><span class="ot"> ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> ( t a <span class="ot">-&gt;</span> f (t b))</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>(point <span class="op">.</span> x)<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> f <span class="dt">Double</span>) <span class="ot">-&gt;</span> (<span class="dt">Atom</span> <span class="ot">-&gt;</span> f <span class="dt">Atom</span>)</span></code></pre></div>
<p><code>a</code>, <code>b</code>를 <code>Atom</code>으로 맞추면 <code>(point . x)</code>의 결과를 <code>traverse</code>가 받을 수 있습니다. 타입은 이렇게 맞춰 컴포지션이 가능하다는 건 알겠는데, 동작이 눈에 잘 들어오지 않습니다.</p>
<p><code>traverse</code>는 펑크터로 싸인 함수를 받아서, 펑크터 안에 들어 있는 값에 적용합니다. <em>인자로 받아야 할 함수를 컴포지션으로 연결</em>하는 모양이라 눈에 금방 안들어 옵니다.
<code>(point . x)</code>는 적용할 함수가 아니라, 적용할 <em>함수를 만드는 함수</em>입니다.</p>
<p><code>(point . x)</code>는 <code>(+1)</code>을 주면 <code>Atom</code>에 적용할 수 있는 함수를 만들어주는 브로커같은 함수입니다.</p>
<p>※ 생각하는 팁<br />
각 연결된 함수들의 동작을 끝 맺으면서 다음 함수로 넘어가지 마세요. 첫 번째 함수의 동작을 끝내고, 결과를 가지고 다음 함수로 넘어가지 말고, 첫 번째 함수도 끝나지 않은 채 다음 함수로 언젠가 값을 넘길 준비를 한 상태로 읽는 게 이해하기 더 좋습니다.</p>
<div class="line-block"><code>(traverse . point . x)</code> 는 나중에 언젠가<br />
<code>Double -&gt; f Double</code> 함수를 받아 <code>x</code>가 작업해서<br />
<code>Point -&gt; f Point</code> 함수를 만들어 <code>point</code>에 넘기면<br />
<code>Atom -&gt; f Atom</code> 함수를 만들어 <code>traverse</code> 첫 번째 인자로 넣어 줄 <em>준비를 한 상태</em>입니다.</div>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>t <span class="fu">traverse</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">traverse</span><span class="ot"> ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>t (<span class="fu">traverse</span> <span class="op">.</span> point <span class="op">.</span> x)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>(<span class="fu">traverse</span> <span class="op">.</span> point <span class="op">.</span> x)<span class="ot"> ::</span> (<span class="dt">Traversable</span> t, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> f <span class="dt">Double</span>) <span class="ot">-&gt;</span> t <span class="dt">Atom</span> <span class="ot">-&gt;</span> f (t <span class="dt">Atom</span>)</span></code></pre></div>
<h2 id="쥬스-만들기에-비유해-봤습니다">쥬스 만들기에 비유해 봤습니다</h2>
<p>비유, 은유적인 예를 그다지 좋아하는 편은 아닌데, 함수가 많이 등장해 한 번 생각해 봤습니다.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span><span class="dv">1</span>)은 칼날</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>(point <span class="op">.</span> x)는 칼날을 결합할 블렌더</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>[<span class="dt">Atom1</span>, <span class="dt">Atom2</span>]는 과일 바구니</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>traverse는 작업자</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>f <span class="dt">Atom</span> 은 쥬스</span></code></pre></div>
<p>목표는 아래 모양을 만드는 겁니다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">traverse</span> ( blenderfunc ) [<span class="dt">Atom1</span>, <span class="dt">Atom2</span>]</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 작업자는 보통 (칼날이 끼워진 블렌더)를 받아서, 바구니에서 과일을 하나씩 꺼내 쥬스를 만듭니다.</span></span></code></pre></div>
<p>그런데 지금은 칼날이 빠진 블렌더가 먼저 손에 들어왔습니다.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">traverse</span> <span class="op">.</span> (point <span class="op">.</span> x)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 컴포지션이란 (point . x)에 칼날을 끼워 블렌더가 완성되면 그걸 작업자traverse에게 줄 준비를 한다는 말입니다.</span></span></code></pre></div>
<p>여기에 칼날을 넣어줘야 작업할 준비 상태가 됩니다.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">traverse</span> <span class="op">.</span> point <span class="op">.</span> x <span class="op">$</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 컴포지션은 오른쪽 우선 결합이므로 괄호를 생략할 수 있습니다. </span></span></code></pre></div>
<p>이렇게 칼날을 주면 생각하기가 편해지는데, 지금 당장 칼날은 주어지지 않습니다.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">traverse</span> <span class="op">.</span> point <span class="op">.</span> x</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 언젠가 칼날을 주면 블렌더를 완성해서 작업을 할 &quot;준비&quot;를 뜻합니다.</span></span></code></pre></div>
<p>작업자에 칼날을 넘기며 오더를 내리는 함수는 over입니다.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>over는 (작업자<span class="op">.</span> 블렌더) 칼날 과일바구니 </span></code></pre></div>
<p>이제 traverse와 컴포지션 모양이 나오는 걸 이해했으니, 다음은 펑크터로 넘어가겠습니다.</p>
<h2 id="왜-펑크터가-들어가-있을까요">왜 펑크터가 들어가 있을까요?</h2>
<h3 id="펑크터-없이-구현">펑크터 없이 구현</h3>
<p><code>Atom</code>안에 있는 <code>Point</code>, <code>Point</code> 안에 있는 <code>x</code>에 접근해서 <code>(+1)</code> 하는 작업을 하는데 왜 <code>Double -&gt; Double</code> 함수가 아니라 <code>Double -&gt; f Double</code> 함수를 받을까요? 어디서 나온 펑크터일까요? 그러지만 않았다면 <code>map</code>을 적용해도 됐을텐데요.</p>
<p>펑크터를 안쓰고 구현하면 어떤 모양이 될까 해보겠습니다.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pointN ::</span> (<span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span>) <span class="ot">-&gt;</span> <span class="dt">Atom</span> <span class="ot">-&gt;</span> <span class="dt">Atom</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>pointN k at <span class="ot">=</span> at { _point <span class="ot">=</span> k (_point at) }</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="ot">xN ::</span> (<span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>) <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>xN k po <span class="ot">=</span> po { _x <span class="ot">=</span> k (_x po) }</span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span>  pointN (xN (<span class="op">+</span><span class="dv">1</span>)) atom</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Atom</span> {_element <span class="ot">=</span> <span class="st">&quot;I am Atom&quot;</span>, _point <span class="ot">=</span> <span class="dt">Point</span> {_x <span class="ot">=</span> <span class="fl">2.0</span>, _y <span class="ot">=</span> <span class="fl">2.0</span>}}</span></code></pre></div>
<p>모양은 보기 좋게 <code>atom</code>, <code>point</code>, <code>x</code> 순서는 아니지만 작동은 잘 합니다.
물론 모양도 바꿀 수 있습니다.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(#) ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">#</span> f <span class="ot">=</span> f x</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">0</span> <span class="op">#</span></span></code></pre></div>
<p>보조 함수를 정의하고 아래와 같이 쓸 수 있습니다.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>atom <span class="op">#</span> (pointN <span class="op">.</span> xN) (<span class="op">+</span><span class="dv">1</span>)</span></code></pre></div>
<p><code>_x</code> 값을 보고 싶다면</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>atom <span class="op">#</span> _point <span class="op">#</span> _x</span></code></pre></div>
<p>아직까진 왜 펑크터가 필요한지 모르겠습니다.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> (    <span class="op">#</span> (pointN <span class="op">.</span> xN) (<span class="op">+</span><span class="dv">1</span>)    ) [atom1, atom2]</span></code></pre></div>
<p>역시 map으로 잘 작동합니다. <em>왜 펑크터가 필요한 걸까요?</em></p>
<h3 id="펑크터가-필요한-이유">펑크터가 필요한 이유</h3>
<p><a href="https://www.fpcomplete.com/haskell/tutorial/lens/">Lens Tutorial - FPComplete</a></p>
<p>위 사이트에서 답을 찾았습니다. <code>over</code>, <code>view</code> 둘 다 같은 렌즈를 받도록 하기 위해서입니다. 좀 더 풀어서 얘기하면, 특정 필드의 값을 수정할 때와, 보기만 할 때 경로를 의미하는 렌즈가 다를 필요가 없으니, 이런 직관이 들어 맞도록 <code>over</code>와 <code>view</code>가 같은 타입의 렌즈를 받아야 합니다.</p>
<p>우선 두 타입을 다르게 놓고 구현한 걸 보여 줍니다. 여기 있는 소스는 모두 fpcomplete 사이트에서 발췌했습니다.</p>
<p>일단 목표를 코드로 설명하면,</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Lens</span> s a <span class="ot">=</span> <span class="op">?</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="ot">view ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>view <span class="ot">=</span> <span class="op">?</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="ot">over ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>over <span class="ot">=</span> <span class="op">?</span></span></code></pre></div>
<p>이렇게 <code>view</code>, <code>over</code>에서 같은 <code>Lens s a</code>타입을 받도록 하는게 목표입니다.</p>
<p>일단 <code>over</code>에서 쓸 펑크터를 정의합니다.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> {<span class="ot"> runIdentity ::</span> a } <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>나중에 값을 꺼낼 때 <code>Identity</code>를 벗겨야 하긴 하지만, <code>over</code>가 받는 타입을<br />
<code>(a -&gt; a) -&gt; (s -&gt; s)</code>가 아닌<br />
<code>(a -&gt; Identity a) -&gt; (s -&gt; Identity s)</code> 타입으로 바꿔 놓습니다.<br />
의미가 달라진 건 없습니다.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensModify</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Identity</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> <span class="dt">Identity</span> s)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="ot">over ::</span> <span class="dt">LensModify</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>over lens f s <span class="ot">=</span> runIdentity (lens (<span class="dt">Identity</span> <span class="op">.</span> f) s)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="ot">personAddressL ::</span> <span class="dt">LensModify</span> <span class="dt">Person</span> <span class="dt">Address</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>personAddressL f person <span class="ot">=</span> <span class="dt">Identity</span> <span class="op">$</span> person { personAddress <span class="ot">=</span> runIdentity <span class="op">$</span> f <span class="op">$</span> personAddress person }</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- f를 먹인 후 runIdentity를 실행하는 걸로 봐서, f의 결과는 Identity 타입을 예상할 수 있습니다. </span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- Identity 없이 구현했던 버전</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="ot">personAddressL ::</span> <span class="dt">Lens</span> <span class="dt">Person</span> <span class="dt">Address</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>personAddressL <span class="ot">=</span> <span class="dt">Lens</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>  { lensGetter <span class="ot">=</span> personAddress </span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>  , lensModify <span class="ot">=</span> \f person <span class="ot">-&gt;</span> person { personAddress <span class="ot">=</span> f (personAddress person)}</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>이 경우는 크게 달라지는 건 없지만, Identity를 씌웠다 벗겼다 하기 싫으면 <code>Functor</code>로 해결해도 됩니다.<br />
그럼 <em>코드에서 Identity를 지울 수 있습니다.</em></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">personAddressL ::</span> <span class="dt">LensModify</span> <span class="dt">Person</span> <span class="dt">Address</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>personAddressL f person <span class="ot">=</span> (\address <span class="ot">-&gt;</span> person { personAddress <span class="ot">=</span> address}) <span class="op">&lt;$&gt;</span> f (personAddress person)</span></code></pre></div>
<p>이 번엔, <code>getter</code>를 구현하겠습니다.</p>
<p>이제 매직을 써서 <code>(a -&gt; a) -&gt; (s -&gt; s)</code>를 <code>s -&gt; a</code>로 바꾸는 작업을 합니다.<br />
※ 어떻게 이런 매직 같은 아이디어를 떠올렸을지 궁금합니다.</p>
<p><code>view</code>에서 쓸 펑크터를 정의합니다.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Const</span> a b <span class="ot">=</span> <span class="dt">Const</span> {<span class="ot"> getConst ::</span> a } <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p><code>const</code> 함수와 하는 일은 완전히 같은 개념입니다. <code>b</code>를 받아 버리는 역할만 합니다.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensGetter</span> s a <span class="ot">=</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> a s</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="ot">view ::</span> <span class="dt">LensGetter</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>view lens s <span class="ot">=</span> getConst (lens s)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="ot">personAddressL ::</span> <span class="dt">LensGetter</span> <span class="dt">Person</span> <span class="dt">Address</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>personAddressL person <span class="ot">=</span> <span class="dt">Const</span> (personAddress person) </span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>                     <span class="co">-- Const a b 에서 b는 뭐로 추론될까요?</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>                     <span class="co">-- LensGetter는 Person -&gt; Const Address Person</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>                     <span class="co">-- b는 따로 지정 안해줘도 서명에 따라 Person으로 추론합니다.</span></span></code></pre></div>
<p>아래 두 개의 타입을 같게 만드는 게 목표인데, 여전히 달라 보입니다.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensModify</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Identity</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> <span class="dt">Identity</span> s)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensGetter</span> s a <span class="ot">=</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> a s</span></code></pre></div>
<p>비슷한 모양을 가지도록 <code>LensGetter</code>를 다시 정의하면,<br />
(이런 아이디어가 어디서 왔을까요? 가설처럼 일단 서명을 세우고 고민한 건 아닐까요?)</p>
<p>2022.8.11 추가 - Yoneda lemma를 보면, 이런 아이디어가 나온 이유를 알 수 있다고 합니다.<br />
2024.1.7 추가 - Yoneda lemma를 <a href="../posts/2023-12-16-homFunctor.html">정리한 글</a>을 추가했습니다.<br />
</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensGetter</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Const</span> a s) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> <span class="dt">Const</span> a s)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="ot">view ::</span> <span class="dt">LensGetter</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>view lens s <span class="ot">=</span> getConst (lens <span class="dt">Const</span> s)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="co">--                           ^^^^^</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="co">--                         값 생성자</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="ot">personAddressL ::</span> <span class="dt">LensGetter</span> <span class="dt">Person</span> <span class="dt">Address</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>personAddressL f person <span class="ot">=</span> <span class="dt">Const</span> <span class="op">$</span> getConst <span class="op">$</span> f (personAddress person)</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="co">--             ^                             ^</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="co">--           Const                           |</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a><span class="co">--                        어차피 나머지가 하드 코딩인데, </span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a><span class="co">--                        그냥 Const라 써도 될 것 같지만 </span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span class="co">--                        Setter와 모양을 맞추기 위해 f로 두어야 합니다.</span></span></code></pre></div>
<p><code>LensGetter</code>타입 <code>lens</code>에 <code>Const p</code>를 넣는게 아니라, <strong>Const 값 생성자</strong>, <code>p</code>를 넣으면 어찌되나 보겠습니다.<br />
<code>(Address -&gt; Const Address Person) -&gt; Person -&gt; Const Address Person</code>에서<br />
처 번째 인자로 <code>Const</code> 값 생성자, 두 번째 인자로 <code>p</code>를 넣는다는 말입니다.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>view personalAddressL p </span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> getConst (personalAddressL <span class="dt">Const</span> p) </span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="co">--              ^^^^^^^^^^^^^^^^^^^^^^</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> getConst (<span class="dt">Const</span> <span class="op">$</span> getConst <span class="op">$</span> <span class="dt">Const</span> (personAddress p))</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="co">--    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="co">--             Const와 관련된 걸 지울 수 있게 됐습니다.</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> personAddress p</span></code></pre></div>
<p><em>Const 값 생성자</em>를 넣는 방법으로 <code>view</code> 함수를 구현했습니다.<br />
이 것도 <code>Functor</code> 스타일로 구현하면</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="ot">personAddressL ::</span> <span class="dt">LensGetter</span> <span class="dt">Person</span> <span class="dt">Address</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>personAddressL f person <span class="ot">=</span> (\address <span class="ot">-&gt;</span> person { personAddress <span class="ot">=</span> address}) <span class="op">&lt;$&gt;</span> f (personAddress person)</span></code></pre></div>
<p><em>명시적인 Const는 사라지고</em>, <code>LensModify</code> 때 정의한 함수와 같아 보이지 않나요?<br />
타입만 <code>LensGetter</code>냐, <code>LensModify</code>냐지 함수 본체body는 완전히 동일한 모양이 됐습니다.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="ot">personAddressL ::</span> <span class="dt">LensGetter</span> <span class="dt">Person</span> <span class="dt">Address</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>personAddressL f person <span class="ot">=</span> (\address <span class="ot">-&gt;</span> person { personAddress <span class="ot">=</span> address}) <span class="op">&lt;$&gt;</span> f (personAddress person)</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="ot">personAddressL ::</span> <span class="dt">LensModify</span> <span class="dt">Person</span> <span class="dt">Address</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>personAddressL f person <span class="ot">=</span> (\address <span class="ot">-&gt;</span> person { personAddress <span class="ot">=</span> address}) <span class="op">&lt;$&gt;</span> f (personAddress person)</span></code></pre></div>
<p>이 정도면 두 함수를 하나의 모양으로 표시하고, 조립할 때 쓸 실제 코드는 GHC가 골라 오도록 떠맡길 수 있습니다.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- type LensModify s a = (a -&gt; Identity a) -&gt; (s -&gt; Identity s)</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- type LensGetter s a = (a -&gt; Const a s) -&gt; (s -&gt; Const a s)</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Lens</span> s a <span class="ot">=</span> <span class="kw">forall</span> f<span class="op">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> f s)</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> {<span class="ot"> runIdentity ::</span> a }</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Const</span> a b <span class="ot">=</span> <span class="dt">Const</span> {<span class="ot"> getConst ::</span> a }</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a><span class="ot">over ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>over lens f s <span class="ot">=</span> runIdentity (lens (<span class="dt">Identity</span> <span class="op">.</span> f) s) </span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- 위의 기나긴 여정 없이 Identity가 왜 들어갔는지 알 수 있을까요?</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a><span class="ot">view ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>view lens s <span class="ot">=</span> getConst (lens <span class="dt">Const</span> s) </span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- 위의 기나긴 여정 없이 Const가 왜 들어갔는지 알 수 있을까요? </span></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a><span class="ot">personAddressL ::</span> <span class="dt">Lens</span> <span class="dt">Person</span> <span class="dt">Address</span></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>personAddressL f person <span class="ot">=</span></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>      (\address <span class="ot">-&gt;</span> person { personAddress <span class="ot">=</span> address })</span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;$&gt;</span> f (personAddress person)</span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a><span class="ot">getPersonAddress ::</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Address</span></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>getPersonAddress <span class="ot">=</span> view personAddressL</span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a><span class="ot">modifyPersonAddress ::</span> (<span class="dt">Address</span> <span class="ot">-&gt;</span> <span class="dt">Address</span>) <span class="ot">-&gt;</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Person</span></span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a>modifyPersonAddress <span class="ot">=</span> over personAddressL</span>
<span id="cb46-29"><a href="#cb46-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-30"><a href="#cb46-30" aria-hidden="true" tabindex="-1"></a><span class="ot">setPersonAddress ::</span> <span class="dt">Address</span> <span class="ot">-&gt;</span> <span class="dt">Person</span> <span class="ot">-&gt;</span> <span class="dt">Person</span></span>
<span id="cb46-31"><a href="#cb46-31" aria-hidden="true" tabindex="-1"></a>setPersonAddress address <span class="ot">=</span> modifyPersonAddress (<span class="fu">const</span> address)</span></code></pre></div>
<blockquote>
<p><strong>Q.</strong> 나중에 GHC가 타입 추론한다 해도 <code>&lt;$&gt;</code> 인스턴스만 다른 걸 가져오는 걸 텐데, 그래 봤자 <code>Const</code>의 <code>fmap</code>이나 <code>Identity</code>의 <code>fmap</code>이나 별로 다른 동작을 하지 않을텐데, 이 걸로 어떻게 <code>getter</code>, <code>setter</code> 동작을 다 표현하지?<br />
<strong>A.</strong> 추상화한 <code>personAddressL</code> 렌즈는 함수 하나를 받고, 이 함수를 <code>fmap</code>으로 안쪽에 적용하는 역할만 정해놨습니다. 어떤 일을 할지는 이 함수로 뭘 받냐에 따라 달라집니다. 동일 구조의 렌즈지만, <code>getPersonAddress</code>와 <code>modifyPersonAddress</code>는 포인트 프리로 정의되어 있습니다. <code>view</code>가 동작하면 <code>Person</code>만 받을테고, <code>over</code>가 동작하면 함수와 <code>Person</code>을 받습니다.</p>
</blockquote>
<p><code>Lens</code> 타입 안에 들어 있는 <code>Functor f</code>는<br />
<code>over</code> 안에서 인자 <code>lens</code>에 <code>runIdentity</code>를 쓰는 걸 보고 GHC가 알아서 <code>Identity</code>로 추론하고,<br />
<code>view</code> 안에서 인자 <code>lens</code>에 <code>getConst</code>를 쓰는 걸 보고 GHC가 알아서 <code>Const</code>로 추론합니다.</p>
<p><code>Lens</code> 타입 서명을 보면 <code>forall f. Functor f =&gt;</code> 나중에 어떤 펑크터든 될 수 있다고 선언했습니다. <code>personAddressL</code> 렌즈의 <code>&lt;$&gt;</code>는 <code>over</code><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>에서 쓰이는 실제 코드와 <code>view</code>에 쓰이는 실제 코드가 다른 겁니다. <code>Lens</code>를 <em>하나의 코드로 해결한다는 말이 아닙니다. 실제 가져 올 코드는 GHC가 추론하도록 열어두고, 프로그래머는 같은 코드 모양을 쓰겠다</em>가 펑크터를 쓴 목적입니다.</p>
<p>제작자가 어떻게 <code>Const</code>와 <code>Identity</code> 펑크터를 떠올렸을까 신기합니다.<br />
(추가: 카테고리 이론 Monoidal Category 부분을 보면 <code>Const</code> 펑크터와 <code>Identity</code> 펑크터를 써서 <code>Monoidal</code>로 만드는 예가 나옵니다.)</p>
<p><code>(a -&gt; a) -&gt; s -&gt; s</code> 타입을, 어떤 조건이 맞으면 <code>s -&gt; a</code> 타입이 되게 해야 됩니다.<br />
타입 서명을 <code>(a -&gt; Const a p) -&gt; (s -&gt; Const a p)</code> 이렇게 바꾸고, 이 타입의 렌즈를 가져다 쓰는 <code>view</code>쪽에서 <code>Const</code>를 적당히 적용해서 <code>s -&gt; a</code>를 뽑아내야 합니다. 서명에서 치고 들어간게 아니라, <code>Const</code> 값 생성자를 넘기는 트릭을 먼저 떠올렸을까요?</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>실제 <code>over</code> 정의</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">over ::</span> <span class="dt">ASetter</span> s t a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>over l f <span class="ot">=</span> runIdentity <span class="op">#.</span> l (<span class="dt">Identity</span> <span class="op">#.</span> f)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- 매개 변수가 3개여야 하는데 두 개면 하나만 포인트 프리로 보면 됩니다.</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>( <span class="op">#.</span> )<span class="ot"> ::</span> <span class="dt">Coercible</span> c b <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>( <span class="op">#.</span> ) _ <span class="ot">=</span> coerce (\x <span class="ot">-&gt; x ::</span> b)<span class="ot"> ::</span> <span class="kw">forall</span> a b<span class="op">.</span> <span class="dt">Coercible</span> b a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>Coercible - 단어 뜻: 강제할 수 있는
<code>coerce</code> : 같은 표현representation을 가진 타입의 값들을 런타임 오버헤드 없이 서로 안전하게 변환할 때 씁니다. 가장 간단한 경우가, <code>newtype</code>의 구체 타입에서 추상 타입으로 갈 때 <code>newtype</code> 생성자를 대신해서 쓸 수 있을 뿐 아니라, <code>newtype</code>의 리스트를 구체 타입들의 리스트로 바꿀 때 쓸 수 있다고 합니다.</p>
<p>깊이가 점점 깊어져, <code>coerce</code>는 <code>a</code>를 받아 <code>b</code>로 변환하는 함수정도로만 알고 지나 가겠습니다.</p>
<p><code>( #. )</code>는 함수 두개를 받는 컴포지션과 서명이 비슷한데, 받는 인자 순서가 반대입니다.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
