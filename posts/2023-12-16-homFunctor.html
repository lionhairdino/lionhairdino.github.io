<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - Hom Functor (스케치 중)</title>

        <meta name="description" content="lionhairdino - Hom Functor (스케치 중)" />
        <meta property="og:description" content="하스켈 함수형 프로그래밍" />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Hom Functor (스케치 중)" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-12-16-homFunctor.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

      <meta name="keywords" content="hom-set, functor">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>Hom Functor (스케치 중)</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on December 16, 2023
    
</div>

<p><a href="https://en.wikipedia.org/wiki/Hom_functor" class="uri">https://en.wikipedia.org/wiki/Hom_functor</a></p>
<h3 id="a---b-와-homab">a -&gt; b 와 Hom(a,b)</h3>
<p>일단, hom-set부터 보고 가겠습니다. <code>hom(a,b)</code>는 <code>a</code>에서 <code>b</code>로 가는 모든 모피즘의 집합이라고 합니다.</p>
<blockquote>
<p>상상<br />
Q. 그런데, <code>a -&gt; b</code>라고 표현하는 것도 어차피 <code>a</code>, <code>b</code>가 폴리모픽 아닌가요? <code>a -&gt; b</code>라고 표현해도 같은 의미인 것 같은데, 왜 또 표현을 만들었을까요?<br />
A. <code>a -&gt; b</code>가 모피즘으로 쓰이지 않고, 카테고리에서 대상object 역할을 할 때, <code>a -&gt; b</code>라고 쓰면, <code>a -&gt; b</code>에서 <code>c -&gt; d</code>로 가는 모피즘 <code>b -&gt; c</code>와 혼란스럽게 섞입니다. 이 때 <code>hom(a,b) ---- b -&gt; c ----&gt; hom(c,d)</code>로 표현하면 혼란을 줄일 수 있어서 만들어내지 않았을까 추측합니다.</p>
</blockquote>
<h3 id="hom-펑터의-hom은">Hom 펑터의 Hom은?</h3>
<p>Hom-Set은 준동형<strong>Hom</strong>omorphism 사상 집합이란 이름인데, Hom-Functor는 뭘까요?<br />
카테고리<code>C</code>를, 카테고리 <code>C</code>에 있는 모피즘들의 집합을 대상으로 가진 카테고리 <code>Set</code>로 매핑하는 펑터를 의미합니다.</p>
<blockquote>
<p>상상<br />
펑터 자체도 카테고리 구조를 보존하는 homomorphism이니, <strong>Hom</strong>을 붙이는 게 어색하지 않습니다.<br />
Q. 그럼 hom-set처럼 펑터의 집합을 의미할까요?<br />
A. 처음 <code>Hom(A, -)</code>를 봤을 때는, 이 자체가 구현처럼 보였습니다. <code>X1 -&gt; Hom(A,X1)</code> 이렇게 매핑하니까요. 그런데, 아래 정의를 보면, 이렇게 단일 펑터를 의미하는 게 아니라, “<strong>카테고리의 모든 대상 A, B에 대해</strong>”라 하니, <code>Hom(A,-)</code>라고 쓰면 <code>A</code>자체도 폴리모픽이고, <code>-</code>는 마치 람다 함수가 인자를 받는 것과 비슷합니다. 아래는 정의를 설명하기 위해 <code>A</code>를 넣어서 <code>Hom(A,-)</code>가 먼저 나와 혼동을 주는데, <code>Hom(-,-)</code>(혹은 다른 텍스트에선 <code>Hom(-,=)</code>)으로 표기해서, 인자 두 개를 받게 비워둔 폴리모픽한 모양입니다. <code>a -&gt; b</code>, <code>hom(a, b)</code>가 폴리모픽하게 여러 모피즘들을 가리킬 때 썼듯이, 한마디로 여러 펑터를 한 번에 가리키는 폴리모픽 표현입니다.</p>
<p>※ 정규 과정에 쓰이는 텍스트를 차분히 보지, 왜 상상해서 이런 말을 올리냐 할 수 있습니다. (다 보진 못하고, 2~3권 딱 해당 챕터의 도입부 정도만 보긴 했지만) 사람들이 이런 걸 별로 궁금해 하지 않는지, 짚어 주고 시작하는 텍스트를 못 찾았습니다. 그래서, 이런 상상 꼬리표가 달린 글들을 올립니다. 이런 글을 보고, 틀린 걸 발견하거나 다른 의견이 있으신 분들을 만나 이러쿵 저러쿵 하고 싶어 글을 올립니다만, 3년 넘게 운영하는 동안, 의견을 주고 받을 분을 만나기가 쉽지 않네요.</p>
</blockquote>
<p>보통 소문자 <strong>hom</strong>은 hom-set으로 쓰이고, 대문자 <strong>Hom</strong>은 hom-functor로 구별해서 쓰나 했는데, 딱히 대소문자로 가리진 않고, 위 링크 위키 텍스트에서 <code>Hom(-,-)</code>, <code>Hom(A,-)</code>처럼 <code>-</code>가 들어가 있으면 hom-functor, <code>-</code>가 없이 <code>Hom(A,B)</code>면 hom-set을 가리키는 걸로 보입니다.</p>
<p><code>C</code>에 있는 <strong>모든 대상</strong> <code>A</code>, <code>B</code>들에 대해 <strong>Set</strong>으로 보내는 두 펑터를 아래와 같이 정의합니다.</p>
<h3 id="hom-a---c---set">Hom (A, -): C -&gt; Set</h3>
<p><code>Hom(A, -)</code>는 마치 하스켈 타입 생성자 같기도 하고, 함수를 인자로 받아, 가지고 있는 함수를 변형하는 고차 함수 같기도 합니다. 쓰고나서 보니, 펑터 인스턴스가 있는 타입 생성자와 <code>fmap</code>, 즉 펑터입니다.</p>
<p><code>Hom(A, -)</code>에서, 설명을 위해 <code>A</code>는 일단 고정한 채로<br />
아래와 같이 카테고리<code>C</code>에 있는 <code>X1</code>,<code>X2</code>,<code>...</code> 대상을 <code>Set</code>카테고리의 대상 hom-Set에 매핑합니다.<br />
<code>X1</code> —&gt; <code>Hom(A,X1)</code><br />
<code>X2</code> —&gt; <code>Hom(A,X2)</code><br />
…<br />
모든 <code>A</code>라 했으니,<br />
<code>X1</code> —&gt; <code>Hom(X1,X1)</code><br />
<code>X2</code> —&gt; <code>Hom(X1,X2)</code><br />
…<br />
이런 식으로 많은 수의 펑터를 의미합니다.</p>
<p><code>Hom</code>펑터는 <strong>펑터</strong>니까 모피즘도 매핑해야 합니다.<br />
<code>f:X -&gt; Y</code> —&gt; <code>Hom(A,</code><strong>f</strong><code>): Hom(A,</code><strong>X</strong><code>) -&gt; Hom(A,</code><strong>Y</strong><code>)</code><br />
그런데, 여기 눈여겨 봐야할 성질이 하나 숨어 있습니다. 펑터는
- <code>f</code>를 변형한다고 보기도 하고,
- 새로운 구조 안에 있는 대상에 <code>f</code>를 적용한다고 해석하기도 합니다.</p>
<p><code>A-&gt;</code><strong>X</strong>를 변환해서 <code>A-&gt;</code><strong>Y</strong>가 되게 하려면, <code>A-&gt;</code><strong>X</strong> 다음에 <code>f:</code> <strong>X</strong><code>-&gt;</code><strong>Y</strong>를 합성(<strong>X - &gt;Y ∘ A - &gt;X</strong>)하면 됩니다. 또는 새로운 구조 <code>A-&gt;</code><strong>X</strong> 안 쪽에 있는 <strong>X</strong>에 <code>f</code>를 적용한다고 봐도 자연스럽게 <strong>Y</strong>가 나옵니다.
하나의 <strong>hom-Set</strong> <code>Hom(A,X)</code>에 들어 있는 모피즘(:<strong>A -&gt; X</strong>)을 <code>g1</code>, <code>g2</code>, <code>...</code> 이라 하면, <strong>Hom-Functor</strong> <code>Hom(A,-)</code>는 이 모피즘들을 각 각 <code>f:</code><strong>X -&gt; Y</strong>와 합성한 모양이 됩니다. 결국 <strong>hom-set</strong> <code>Hom(A,Y)</code>에 있는 모피즘(:<strong>A -&gt; Y</strong>) <code>f∘g1</code>, <code>f∘g2</code>, <code>...</code>로 매핑하면 됩니다.</p>
<p>※ 모피즘 매핑을 보면 <code>X</code> <strong>-&gt;</strong> <code>Y</code>에 펑터를 적용한 결과가 <code>...X...</code> <strong>-&gt;</strong> <code>...Y...</code> 그대로여서 covariant[^1] 펑터라 합니다.
[^1]: 참고 - <a href="../posts/2022-11-10-coContraVarint.html">Covariant, Contravariant, Positive, Negative</a></p>
<p>(※ 보통 카테고리 이론에서는 대상을 구조가 없는, 아무 성질도 없는 점 쯤으로 생각합니다. 그런데, 만일 <code>Hom(A,-)</code> 펑터를 적용하니, 위에 같은 합성 성질이 나왔다면, 대상이 <code>A -&gt; X</code>를 가지고 있다고 유추할 수 있을 것 같습니다. 이렇게 생각하는 게 맞는지 모르겠습니다.)</p>
<h3 id="hom---b-c---set">Hom (-, B) : C -&gt; Set</h3>
<p><code>B</code>는 고정입니다.<br />
<code>Hom(-,B)</code>는 아래와 같이 매핑하는 펑터입니다.<br />
<code>X1</code> —&gt; <code>Hom(X1,B)</code><br />
<code>X2</code> —&gt; <code>Hom(X2,B)</code><br />
…<br />
모든 <code>B</code>라 했으니,<br />
<code>X1</code> —&gt; <code>Hom(X1,X1)</code><br />
<code>X2</code> —&gt; <code>Hom(X2,X1)</code><br />
…<br />
모피즘 매핑을 보겠습니다.<br />
<code>h:X -&gt; Y</code> —&gt; <code>Hom(h,B): Hom(X,B) -&gt; Hom(Y,B) -- ???</code><br />
이 번엔 <code>X</code>가 입력 위치에 있으니 <code>X-&gt;Y</code>를 먼저 하고, <code>X-&gt;B</code>를 하면 될 것 처럼 보이지만, <code>X-&gt;Y</code>를 먼저 적용 후 하면 결과는 <code>Y</code>입니다. 펑터로 변환된 세상에서 <code>X</code>를 먼저 받는다면, <code>h</code>를 적용할 길이 없습니다. 변환된 세상에선 <code>Y</code>를 먼저 받아야 합니다.<br />
<code>h:X -&gt; Y</code> —&gt; <code>Hom(</code><strong>h</strong><code>,B): Hom(</code><strong>Y</strong><code>,B) -&gt; Hom(</code><strong>X</strong><code>,B)</code></p>
<p>※ 모피즘 매핑을 보면 <code>X</code> <strong>-&gt;</strong> <code>Y</code>에 펑터를 적용한 결과가 <code>...Y...</code> <strong>-&gt;</strong> <code>...X...</code>여서 contravariant 펑터입니다.</p>
<p><code>Hom(X,B)</code>는 <code>g1</code>, <code>g2</code>, … 모피즘 집합입니다. 이 모피즘들을 각각 <code>h</code>에 합성합니다. 결국 <code>Hom(B,Y)</code>에 있는 함수 <code>g1∘h</code>, <code>g2∘h</code>, <code>...</code>로 매핑됩니다.</p>
<blockquote>
<p>Q. 정의 결과가 모피즘 매핑할 때는 <code>C^op</code>에 있는 모피즘과 매핑하게 되는데, 그럼 C^op -&gt; Set 으로 두어야 위에 Hom (A, -)이 소속해 있는 Set과 같아지는 것 아닌가? <span class="citation" data-cites="todo">@todo</span>
### Natural Manner
첫 번째 인자를 고정하면 covariant 펑터를 주고, 두 번째 인자를 고정하면 contravariant 펑터를 줍니다.</p>
</blockquote>
<p><code>Hom(A, -)</code>, <code>Hom(-, B)</code>는 natural manner와 관계 있습니다. <code>f: B -&gt; B'</code>, <code>h:A' -&gt; A</code>에서 아무거나 짝지으면</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>Hom(A,B) -----Hom(h,B)-----&gt; Hom(A',B)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   |                            |</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   | Hom(A,f)                   | Hom(A',f)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>   |                            |</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>   V                            V</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>Hom(A,B') ----Hom(h,B')----&gt; Hom(A',B')</span></code></pre></div>
<p>양 쪽 경로 모두 <code>g:A -&gt; B</code>를 <code>f∘g∘h:A' -&gt; B'</code>로 보냅니다. 이 가환이 갖는 의미가 뭘까요? covariant 펑터 <code>Hom(A,-)</code>를 적용한 후에 contravariant 펑터 <code>Hom(-,B)</code>를 적용하나, contravariant 펑터를 적용 후 covariant 펑터를 적용하나 결과가 같습니다.</p>
<p>두 펑터를 합친 <code>Hom(-, -)</code>는 바이펑터bifunctor입니다. <code>C</code>카테고리에서 한 번만 뽑는게 아니라, 두 번 뽑아아야 하니 <code>C × C</code>에서 <code>Set</code>으로 가는 바이펑터인데, 첫 번째 인자를 고정하면 covariant하고, 두 번째 인자를 고정하면 contravariant하니</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Hom(-, -): C^op × C -&gt; Set</span></code></pre></div>
<p><code>C^op</code>는 <code>C</code>의 화살표를 모두 뒤집어 놓은 반대opposite 카테고리입니다.</p>
<blockquote>
<p><span class="citation" data-cites="todo">@todo</span>:
Q. <code>Hom(-,B)</code>를 이미 contravariant로 정의했는데, 또 뒤집으면 안되지 않나?<br />
Q. <code>C^op × C</code>가 아니라 <code>C × C^op</code> 아닌가?</p>
</blockquote>
<p>※ 바이펑터는 적용할 대상도 2튜플로 받고, 결과도 2튜플로 내뱉습니다.<br />
<code>C^op × C</code> product 카테고리에서 대상 <code>(X, Y)</code>을 가져오면,<br />
<code>(X, Y)</code> —바이펑터(A를 고정한 펑터 Hom(A,-), B를 고정한 펑터 Hom(-,B)—&gt; <code>(Hom(A,X), Hom(Y,B))</code><br />
모피즘은<br />
<code>(f, h)</code> —바이펑터(A를 고정한 펑터 Hom(A,-), B를 고정한 펑터 Hom(-,B)—&gt; <code>(Hom(A,f), Hom(h,B))</code><br />
</p>
<p>C(a, x) ~ x^a ~ a -&gt; x
a -&gt; - = F</p>
<p>참고 - <a href="https://www.johndcook.com/blog/2019/08/06/hom-functors/%3E">Hom functors and a glimpse of Yoneda</a> : 혼란스럽게 쓰이는 기호들도 짚어주고, 다른 배경 지식을 최소한 요구하며 설명합니다. 제 입맛에는 딱인 글입니다.</p>
<p><code>H^A = Hom(A, -)</code> covariant 펑터
<code>H_A = Hom(-, A)</code> contravariant 펑터
※ <code>^A</code>는 윗 첨자, <code>_A</code>는 아래 첨자</p>
<blockquote>
<p>상상 <span class="citation" data-cites="todo">@todo</span><br />
<strong>C와 D가 같은가</strong>를 볼 때, <code>C</code>와 <code>D</code>의 대상을 사람이 눈으로 확인하듯 보는 게 아니라, <code>C</code>와 <code>D</code> 사이를 오가는 펑터가 <code>id</code>펑터들과 같은가를 봤다. 둘이 같은가를 표현하는데, 대상은 등장하지 않는다. <strong>펑터만 보면 된다.</strong> 어떤 펑터와 어떤 펑터가 닮았는지, 같은지를 보면 된다.</p>
<p>대상 <code>A</code>의 정체성?은 뭘까? 대상 <code>A</code>는 무엇이다라고 결정하는 게 사실은 <strong>주변과의 관계</strong>로 결정된다. Hom펑터는 이 걸 뜻하는 것 같다. <code>A</code>는 <code>Hom(A,-)</code>라고 표현할 수도 있다. 이 펑터로 적용해서 도달한 세계(<code>Set</code>)는 이 전 세계처럼 <code>A</code>를 볼 일이 없어졌다. <code>Set</code>에서도 이 전 카테고리에 있던 모피즘도 그대로 매핑되어야 한다. <code>f:X -&gt; Y</code>의 매핑은 <code>Hom(A,f): Hom(A,X) -&gt; Hom(A,Y)</code>다. A가 어떤 대상이어야 되는 게 아니라, <code>C</code>카테고리에서 뽑은 임의의 대상 하나다.</p>
</blockquote>
<p>C-&gt;D인 F펑터와 G펑터가 Naturality condition(Square)을 만족한다고 하면, 이 걸로 뭘 알 수 있을까? F와 G 모두 C의 구조를 보존한채로 D에 상image을 만든다. 이 두 상은 구조가 같다.</p>
<p><span class="citation" data-cites="todo">@todo</span>
Sat Dec 16 01:37:37 AM KST 2023</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
