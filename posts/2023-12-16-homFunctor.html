<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - Hom Functor (스케치 중)</title>

        <meta name="description" content="lionhairdino - Hom Functor (스케치 중)" />
        <meta property="og:description" content="하스켈 함수형 프로그래밍" />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Hom Functor (스케치 중)" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-12-16-homFunctor.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

      <meta name="keywords" content="hom-set, functor">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>Hom Functor (스케치 중)</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on December 16, 2023
    
</div>

<p><a href="https://en.wikipedia.org/wiki/Hom_functor" class="uri">https://en.wikipedia.org/wiki/Hom_functor</a></p>
<h2 id="생각-스트레칭">생각 스트레칭</h2>
<p>삼형제 <code>A</code>,<code>B</code>,<code>C</code>가 있을 때,<br />
“(가) <code>A</code>보다는 작고”, “(나) <code>C</code>보다는 크다”<br />
는 두 조건을 모두 만족하려면 <code>B</code>뿐이 없습니다. (가), (나) 모피즘을 이용해 <code>B</code>를 정의했습니다. (<code>B</code>를 특정지을 수 있습니다.)</p>
<p>다른 것들과 어떤 관계를 맺고 있는지 충분히 알면, 범인을 단정지을 수 있습니다.!</p>
<p>※ product 어원: pro 앞으로, duct 이끌다.</p>
<h2 id="a---b-와-homab">a -&gt; b 와 Hom(a,b)</h2>
<p>일단, hom-set부터 보고 가겠습니다. <code>hom(a,b)</code>는 <code>a</code>에서 <code>b</code>로 가는 모든 모피즘의 집합이라고 합니다.</p>
<blockquote>
<p>상상<br />
<strong>Q</strong>. 그런데, <code>a -&gt; b</code>라고 표현하는 것도 어차피 <code>a</code>, <code>b</code>가 폴리모픽 아닌가요? <code>a -&gt; b</code>라고 표현해도 같은 의미인 것 같은데, 왜 또 표현을 만들었을까요?<br />
<strong>A</strong>. <code>a -&gt; b</code>가 모피즘으로 쓰이지 않고, 카테고리에서 대상object 역할을 할 때, <code>a -&gt; b</code>라고 쓰면, <code>a -&gt; b</code>에서 <code>c -&gt; d</code>로 가는 모피즘 <code>b -&gt; c</code>와 혼란스럽게 섞입니다. 이 때 <code>hom(a,b) ---- b -&gt; c ----&gt; hom(c,d)</code>로 표현하면 혼란을 줄일 수 있어서 만들어내지 않았을까 추측합니다.</p>
</blockquote>
<h2 id="hom-펑터의-hom은">Hom 펑터의 Hom은?</h2>
<p>Hom-Set은 준동형<strong>Hom</strong>omorphism 사상 집합이란 이름인데, Hom-Functor는 뭘까요?<br />
카테고리<code>C</code>를, 카테고리 <code>C</code>에 있는 모피즘들의 집합을 대상으로 가진 카테고리 <code>Set</code>로 매핑하는 펑터를 의미합니다.</p>
<blockquote>
<p>상상<br />
펑터 자체도 카테고리 구조를 보존하는 homomorphism이니, <strong>Hom</strong>을 붙이는 게 어색하지 않습니다.<br />
<strong>Q</strong>. 그럼 hom-set처럼 펑터의 집합을 의미할까요?<br />
<strong>A</strong>. 처음 <code>Hom(A, -)</code>를 봤을 때는, 이 자체가 구현처럼 보였습니다. <code>X1 -&gt; Hom(A,X1)</code> 이렇게 매핑하니까요. <code>A</code>는 카테고리 <code>C</code>에 있는 오브젝트 <code>X1</code>, <code>X2</code>, … 중 하나를 뽑아 홈펑터를 만듭니다. 그런데, <code>A</code>는 모든 오브젝트라 하니, 각각의 오브젝트에 대해 <code>Hom(X1, -)</code>, <code>Hom(X2, -)</code>, …를 의미합니다. 폴리모픽 펑터 표현으로 펑터 집합을 표현합니다. (검증 필요)</p>
<p>※ 정규 과정에 쓰이는 텍스트를 차분히 보지, 왜 상상해서 이런 말을 올리냐 할 수 있습니다. (다 보진 못하고, 2~3권 딱 해당 챕터의 도입부 정도만 보긴 했지만) 사람들이 이런 걸 별로 궁금해 하지 않는지, 짚어 주고 시작하는 텍스트를 못 찾았습니다. 그래서, 이런 상상 꼬리표가 달린 글들을 올립니다. 이런 글을 보고, 틀린 걸 발견하거나 다른 의견이 있으신 분들을 만나 이러쿵 저러쿵 하고 싶어 글을 올립니다만, 3년 넘게 운영하는 동안 의견을 주고 받을 분을 만나기가 쉽지 않네요.</p>
</blockquote>
<p>보통 소문자 <strong>hom</strong>은 hom-set으로 쓰이고, 대문자 <strong>Hom</strong>은 hom-functor로 구별해서 쓰나 했는데, 딱히 대소문자로 가리진 않고, 위 링크 위키 텍스트에서 <code>Hom(-,-)</code>, <code>Hom(A,-)</code>처럼 <code>-</code>가 들어가 있으면 hom-functor, <code>-</code>가 없이 <code>Hom(A,B)</code>면 hom-set을 가리키는 걸로 보입니다.</p>
<p><code>C</code>에 있는 <strong>모든 대상</strong> <code>A</code>, <code>B</code>들에 대해 <strong>Set</strong>으로 보내는 두 펑터를 아래와 같이 정의합니다.</p>
<h2 id="hom-a---c---set">Hom (A, -): C -&gt; Set</h2>
<p><code>Hom(A, -)</code>는 마치 하스켈 타입 생성자 같기도 하고, 함수를 인자로 받아, 가지고 있는 함수를 변형하는 고차 함수 같기도 합니다. 쓰고나서 보니, 펑터 인스턴스가 있는 타입 생성자와 <code>fmap</code>, 즉 펑터입니다.</p>
<p><code>Hom(A, -)</code>에서, 설명을 위해 <code>A</code>는 일단 고정한 채로<br />
아래와 같이 카테고리<code>C</code>에 있는 <code>X1</code>,<code>X2</code>,<code>...</code> 대상을 <code>Set</code>카테고리의 대상 hom-Set에 매핑합니다.<br />
<code>X1</code> —&gt; <code>Hom(A,X1)</code><br />
<code>X2</code> —&gt; <code>Hom(A,X2)</code><br />
…<br />
모든 <code>A</code>라 했으니, <code>A</code>가 <code>X1</code>인 홈펑터, <code>X2</code>인 홈펑터, …들을 정의 합니다.<br />
</p>
<p><code>Hom</code>펑터는 <strong>펑터</strong>니까 모피즘도 매핑해야 합니다.<br />
<code>f:X -&gt; Y</code> —&gt; <code>Hom(A,</code><strong>f</strong><code>): Hom(A,</code><strong>X</strong><code>) -&gt; Hom(A,</code><strong>Y</strong><code>)</code><br />
그런데, 여기 눈여겨 봐야할 성질이 하나 숨어 있습니다. 펑터는</p>
<ul>
<li><code>f</code>를 변형한다고 보기도 하고, <code>(a -&gt; b) -&gt; (f a -&gt; f b)</code></li>
<li>새로운 구조 안에 있는 대상에 <code>f</code>를 적용한다고 해석하기도 합니다. <code>(a -&gt; b) -&gt; f a -&gt; f b</code></li>
</ul>
<blockquote>
<p>주의: 함수 안에 들어 있는 걸 바꾸는 건 다른 문제입니다. 한참 헤맸는데, <code>Maybe x</code>일 때 <code>x</code>에 함수를 적용할 순 있어도, <code>Maybe (x -&gt; y)</code>일 때 <code>x</code>에 <code>f</code>를 적용하는 건 다른 문제입니다. 함수를 깨버리고 들어갈 수가 없습니다. 함수를 변형할 수는 없고, 전에 합성을 하든, 후에 합성을 하는 수 밖에 없습니다.</p>
</blockquote>
<p><code>A-&gt;</code><strong>X</strong>를 변환해서 <code>A-&gt;</code><strong>Y</strong>가 되게 하려면, <code>A-&gt;</code><strong>X</strong> 다음에 <code>f:</code> <strong>X</strong><code>-&gt;</code><strong>Y</strong>를 합성(<strong>X - &gt;Y ∘ A - &gt;X</strong>)하면 됩니다. 또는 새로운 구조 <code>A-&gt;</code><strong>X</strong> 안 쪽에 있는 <strong>X</strong>에 <code>f</code>를 적용하는 것이 아니라, <code>A-&gt;X</code>의 결과로 함수를 빠져나온 <code>X</code>에 <code>f</code>를 적용합니다.</p>
<p>하나의 <strong>hom-Set</strong> <code>Hom(A,X)</code>에 들어 있는 모피즘(:<strong>A -&gt; X</strong>)을 <code>g1</code>, <code>g2</code>, <code>...</code> 라 하면, <strong>Hom-Functor</strong> <code>Hom(A,-)</code>는 이 모피즘들을 각 각 <code>f:</code><strong>X -&gt; Y</strong>와 합성한 모양이 됩니다. 결국 <strong>hom-set</strong> <code>Hom(A,Y)</code>에 있는 모피즘(:<strong>A -&gt; Y</strong>) <code>f∘g1</code>, <code>f∘g2</code>, <code>...</code>로 매핑하면 됩니다.</p>
<p>※ 모피즘 매핑을 보면 <code>X</code> <strong>-&gt;</strong> <code>Y</code>에 펑터를 적용한 결과가 <code>...X...</code> <strong>-&gt;</strong> <code>...Y...</code> 그대로여서 covariant 펑터라 합니다.</p>
<p>(※ 보통 카테고리 이론에서는 대상을 구조가 없는, 아무 성질도 없는 점 쯤으로 생각합니다. 그런데, 만일 <code>Hom(A,-)</code> 펑터를 적용하니, 위에 같은 합성 성질이 나왔다면, 대상이 <code>A -&gt; X</code>를 가지고 있다고 유추할 수 있을 것 같습니다. 이렇게 생각하는 게 맞는지 모르겠습니다.)</p>
<h2 id="hom---b-c---set">Hom (-, B) : C -&gt; Set</h2>
<p><code>B</code>는 일단 고정한 채로<br />
<code>Hom(-,B)</code>는 아래와 같이 매핑하는 펑터입니다.<br />
<code>X1</code> —&gt; <code>Hom(X1,B)</code><br />
<code>X2</code> —&gt; <code>Hom(X2,B)</code><br />
…<br />
모든 <code>B</code>라 했으니, <code>B</code>가 <code>X1</code>인 홈펑터, <code>X2</code>인 홈펑터,… 들을 정의합니다.<br />
모피즘 매핑을 보겠습니다.</p>
<ol type="1">
<li><code>h:X -&gt; Y</code> —&gt; <code>Hom(</code><strong>h</strong><code>,B): Hom(</code><strong>X</strong><code>,B) -&gt; Hom(</code><strong>Y</strong><code>,B) -- ???</code><br />
</li>
<li><code>h:X -&gt; Y</code> —&gt; <code>Hom(</code><strong>h</strong><code>,B): Hom(</code><strong>Y</strong><code>,B) -&gt; Hom(</code><strong>X</strong><code>,B)</code><br />
(1)처럼 Covariant하게 정의하면 될 것 같은데, (2)로 Contravariant하게 정의하고 있습니다. <strong><em>왜 이렇게 정의했을까요?</em></strong> (1)이 뭐가 문제인지 보기 위해, (1)로 정의해 보겠습니다. <code>X-&gt;B</code> 모피즘을 <code>Y-&gt;B</code>로 바꾸려 합니다. 어떤 변환 과정을 거치든 시작이 <code>Y</code>이고 끝이 <code>B</code>입니다. <code>X-&gt;Y</code>와 <code>X-&gt;B</code>만 가지고선 <strong>시작에 Y</strong>를 둘 방법이 없습니다. 끝에 <code>B</code>를 둘 수 있는 <code>X-&gt;B</code>는 있으니, <code>Y-&gt;X</code>가 있으면 딱입니다. <code>h^op:Y-&gt;X</code>가 필요합니다. <code>X-&gt;B</code>모피즘을 <code>g1</code>, <code>g2</code>, …라 하면, <code>h^op∘g1</code>, <code>h^op∘g2</code>, …와 매핑합니다. 결국, 함수의 입력 쪽에 <code>X</code>가 있다면 Contravariant한 정의만 가능합니다.</li>
</ol>
<blockquote>
<p>Contravariant 속 뜻[^1]<br />
<code>f: x -&gt; y</code>에서 <code>x</code>는 <code>f</code>만으론 정해진 값이 아닙니다. <code>f</code>는 누군가가 <code>x</code>를 준다면 <code>y</code>값을 준다는 <code>y</code>예정값일 뿐입니다. 여기에 누군가 <code>x</code>를 줘야지만 <code>A</code>를 돌려주는 <code>x -&gt; A</code>만 있다면, 아무도 <code>f</code>에 줄 <code>x</code>값을 가지고 있지 않습니다. 우리 손엔 <code>x</code>를 결과로 내어주는 <code>some -&gt; x</code>로 <code>x</code>예정값이 있어야만 합니다. 그러면 <code>some -&gt; x</code>와 <code>x -&gt; y</code>를 붙일 수 있습니다. 적어도 <code>x</code>예정값 하나는 들고 있으니까요. <strong><em>x-&gt;y는 무슨일이 생겨도 x값은 되지 않습니다. y값이 될 뿐입니다.</em></strong><br />
만일, <code>g: (x -&gt; y) -&gt; y</code>라면 어떻게 될까요? 나중에 <code>(x-&gt;y)</code>인 함수를 받으면 <code>y</code>값을 돌려준다니, 이미 어딘가에 <code>x</code>를 가지고 있어야만(혹은 생성해야만) 합니다. 이럴 땐 Covariant하다라고 합니다.<br />
참고 - <a href="../posts/2022-11-10-coContraVarint.html">Covariant, Contravariant, Positive, Negative</a></p>
</blockquote>
<p>※ 모피즘 매핑을 보면 <code>X</code> <strong>-&gt;</strong> <code>Y</code>에 펑터를 적용한 결과가 방향이 뒤집어진 <code>...Y...</code> <strong>-&gt;</strong> <code>...X...</code>여서 contravariant 펑터입니다. 입력이었던 것이 출력이 되고, 출력이었던 것이 입력이 되었습니다.</p>
<p><code>Hom(Y,B)</code>는 <code>g1</code>, <code>g2</code>, … 모피즘 집합입니다. 이 모피즘들을 각각 <code>h</code>에 합성합니다. 결국 <code>Hom(X,B)</code>에 있는 함수 <code>g1∘h</code>, <code>g2∘h</code>, <code>...</code>로 매핑됩니다.</p>
<p>※ “<code>C × C -&gt; Set</code>인 바이펑터로, 첫 번째 인자에 contravariant하고, 두 번째 인자에 covariant하다”라고 말로 쓰거나, <code>C^op × C -&gt; Set</code> 이렇게만 표기하거나 하는 것 같습니다 (검증필요)</p>
<h3 id="natural-manner">Natural Manner</h3>
<p>첫 번째 인자를 고정하면 covariant 펑터를 주고, 두 번째 인자를 고정하면 contravariant 펑터를 줍니다. (위 설명하고 헛갈리지 말아야 합니다. variant한 값이 어디 있는지를 봐야 합니다.)</p>
<p><code>Hom(A, -)</code>, <code>Hom(-, B)</code>는 다음과 같은 가환 다이어그램이 성립합니다. <code>f: B -&gt; B'</code>, <code>h:A' -&gt; A</code>에서 아무거나 짝지으면</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>Hom(A,B) -----Hom(h,B)-----&gt; Hom(A',B)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   |                            |</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   | Hom(A,f)                   | Hom(A',f)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>   |                            |</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>   V                            V</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>Hom(A,B') ----Hom(h,B')----&gt; Hom(A',B')</span></code></pre></div>
<p>양 쪽 경로 모두 <code>g:A -&gt; B</code>를 <code>f∘g∘h:A' -&gt; B'</code>로 보냅니다. 이 가환이 갖는 의미가 뭘까요? covariant 펑터 <code>Hom(A,-)</code>를 적용한 후에 contravariant 펑터 <code>Hom(-,B)</code>를 적용하나, contravariant 펑터를 적용 후 covariant 펑터를 적용하나 결과가 같습니다. 이 걸 Natural Manner라고 부릅니다.</p>
<p>두 펑터를 합친 <code>Hom(-,-)</code>는 바이펑터bifunctor입니다. <code>C</code>카테고리에서 한 번만 뽑는게 아니라, 두 번 뽑아아야 하니 <code>C × C</code>에서 <code>Set</code>으로 가는 바이펑터인데, 첫 번째 인자를 고정하면 covariant하고, 두 번째 인자를 고정하면 contravariant하니</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Hom(-,-): C^op × C -&gt; Set</span></code></pre></div>
<p><code>C^op</code>는 <code>C</code>의 화살표를 모두 뒤집어 놓은 반대opposite 카테고리입니다.</p>
<p>※ 바이펑터는 적용할 대상도 2튜플로 받고, 결과도 2튜플로 내뱉습니다.<br />
<code>C^op × C</code> product 카테고리에서 대상 <code>(X, Y)</code>을 가져오면,<br />
<code>(X, Y)</code> —바이펑터(A를 고정한 펑터 Hom(A,-), B를 고정한 펑터 Hom(-,B)—&gt; <code>(Hom(A,X), Hom(Y,B))</code><br />
모피즘은<br />
<code>(f, h)</code> —바이펑터(A를 고정한 펑터 Hom(A,-), B를 고정한 펑터 Hom(-,B)—&gt; <code>(Hom(A,f), Hom(h,B))</code></p>
<p>참고 - <a href="https://www.johndcook.com/blog/2019/08/06/hom-functors/%3E">Hom functors and a glimpse of Yoneda</a> : 혼란스럽게 쓰이는 기호들도 짚어주고, 다른 배경 지식을 최소한 요구하며 설명합니다.</p>
<p><code>H^A = Hom(A, -)</code> covariant 펑터<br />
<code>H_A = Hom(-, A)</code> contravariant 펑터<br />
※ <code>^A</code>는 윗 첨자, <code>_A</code>는 아래 첨자</p>
<blockquote>
<p>상상 <span class="citation" data-cites="todo">@todo</span><br />
<strong>C와 D가 같은가</strong>를 볼 때, <code>C</code>와 <code>D</code>의 대상을 사람이 눈으로 확인하듯 보는 게 아니라, <code>C</code>와 <code>D</code> 사이를 오가는 펑터가 <code>id</code>펑터들과 같은가를 봤습니다. 둘이 같은가를 표현하는데, 대상은 등장하지 않습니다. <strong>펑터만 보면 됩니다.</strong> 어떤 펑터와 어떤 펑터가 닮았는지, 같은지를 보면 됩니다. identity를 확인하는데, 주변과의 관계만 얘기하고 있습니다.</p>
<p>대상 <code>A</code>의 정체성?은 뭘까요? 대상 <code>A</code>는 무엇이다라고 결정하는 게 사실은 <strong>주변과의 관계</strong>로 결정됩니다. 홈펑터는 이 걸 뜻하는 것 같습니다. <code>A</code>는 <code>Hom(A,-)</code>, <code>Hom(-,A)</code>라고 표현할 수도 있습니다. 이 펑터로 적용해서 도달한 세계(<code>Set</code>)는 이 전 세계처럼 <code>A</code>를 볼 일이 없어졌습니다. <code>Set</code>에도 이 전 카테고리에 있던 모피즘이 그대로 매핑되어야 합니다. <code>f:X -&gt; Y</code>의 매핑은 <code>Hom(A,f): Hom(A,X) -&gt; Hom(A,Y)</code>입니다.</p>
</blockquote>
<p>C-&gt;D인 F펑터와 G펑터가 Naturality condition(Square)을 만족한다고 하면, 이 걸로 뭘 알 수 있을까? F와 G 모두 C의 구조를 보존한채로 D에 상image을 만든다. 이 두 상은 <strong><em>구조가 같다.</em></strong></p>
<p><span class="citation" data-cites="todo">@todo</span>
Mon Dec 18 03:02:04 AM KST 2023</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
