<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - 홈펑터Hom Functor와 요네다 보조 정리Yoneda lemma(작성 중)</title>

        <meta name="description" content="다른 수학 배경 지식 없이, 오로지 카테고리 이론으로만 풀어 나갔습니다. 최종 목표는 Lens에 Yoneda lemma 아이디어를 어떤식으로 적용했는지를 보는 것입니다." />
        <meta property="og:description" content="다른 수학 배경 지식 없이, 오로지 카테고리 이론으로만 풀어 나갔습니다. 최종 목표는 Lens에 Yoneda lemma 아이디어를 어떤식으로 적용했는지를 보는 것입니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="홈펑터Hom Functor와 요네다 보조 정리Yoneda lemma(작성 중)" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-12-16-homFunctor.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

      <meta name="keywords" content="hom-set, functor, hom-functor, 홈펑터, 요네다 레마, 요네다 렘마, 요네다 레머, 요네다 보조 정리, Covariant, Contravariant, Lens">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>홈펑터Hom Functor와 요네다 보조 정리Yoneda lemma(작성 중)</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on December 16, 2023
    
</div>

<p>※ 블로그 글의 편집 결과가 그런대로 볼만하게 나오는 게 오히려 문제입니다. 꼭, 정확한 지식인양 보일 수가 있거든요. (조금이라도 검증을 통과하면 그림들을 다시 그리겠습니다. 지금은 허술한 그림이 오히려 목적에 맞습니다.) 아래 글은 정확한 내용이라 검증되지 않았습니다. 다른 텍스트를 보고 아직 이해가 안간 분들과, 뭐가 맞는지 상의하기 위해 올리는 글입니다.</p>
<p><a href="https://en.wikipedia.org/wiki/Hom_functor" class="uri">https://en.wikipedia.org/wiki/Hom_functor</a></p>
<h2 id="생각-스트레칭">생각 스트레칭</h2>
<ol type="1">
<li>삼형제 <code>A</code>,<code>B</code>,<code>C</code>(순서는 형부터)가 있을 때,<br />
“(가) <code>A</code>보다는 작고”, “(나) <code>C</code>보다는 크다”<br />
는 두 조건을 모두 만족하려면 <code>B</code>뿐이 없습니다. (가), (나) 모피즘을 이용해 <code>B</code>를 정의했습니다. (<code>B</code>를 특정지을 수 있습니다.)</li>
</ol>
<figure>
<img src="../images/usingMorphism.jpg" alt="삼각형을 모피즘으로 가리키는 방법" /><figcaption aria-hidden="true">삼각형을 모피즘으로 가리키는 방법</figcaption>
</figure>
<p>위 그림의 사각형을 완성시킬 무엇 = 삼각형. 삼각형 모양을 잘라 낸 어떤 도형으로도 삼각형을 가리킬 수 있습니다.</p>
<ol start="2" type="1">
<li><code>(A-&gt;B) -&gt; (C-&gt;B)</code><br />
<code>(A-&gt;B)</code>를 <code>(C-&gt;B)</code>로 매핑한다.<br />
<code>(A-&gt;B)</code>를 <code>(C-&gt;B)</code>로 변환한다.<br />
<code>(A-&gt;B)</code>와 <code>(C-&gt;B)</code>의 차이를 나타낸다.<br />
…<br />
그다지 거부감 없이 다 받아들일만한 설명입니다. 위의 해석들을 직관으로 보면 <code>A</code>를 <code>C</code>로 바꾸는 <code>A-&gt;C</code>만 있으면 구현할 수 있을 것만 같습니다. <code>((A-&gt;C)-&gt;B)</code> 이렇게요. 하지만 <strong>A-&gt;B</strong>는 <strong>블랙 박스</strong>입니다. 안에서 무슨 일이 일어나고 있을지 알 수 없습니다. <code>A-&gt;Z-&gt;Y-&gt;X....C-&gt;B</code> 이러고 있을지도 모르는데, 어디를 어떻게 손 댈지 알 수 없습니다. <code>A-&gt;블랙 박스-&gt;B</code>가 고차 함수가 아니고선, 블랙 박스에 들어가는 인터페이스 A와 붙이든지, 나오는 인터페이스 B와 붙이든지 해야 합니다.</li>
</ol>
<h2 id="a---b-와-homab">a -&gt; b 와 Hom(a,b)</h2>
<p>일단, hom-set부터 보고 가겠습니다. <code>hom(a,b)</code>는 <code>a</code>에서 <code>b</code>로 가는 모든 모피즘의 집합이라고 합니다.</p>
<blockquote>
<p>상상<br />
<strong>Q</strong>. 그런데, <code>a -&gt; b</code>라고 표현하는 것도 어차피 <code>a</code>, <code>b</code>가 폴리모픽 아닌가요? <code>a -&gt; b</code>라고 표현해도 같은 의미인 것 같은데, 왜 또 표현을 만들었을까요?<br />
<strong>A</strong>. <code>a -&gt; b</code>가 모피즘으로 쓰이지 않고, 카테고리에서 대상object 역할을 할 때, <code>a -&gt; b</code>라고 쓰면, <code>a -&gt; b</code>에서 <code>c -&gt; d</code>로 가는 모피즘 <code>b -&gt; c</code>와 혼란스럽게 섞입니다. 이 때 <code>hom(a,b) ---- b -&gt; c ----&gt; hom(c,d)</code>로 표현하면 혼란을 줄일 수 있어서 만들어내지 않았을까 추측합니다.</p>
</blockquote>
<h2 id="hom-펑터의-hom은">Hom 펑터의 Hom은?</h2>
<p>Hom-Set은 준동형<strong>Hom</strong>omorphism 사상 집합이란 이름인데, Hom-Functor는 뭘까요?<br />
카테고리<code>C</code>를, 카테고리 <code>C</code>에 있는 모피즘들의 집합을 대상으로 가진 카테고리 <code>Set</code>로 매핑하는 펑터를 의미합니다.</p>
<blockquote>
<p>상상<br />
펑터 자체도 카테고리 구조를 보존하는 homomorphism이니, <strong>Hom</strong>을 붙이는 게 어색하지 않습니다.<br />
<strong>Q</strong>. 그럼 hom-set처럼 펑터의 집합을 의미할까요?<br />
<strong>A</strong>. 처음 <code>Hom(A, -)</code>를 봤을 때는, 이 자체가 구현처럼 보였습니다. <code>X1 -&gt; Hom(A,X1)</code> 이렇게 매핑하니까요. <code>A</code>는 카테고리 <code>C</code>에 있는 오브젝트 <code>X1</code>, <code>X2</code>, … 중 하나를 뽑아 홈펑터를 만듭니다. 그런데, <code>A</code>는 모든 오브젝트라 하니, 각각의 오브젝트에 대해 <code>Hom(X1, -)</code>, <code>Hom(X2, -)</code>, …를 의미합니다. 폴리모픽 펑터 표현으로 펑터 집합을 표현합니다. (검증 필요)</p>
<p>※ 정규 과정에 쓰이는 텍스트를 차분히 보지, 왜 상상해서 이런 말을 올리냐 할 수 있습니다. (다 보진 못하고, 2~3권 딱 해당 챕터의 도입부 정도만 보긴 했지만) 사람들이 이런 걸 별로 궁금해 하지 않는지, 짚어 주고 시작하는 텍스트를 못 찾았습니다. 그래서, 이런 상상 꼬리표가 달린 글들을 올립니다. 이런 글을 보고, 틀린 걸 발견하거나 다른 의견이 있으신 분들을 만나 이러쿵 저러쿵 하고 싶어 글을 올립니다만, 3년 넘게 운영하는 동안 의견을 주고 받을 분을 만나기가 쉽지 않네요.</p>
</blockquote>
<p>보통 소문자 <strong>hom</strong>은 hom-set으로 쓰이고, 대문자 <strong>Hom</strong>은 hom-functor로 구별해서 쓰나 했는데, 딱히 대소문자로 가리진 않고, 위 링크 위키 텍스트에서 <code>Hom(-,-)</code>, <code>Hom(A,-)</code>처럼 <code>-</code>가 들어가 있으면 hom-functor, <code>-</code>가 없이 <code>Hom(A,B)</code>면 hom-set을 가리키는 걸로 보입니다.</p>
<p><code>C</code>에 있는 <strong>모든 대상</strong> <code>A</code>, <code>B</code>들에 대해 <strong>Set</strong>으로 보내는 두 펑터를 아래와 같이 정의합니다.</p>
<figure>
<img src="../images/homFunctor.jpg" alt="Hom(A,-)와 Hom(-,B)" /><figcaption aria-hidden="true">Hom(A,-)와 Hom(-,B)</figcaption>
</figure>
<h2 id="hom-a---c---set">Hom (A, -): C -&gt; Set</h2>
<p><code>Hom(A, -)</code>는 마치 하스켈 타입 생성자 같기도 하고, 함수를 인자로 받아, 가지고 있는 함수를 변형하는 고차 함수 같기도 합니다. 쓰고나서 보니, 펑터 인스턴스가 있는 타입 생성자와 <code>fmap</code>, 즉 펑터입니다.</p>
<p><code>Hom(A, -)</code>에서, 설명을 위해 <code>A</code>는 일단 고정한 채로<br />
아래와 같이 카테고리<code>C</code>에 있는 <code>X1</code>,<code>X2</code>,<code>...</code> 대상을 <code>Set</code>카테고리의 대상 hom-Set에 매핑합니다.<br />
<code>X1</code> —&gt; <code>Hom(A,X1)</code><br />
<code>X2</code> —&gt; <code>Hom(A,X2)</code><br />
…</p>
<p><code>Hom</code>펑터는 <strong>펑터</strong>니까 모피즘도 매핑해야 합니다.<br />
<code>f:X -&gt; Y</code> —&gt; <code>Hom(A,</code><strong>f</strong><code>): Hom(A,</code><strong>X</strong><code>) -&gt; Hom(A,</code><strong>Y</strong><code>)</code><br />
그런데, 여기 눈여겨 봐야할 성질이 하나 숨어 있습니다. 하스켈에서 펑터는</p>
<ul>
<li><code>f</code>를 변형한다고 보기도 하고, <code>(a -&gt; b) -&gt; (f a -&gt; f b)</code></li>
<li>새로운 구조 안에 있는 대상에 <code>f</code>를 적용한다고 해석하기도 합니다. <code>(a -&gt; b) -&gt; f a -&gt; f b</code></li>
</ul>
<blockquote>
<p>주의: 함수 안에 들어 있는 걸 바꾸는 건 다른 문제입니다. 한참 헤맸는데, <code>Maybe x</code>일 때 <code>fmap</code>으로 <code>x</code>에 함수를 적용할 순 있어도, <code>Maybe (x -&gt; y)</code>에선 함수를 깨버리고 들어갈 수가 없습니다. <code>x</code>와 <code>y</code>는 보이지 않습니다. <code>(x -&gt; y)</code> 자체가 대상object입니다. 대상을 변형할 수는 없고, 전에 합성을 하든, 후에 합성을 하는 수 밖에 없습니다. 안에 있는 <code>x</code>에 <code>f</code>를 적용한다는 메타포로 보면, <code>Maybe</code> 안에 있는 <code>(x -&gt; y)</code>에 <code>f</code>를 적용할 순 있어도, 더 들어가 <code>x</code>에 적용할 순 없습니다.</p>
</blockquote>
<p><code>A-&gt;</code><strong>X</strong>를 변환해서 <code>A-&gt;</code><strong>Y</strong>가 되게 하려면, <code>A-&gt;</code><strong>X</strong> 다음에 <code>f:</code> <strong>X</strong><code>-&gt;</code><strong>Y</strong>를 합성(<strong>(X-&gt;Y) ∘ (A-&gt;X)</strong>)하면 됩니다. 또는 새로운 구조 <code>A-&gt;</code><strong>X</strong> 안 쪽에 있는 <strong>X</strong>에 <code>f</code>를 적용하는 것이 아니라, <code>A-&gt;X</code>의 결과로 함수를 빠져나올 <code>X</code>에 <code>f</code>를 적용합니다.</p>
<p>하나의 <strong>hom-Set</strong> <code>Hom(A,X)</code>에 들어 있는 모피즘(:<strong>A-&gt;X</strong>)을 <code>g1</code>, <code>g2</code>, <code>...</code> 라 하면, <strong>Hom-Functor</strong> <code>Hom(A,-)</code>는 이 모피즘들을 각 각 <code>f:</code><strong>(X-&gt;Y) ∘</strong>와 합성합니다. 결국 <strong>hom-set</strong> <code>Hom(A,Y)</code>에 있는 모피즘(:<strong>A-&gt;Y</strong>) <code>f∘g1</code>, <code>f∘g2</code>, <code>...</code>로 매핑하는 모양이 됩니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>g1 ----&gt; f∘g1</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>g2 ----&gt; f∘g2</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div>
<p>※ 모피즘 매핑을 보면 <code>X</code> <strong>-&gt;</strong> <code>Y</code>에 펑터를 적용한 결과가 <code>X</code> <strong>-&gt;</strong> <code>Y</code> 그대로여서 Covariant 펑터라 합니다.</p>
<p>(※ 보통 카테고리 이론에서는 대상을 구조가 없는, 아무 성질도 없는 점 쯤으로 생각합니다. 그런데, 만일 <code>Hom(A,-)</code> 펑터를 적용하니, 위와 같은 합성 성질이 나왔다면, 대상이 <code>A-&gt;X</code>를 가지고 있다고 유추할 수 있을 것 같습니다. (검증 필요))</p>
<h2 id="hom---b-c---set">Hom (-, B) : C -&gt; Set</h2>
<p><code>B</code>는 일단 고정한 채로<br />
<code>Hom(-,B)</code>는 아래와 같이 매핑하는 펑터입니다.<br />
<code>X1</code> —&gt; <code>Hom(X1,B)</code><br />
<code>X2</code> —&gt; <code>Hom(X2,B)</code><br />
…</p>
<p>모피즘 매핑을 보겠습니다.<br />
(1) <code>h:X -&gt; Y</code> —&gt; <code>Hom(</code><strong>h</strong><code>,B): Hom(</code><strong>X</strong><code>,B) -&gt; Hom(</code><strong>Y</strong><code>,B) -- ???</code><br />
(2) <code>h:X -&gt; Y</code> —&gt; <code>Hom(</code><strong>h</strong><code>,B): Hom(</code><strong>Y</strong><code>,B) -&gt; Hom(</code><strong>X</strong><code>,B)</code><br />
(1)처럼 Covariant하게 정의하면 될 것 같은데, (2)로 Contravariant하게 정의하고 있습니다. <strong><em>왜 이렇게 정의했을까요?</em></strong> (1)이 뭐가 문제인지 보기 위해, (1)로 정의해 보겠습니다. <code>X-&gt;B</code> 모피즘을 <code>Y-&gt;B</code>로 변환하려 합니다. 어떤 변환 과정을 거치든 시작이 <code>Y</code>이고 끝이 <code>B</code>입니다. <code>X-&gt;Y</code>와 <code>X-&gt;B</code>만 가지고선 <strong>시작에 Y</strong>를 둘 방법이 없습니다. <strong>끝에 B</strong>를 둘 수 있는 <code>X-&gt;B</code>는 있으니, <code>∘ (Y-&gt;X)</code>가 있으면 딱입니다. <code>h^op:Y-&gt;X</code>가 필요합니다. (<code>h:X-&gt;Y</code>에서 화살표가 뒤집어졌다고 <code>^op</code>posite를 붙입니다.) <code>X-&gt;B</code>모피즘을 <code>g1</code>, <code>g2</code>, …라 하면, <code>g1∘h^op</code>, <code>g2∘h^op</code>, …와 매핑합니다. 결국, 함수의 입력 쪽에 <code>X</code>가 있다면 Contravariant한 정의만 가능합니다.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>g1 ----&gt; g1∘h^op</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>g2 ----&gt; g2∘h^op</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>-- 텍스트에 따라 아예 h: Y -&gt; X로 뒤집어 두고 설명을 시작하기도 합니다. 그러면</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>g1 ----&gt; g1∘h</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>g2 ----&gt; g2∘h</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div>
<p>또는 다음처럼 볼 수 있습니다. 이미 모피즘들은 반대op 방향 모피즘을 모두 가지고 있습니다. 그들 중 어떤 것과 짝을 지어 줘야 구조가 보존되는가를 보면 됩니다. 위에는 보통의 펑터도 F^op가 같이 있는 상황에서 매핑을 대상을 고르는 것이고, 아래는 홈펑터 얘깁니다. 함수형에서는, 모든 데이터들이 그 때 그 때 생성이 아니라, 마치 예정된 미래처럼 모두 있다고 생각하는 게 도움이 될 때가 있습니다.</p>
<figure>
<img src="../images/contravariant.jpg" alt="Contravariant도 항상 같이 있다." /><figcaption aria-hidden="true">Contravariant도 항상 같이 있다.</figcaption>
</figure>
<p>※ 파란색 굵은 화살표와 빨간색 굵은 화살표를 매핑하는 게 목표입니다.</p>
<p><code>∘ (X-&gt;Y)</code>도 있고, <code>∘ (Y-&gt;X)</code>도 이미 존재하는데, <code>X-&gt;Y</code> 모피즘의 구조를 보존하려면, 어느 것과 매핑해야 구조가 보존되는가입니다. <code>X-&gt;B</code>에서 <code>Y-&gt;B</code>로 연결, 혹은 변환되어야 합니다. <code>∘ (Y-&gt;X)</code>를 붙여 <code>Y-&gt;X-&gt;B</code>로 변환합니다.</p>
<p>대상을 깰 수는 없습니다. 대상이 함수라면, 입력 쪽에 있는 것에 영향을 미치려면 먼저 영향을 줘야 하고, 출력 쪽에 있다면 나중에 영향을 주는 수 밖에 없습니다. <code>(X-&gt;Y)</code>이 한 덩어리로 대상입니다.</p>
<blockquote>
<p>입력에 두는 것이 Contravariant가 필요하게 되는 게 오묘합니다. 최종 결과 모양이 <code>Y-&gt;B</code>로 <code>Y</code>가 입력에 있는 걸 원하니, <code>∘ (Y-&gt;X)</code>가 필요한 게 당연하긴 한데, 여전히 속 뜻이 더 있지 않을까 싶습니다.</p>
<p>상상<br />
<code>X</code>를 <code>X-&gt;X</code> 항등 함수로, <code>Y</code>를 <code>Y-&gt;Y</code> 항등 함수로 두면 (<strong>모든 걸 Computation으로 두면</strong>) 그동안 편하게 해오던, <code>f:X-&gt;Y</code>를 <code>X</code>에 적용해서 <code>Y</code>가 되는 건, <code>f:(X-&gt;X)-&gt;(Y-&gt;Y)</code>으로 두면, <code>Id_X:X-&gt;X</code>가 변환되어 최종 모양이 <code>Id_Y:Y-&gt;Y</code>가 되어야 하기 때문에</p>
<p><strong>Y-&gt;</strong><code>X ---&gt; X-&gt;X ---&gt; X-&gt;</code><strong>Y</strong><br />
<code>Y -------------------&gt; Y</code></p>
<p>로 볼 수 있습니다.<br />
<code>X</code>에서 <code>Y</code>가 아닌 , <code>Id_X</code>가 <code>Id_Y</code>로 변환되려면(혹은 매핑하려면) Contravariant인 <code>Y-&gt;X</code>, Covariant인 <code>X-&gt;Y</code>가 모두 필요합니다.<br />
<code>Id:X-&gt;X</code>를 변환해서 <code>X-&gt;Y</code>로 만든다면, Contravariant를 없애고,<br />
<code>Id:X-&gt;X</code>를 변환해서 <code>Y-&gt;X</code>로 만든다면, Covariant를 없앱니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>Contravariant       Covariant</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>          X-&gt;X ---&gt; X-&gt;Y ----------&gt; X-&gt;Y </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>Y-&gt;X ---&gt; X-&gt;X           ----------&gt; Y-&gt;X </span></code></pre></div>
<p>대상 속에 <code>-&gt;</code>가 있다면(모든 게 Computation인 세상이라면), “Contravariant는 항상 따라다니고 있던 것이었다”라고 상상해 봤습니다.<br />
※ <code>Id_X</code>가 <code>Id_Y</code>로 가려면, <code>Y-&gt;X</code>, <code>X-&gt;Y</code>가 있어야 합니다. <a href="../posts/2023-12-05-adjunction_arrow_meaning.html">Adjunction</a>으로 생각이 이어집니다.</p>
</blockquote>
<p>※ 모피즘 매핑을 보면 <code>X</code> <strong>-&gt;</strong> <code>Y</code>에 펑터를 적용한 결과가 방향이 뒤집어진 <code>Y</code> <strong>-&gt;</strong> <code>X</code>여서 Contravariant 펑터입니다. 입력이었던 것이 출력이 되고, 출력이었던 것이 입력이 되었습니다.</p>
<p>참고 - <a href="../posts/2022-11-10-coContraVarint.html">Covariant, Contravariant, Positive, Negative</a></p>
<h3 id="natural-manner">Natural Manner</h3>
<p>첫 번째 인자를 고정하면 Covariant 펑터를 주고, 두 번째 인자를 고정하면 Contravariant 펑터를 줍니다. (위 설명하고 헛갈리지 말아야 합니다. variant한 값이 어디 있는지를 봐야 합니다.)</p>
<p><code>Hom(A, -)</code>, <code>Hom(-, B)</code>는 다음과 같은 가환 다이어그램이 성립합니다. <code>f: B -&gt; B'</code>, <code>h:A' -&gt; A</code>에서 아무거나 짝지으면 ※ <a href="https://en.wikipedia.org/wiki/Hom_functor">위키 Hom functor</a>에서 발췌</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>Hom(A,B) -----Hom(h,B)-----&gt; Hom(A',B)     -&gt; Hom(-,B) 변환</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>   |                            |</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>   | Hom(A,f)                   | Hom(A',f)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>   |                            |</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>   V                            V</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>Hom(A,B') ----Hom(h,B')----&gt; Hom(A',B')    -&gt; Hom(-,B')로 변환</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>   |                            |</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>   V                            V</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>Hom(A,-)로 변환              Hom(A',-)로 변환</span></code></pre></div>
<p>양 쪽 경로 모두 <code>g:A -&gt; B</code>를 <code>f∘g∘h:A' -&gt; B'</code>로 보냅니다. (※ 하나는 Covariant, 하나는 Contravariant로 정의한 덕에 <code>f∘g∘h</code> 모양으로 합성할 수 있게 됐습니다.) 이 가환이 갖는 의미가 뭘까요? Covariant 펑터 <code>Hom(A,-)</code>를 적용한 후에 Contravariant 펑터 <code>Hom(-,B)</code>를 적용하나, Contravariant 펑터를 적용 후 Covariant 펑터를 적용하나 결과가 같습니다. 이 걸 Natural Manner라고 부릅니다.</p>
<p>두 펑터를 합친 <code>Hom(-,-)</code>는 바이펑터bifunctor입니다. <code>C</code>카테고리에서 한 번만 뽑는게 아니라, 두 번 뽑아아야 하니 <code>C × C</code>에서 <code>Set</code>으로 가는 바이펑터인데, 첫 번째 인자를 고정하면 Covariant하고, 두 번째 인자를 고정하면 Contravariant합니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>Hom(-,-): C^op × C -&gt; Set</span></code></pre></div>
<p><code>C^op</code>는 <code>C</code>의 화살표를 모두 뒤집어 놓은 반대opposite 카테고리입니다.</p>
<p>※ “<code>C × C -&gt; Set</code>인 바이펑터로, 첫 번째 인자에 Contravariant하고, 두 번째 인자에 Covariant하다”라고 말로 쓰거나, <code>C^op × C -&gt; Set</code> 이렇게만 표기하거나 하는 것 같습니다 (검증필요)</p>
<p>※ 바이펑터는 적용할 대상도 2튜플로 받고, 결과도 2튜플로 내뱉습니다.<br />
<code>C^op × C</code> product 카테고리에서 대상 <code>(X, Y)</code>의 매핑은,<br />
<code>(X, Y)</code> —바이펑터(A를 고정한 펑터 Hom(A,-), B를 고정한 펑터 Hom(-,B)—&gt; <code>(Hom(A,X), Hom(Y,B))</code><br />
모피즘 매핑은<br />
<code>(f, h)</code> —바이펑터(A를 고정한 펑터 Hom(A,-), B를 고정한 펑터 Hom(-,B)—&gt; <code>(Hom(A,f), Hom(h,B))</code></p>
<blockquote>
<p>상상 <span class="citation" data-cites="todo">@todo</span><br />
<strong>C와 D가 같은가</strong>를 볼 때, <code>C</code>와 <code>D</code>의 대상을 사람이 눈으로 확인하듯 보는 게 아니라, <code>C</code>와 <code>D</code> 사이를 오가는 펑터가 <code>id</code>펑터들과 같은가를 봤습니다. 둘이 같은가를 표현하는데, 대상은 등장하지 않습니다. <strong>펑터만 보면 됩니다.</strong> 어떤 펑터와 어떤 펑터가 닮았는지, 같은지를 보면 됩니다. identity를 확인하는데, 주변과의 관계만 얘기하고 있습니다.</p>
<p>대상 <code>A</code>의 정체성?은 뭘까요? 대상 <code>A</code>는 무엇이다라고 결정하는 게 사실은 <strong>주변과의 관계</strong>로 결정됩니다. 카테고리가 동형인가를 보기 위해 펑터를 보듯, “대상이 무엇이다”라고 말하는 건, 한 대상이 다른 대상과 맺는 관계, 즉 모피즘들을 훑어 보면 됩니다. 홈펑터는 이 걸 뜻합니다.</p>
<p>Naturality Condition(Square)<br />
<code>C-&gt;D</code>인 <code>F</code>펑터와 <code>G</code>펑터가 Naturality Condition(Square)을 만족한다고 하면, 이 걸로 뭘 알 수 있을까요? <code>F</code>와 <code>G</code> 모두 <code>C</code>의 구조를 보존한채로 <code>D</code>에 상image을 만듭니다. 이 두 상은 <strong><em>구조가 같습니다.</em></strong><br />
</p>
</blockquote>
<h2 id="요네다-보조-정리yoneda-lemma">요네다 보조 정리Yoneda lemma</h2>
<p>:렘마, 레마, 레머… 음차로 쓰는 말이 여럿인데, 여기선 보조 정리라 부르겠습니다.<br />
이제 요네다 보조 정리를 볼 준비가 끝났습니다. 짧은 지식에 카테고리 이론의 정수라는 요네다 보조 정리를 꾸역 꾸역 이해하려고 하는 이유는, Lens 때문입니다. Lens에서 get, set 인터페이스를 하나의 형태로 통일하기 위해 쓴 “테크닉”이 바로 요네다 보조 정리라 하니, 궁금해서 붙들고 있습니다. (참고 - 요네다 보조 정리에 대해 전혀 모를 때 쓴 글입니다. <a href="../posts/2021-05-13-lens.html">Lens - 펑크터의 독특한 활용</a>)</p>
<p>참고 - <a href="https://www.johndcook.com/blog/2019/08/06/hom-functors/%3E">Hom functors and a glimpse of Yoneda</a> : 혼란스럽게 쓰이는 기호들을 짚어주고, 다른 배경 지식을 최소한 요구하며 “짧게” 설명합니다.</p>
<p>또 다른 표기:<br />
<code>H_A = Hom(-, A)</code> Contravariant 펑터<br />
<code>H^A = Hom(A, -)</code> Covariant 펑터<br />
※ <code>^A</code>는 윗 첨자, <code>_A</code>는 아래 첨자</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(가) Hom(H_A, H_B) ~= Hom(A, B)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>(나) Hom(H^A, H^B) ~= Hom(B, A)</span></code></pre></div>
<p>왼 쪽, 오른 쪽 <code>Hom</code>의 의미가 다릅니다. 오른 쪽은 <strong>모피즘 집합</strong>을 의미하고, 왼 쪽은 펑터에서 펑터로 가는, 즉 <strong>자연 변환Natural Transformation 집합</strong>(펑터 사이의 모피즘이 자연 변환이니, 모피즘 집합이라 불러도 됩니다.)입니다.</p>
<h3 id="가">(가)</h3>
<p>“<code>A-&gt;B</code>모피즘은 <code>Hom(-,A) -&gt; Hom(-,B)</code> 자연 변환과 동형isomorphic이다.”<br />
홈펑터 정의를 그대로 넣어, 직관적으로 따라가 보겠습니다.</p>
<p><code>Hom(-,A)</code>홈펑터는<br />
<code>X1 ---&gt; Hom(X1,A)</code><br />
<code>X2 ---&gt; Hom(X2,A)</code><br />
…<br />
<code>Hom(-,B)</code>홈펑터는<br />
<code>X1 ---&gt; Hom(X1,B)</code><br />
<code>X2 ---&gt; Hom(X2,B)</code><br />
…<br />
머리가 복잡한데, 원래의 모피즘 <code>A-&gt;B</code>를 잠시 <code>X-&gt;Y</code>로 두겠습니다.<br />
<code>Hom(-,A)</code>홈펑터가 <code>X-&gt;Y</code>를 매핑한 모피즘은 <code>Hom(X,A) -&gt; Hom(Y,A)</code>입니다.<br />
<code>X-&gt;A</code>를 <code>Y-&gt;A</code>로 변환하려면, Contravariant하게 <code>∘(Y-&gt;X)</code>를 쓰면 됩니다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(X-&gt;A)∘(Y-&gt;X) -- Y-&gt;X-&gt;A</span></code></pre></div>
<p>같은 작업을 <code>Hom(-,B)</code>에도 하면</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>(X-&gt;B)∘(Y-&gt;X) -- Y-&gt;X-&gt;B</span></code></pre></div>
<p><code>Y-&gt;A</code>와 <code>Y-&gt;B</code>의 차이는 <code>A-&gt;B</code>입니다.</p>
<p><code>Y-&gt;</code><strong>A-&gt;B</strong></p>
<p>둘 간의 차이, 즉 <code>Hom(-,A)</code>홈펑터에서 <code>Hom(-,B)</code>홈펑터로 가는 자연 변환은, <code>Y-&gt;A</code> 후에 <strong>A-&gt;B</strong>를 하면 <code>Y-&gt;B</code>가 되니 <strong>A-&gt;B</strong>가 바로 자연 변환입니다. 두 홈펑터 사이의 자연 변환도 <strong>A-&gt;B</strong>가 나왔습니다. <code>Y</code>가 <code>B</code>인 경우를 보면,</p>
<p><code>B-&gt;</code><strong>A-&gt;B</strong><br />
<code>B----&gt;B</code></p>
<p>※ <code>1</code>과 <code>2</code>의 차이는 <code>+1</code>이라고 말하듯, <code>B-&gt;A</code>와 <code>B-&gt;B</code>의 차이(자연변환)는 <strong>A-&gt;B</strong>(<code>(A-&gt;B)∘</code>)입니다. 이런 결과가 나오는 게 당연해 보이기도 하고, 신기하기도 합니다.</p>
<h3 id="나">(나)</h3>
<p>“<code>B-&gt;A</code>모피즘은 <code>Hom(A,-) -&gt; Hom(B,-)</code> 자연 변환과 동형isomorphic이다.”</p>
<p><code>Hom(A,-)</code>홈펑터는<br />
<code>X1 ---&gt; Hom(A,X1)</code><br />
<code>X2 ---&gt; Hom(A,X2)</code><br />
…<br />
<code>Hom(B,-)</code>홈펑터는<br />
<code>X1 ---&gt; Hom(B,X1)</code><br />
<code>X2 ---&gt; Hom(B,X2)</code><br />
…<br />
역시, 원래의 모피즘 <code>A-&gt;B</code>를 잠시 <code>X-&gt;Y</code>로 두겠습니다.<br />
<code>Hom(A,-)</code>홈펑터가 <code>X-&gt;Y</code>를 매핑한 모피즘은 <code>Hom(A,X) -&gt; Hom(A,Y)</code>입니다.<br />
<code>A-&gt;X</code>를 <code>A-&gt;Y</code>로 변환하려면, Covariant하게 <code>(X-&gt;Y)∘</code>를 쓰면 됩니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(X-&gt;Y)∘(A-&gt;X) -- A-&gt;X-&gt;Y</span></code></pre></div>
<p>같은 작업을 <code>Hom(B,-)</code>에도 하면</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(X-&gt;Y)∘(B-&gt;X) -- B-&gt;X-&gt;Y</span></code></pre></div>
<p><code>A-&gt;Y</code>와 <code>B-&gt;Y</code>의 차이는 <code>B-&gt;A</code>입니다.</p>
<p><strong>B-&gt;A</strong>-&gt;Y</p>
<p>두 홈펑터 사이의 자연 변환은 <strong>B-&gt;A</strong>(<code>∘(B-&gt;A)</code>)가 됩니다. <code>Y</code>가 <code>B</code>인 경우를 보면</p>
<p><strong>B-&gt;A</strong><code>-&gt;B</code><br />
<code>B----&gt;B</code></p>
<figure>
<img src="../images/yoneda.jpg" alt="요네다 보조 정리" /><figcaption aria-hidden="true">요네다 보조 정리</figcaption>
</figure>
<p>위에서는 <code>Hom(-,A) -&gt; Hom(-,B)</code>만 봤지만, <code>Hom(-,B)</code>자리에 <code>C^op -&gt; Set</code> 모양의 어떤 펑터든 성립한다고 합니다. 이를 식으로 쓰면, ※ 상상 - 카테고리 Set의 대상이 어떤 set인지는 보지 않고, Contravariant하기만 하면 동작이 성립할테니, 당연히 그럴 것 같긴 합니다.</p>
<p><code>F펑터: C^op -&gt; Set</code>일 때,<br />
<code>Hom(-,X)홈펑터 -&gt; F펑터</code>자연 변환이 <code>F(X)</code>와 bijection<br />
<strong>Nat(Hom(-,X),F) ~= F(X)</strong></p>
<p>위 식이 성립한다가 요네다 보조 정리입니다. 여기서는 왜 성립하는지 증명보다 의미가 무엇이고, 하스켈에 어떻게 적용되는지를 우선 보겠습니다.</p>
<p>※ 그림만 봐서는 Adjunction하고 연관성이 있지 않을까요? <span class="citation" data-cites="todo">@todo</span></p>
<h2 id="lens">Lens</h2>
<p>이제, 이런 결과를 Lens에 어떻게 적용하는지 볼 차례입니다. 많은 내용을 그대로 얘기해야 하니 <a href="https://lionhairdino.github.io/posts/2021-05-13-lens.html#%EC%99%9C-%ED%8E%91%ED%81%AC%ED%84%B0%EA%B0%80-%EB%93%A4%EC%96%B4%EA%B0%80-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94">Lens 정의에 왜 펑터가 들어가 있을까요?</a>를 같이 봐주세요.</p>
<p>Lens 구현에 보면 <code>(a-&gt;a) -&gt; (s-&gt;s)</code>를 <code>s-&gt;a</code>로 바꾸는 작업을 합니다.<br />
위 요네다 보조 정리 (나)에선 <code>B-&gt;A</code>는 <code>(A-&gt;B) -&gt; (B-&gt;B)</code>와 동형이었습니다.<br />
<code>B</code>를 <code>s</code>로, <code>A</code>를 <code>a</code>로 두면,<br />
</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(a-&gt;s) -&gt; (s-&gt;s) ~= s-&gt;a -- 요네다 보조 정리</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>(a-&gt;a) -&gt; (s-&gt;s) ~= s-&gt;a -- Lens에서 필요한 것</span></code></pre></div>
<p>Fri Dec 22 04:32:17 PM KST 2023 작성 중…</p>
<h2 id="하스켈-코드로-보는-요네다-보조-정리">하스켈 코드로 보는 요네다 보조 정리</h2>
<p><a href="https://gist.github.com/Icelandjack/02069708bc75f4284ac625cd0e2ec81f">Icelandjack/Yoneda_II.markdown</a></p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
