<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - 홈펑터Hom Functor와 요네다 보조 정리Yoneda lemma</title>

        <meta name="description" content="다른 수학 배경 지식 없이, 최대한 직관적으로 풀어 나갔습니다. 최종 목표는 Lens에 Yoneda lemma 아이디어를 어떤식으로 적용했는지를 보는 것입니다." />
        <meta property="og:description" content="다른 수학 배경 지식 없이, 최대한 직관적으로 풀어 나갔습니다. 최종 목표는 Lens에 Yoneda lemma 아이디어를 어떤식으로 적용했는지를 보는 것입니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="홈펑터Hom Functor와 요네다 보조 정리Yoneda lemma" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-12-16-homFunctor.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/usingMorphism.jpg" />

      <meta name="keywords" content="hom-set, functor, hom-functor, 홈펑터, 요네다 레마, 요네다 렘마, 요네다 레머, 요네다 보조 정리, Covariant, Contravariant, Lens">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>홈펑터Hom Functor와 요네다 보조 정리Yoneda lemma</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on December 16, 2023
    
</div>

<p>※ 블로그 글의 편집 결과가 그런대로 볼만하게 나오는 게 오히려 문제입니다. 꼭, 정확한 지식인양 보일 수가 있거든요. (조금이라도 검증을 통과하면 그림들을 다시 그리겠습니다. 지금은 허술한 그림이 오히려 목적에 맞습니다.) 아래 글은 정확한 내용이라 검증되지 않았습니다. 다른 텍스트를 보고 아직 이해가 안간, 주로 프로그래머 분들과, 뭐가 맞는지 상의하기 위해 올리는 글입니다. 심오한 수학적 정의를 원하는 분한테는 어울리지 않는 곳입니다.</p>
<h2 id="생각-스트레칭">생각 스트레칭</h2>
<ol type="1">
<li>삼형제 <code>A</code>,<code>B</code>,<code>C</code>(순서는 형부터)가 있을 때,<br />
“(가) <code>A</code>보다는 작고”, “(나) <code>C</code>보다는 크다”<br />
는 두 조건을 모두 만족하려면 <code>B</code>뿐이 없습니다. (가), (나) 모피즘을 이용해 <code>B</code>를 정의했습니다. (<code>B</code>를 특정지을 수 있습니다.)</li>
</ol>
<figure>
<img src="../image/usingMorphism.jpg" alt="삼각형을 모피즘으로 가리키는 방법" /><figcaption aria-hidden="true">삼각형을 모피즘으로 가리키는 방법</figcaption>
</figure>
<p>위 모피즘 그림의 사각형을 완성시킬 무엇은? . 삼각형 모양을 잘라 낸 <strong>어떤 도형으로도 삼각형을 가리킬 수 있습니다.</strong></p>
<ol start="2" type="1">
<li><strong>(A-&gt;B) -&gt; (C-&gt;B) 해석</strong><br />
<code>(A-&gt;B)</code>를 <code>(C-&gt;B)</code>로 매핑한다.<br />
<code>(A-&gt;B)</code>를 <code>(C-&gt;B)</code>로 변환한다.<br />
<code>(A-&gt;B)</code>와 <code>(C-&gt;B)</code>의 차이를 나타낸다.<br />
…<br />
그다지 거부감 없이 다 받아들일만한 설명입니다. 위의 해석들을 직관으로 보면 <code>A</code>를 <code>C</code>로 바꾸는 <code>A-&gt;C</code>만 있으면 구현할 수 있을 것만 같습니다. <code>((A-&gt;C)-&gt;B)</code> 이렇게요. 하지만 <strong>A-&gt;B</strong>는 <strong>블랙 박스</strong>입니다. 안에서 무슨 일이 일어나고 있을지 알 수 없습니다. <code>A-&gt;Z-&gt;Y-&gt;X....C-&gt;B</code> 이러고 있을지도 모르는데, 어디를 어떻게 손 댈지 알 수 없습니다. <code>A-&gt;블랙 박스-&gt;B</code>가 고차 함수가 아니고선, 블랙 박스에 들어가는 인터페이스 <code>A</code>와 붙이든지, 나오는 인터페이스 <code>B</code>와 붙이든지 해야 합니다. (※ 고차 함수를 받을 인터페이스도 결국 하나의 타입으로 표현되니, “항상”이라 해도 되겠습니다.)</li>
</ol>
<p>카테고리 이론에서 보면, <code>(A-&gt;B)</code> 자체를 대상으로 삼으면, 대상이 뭔지는 보지 않습니다. 그저 모피즘의 시작과 끝만 표시하는 점입니다. <code>(A-&gt;B)</code>가 가진 어떤 속성도 고려하지 않습니다.</p>
<h2 id="a---b-와-homab">a -&gt; b 와 Hom(a,b)</h2>
<p>일단, hom-set부터 보고 가겠습니다. <code>hom(a,b)</code>는 <code>a</code>에서 <code>b</code>로 가는 모든 모피즘의 집합이라고 합니다.</p>
<blockquote>
<p>상상<br />
<strong>Q</strong>. 그런데, <code>a -&gt; b</code>라고 표현하는 것도 어차피 <code>a</code>, <code>b</code>가 폴리모픽 아닌가요? <code>a -&gt; b</code>라고 표현해도 같은 의미인 것 같은데, 왜 또 표현을 만들었을까요?<br />
<strong>A</strong>. <code>a -&gt; b</code>가 모피즘으로 쓰이지 않고, 카테고리에서 대상object 역할을 할 때, <code>a -&gt; b</code>라고 쓰면, <code>a -&gt; b</code>에서 <code>c -&gt; d</code>로 가는 모피즘 <code>b -&gt; c</code>와 혼란스럽게 섞입니다. 이 때 <code>hom(a,b) ---- b -&gt; c ----&gt; hom(c,d)</code>로 표현하면 혼란을 줄일 수 있어서 만들어내지 않았을까 추측합니다.</p>
</blockquote>
<h2 id="hom-펑터의-hom은">Hom 펑터의 Hom은?</h2>
<p>Hom-Set은 준동형<strong>Hom</strong>omorphism 사상 집합이란 이름인데, Hom-Functor는 뭘까요?<br />
카테고리<code>C</code>를, 카테고리 <code>C</code>에 있는 모피즘들의 집합을 대상으로 가진 카테고리 <code>Set</code>로 매핑하는 펑터를 의미합니다.</p>
<figure>
<img src="../images/homFunctor2.jpg" alt="Hom-Functor" /><figcaption aria-hidden="true">Hom-Functor</figcaption>
</figure>
<blockquote>
<p>상상<br />
펑터 자체도 카테고리 구조를 보존하는 homomorphism이니, <strong>Hom</strong>을 붙이는 게 어색하지 않습니다.<br />
<strong>Q</strong>. 그럼 hom-set처럼 펑터의 집합을 의미할까요?<br />
<strong>A</strong>. 처음 <code>Hom(A, -)</code>를 봤을 때는, 이 자체가 구현처럼 보였습니다. <code>X1 -&gt; Hom(A,X1)</code> 이렇게 매핑하니까요. <code>A</code>는 카테고리 <code>C</code>에 있는 오브젝트 <code>X1</code>, <code>X2</code>, … 중 하나를 뽑아 홈펑터를 만듭니다. 그런데, <code>A</code>는 모든 오브젝트라 하니, 각각의 오브젝트에 대해 홈펑터 <code>Hom(X1, -)</code>, 홈펑터 <code>Hom(X2, -)</code>, …를 의미합니다. <code>A</code>를 폴리모픽하게 두어 폴리모픽하게 홈펑터를 표현합니다. (검증 필요)</p>
<p>※ 정규 과정에 쓰이는 텍스트를 차분히 보지, 왜 상상해서 이런 말을 올리냐 할 수 있습니다. (다 보진 못하고, 2~3권 딱 해당 챕터의 도입부 정도만 보긴 했지만) 사람들이 이런 걸 별로 궁금해 하지 않는지, 짚어 주고 시작하는 텍스트를 못 찾았습니다. 그래서, 이런 상상 꼬리표가 달린 글들을 올립니다. 이런 글을 보고, 틀린 걸 발견하거나 다른 의견이 있으신 분들을 만나 이러쿵 저러쿵 하고 싶어 글을 올립니다만, 3년 넘게 운영하는 동안 의견을 주고 받을 분을 만나기가 쉽지 않네요.</p>
</blockquote>
<p>보통 소문자 <strong>hom</strong>은 hom-set으로 쓰이고, 대문자 <strong>Hom</strong>은 hom-functor로 구별해서 쓰나 했는데, 딱히 대소문자로 가리진 않고, 위 링크 위키 텍스트에서 <code>Hom(-,-)</code>, <code>Hom(A,-)</code>처럼 <code>-</code>가 들어가 있으면 hom-functor, <code>-</code>가 없이 <code>Hom(A,B)</code>면 hom-set을 가리키는 걸로 보입니다.</p>
<p><code>C</code>에 있는 <strong>모든 대상</strong> <code>A</code>, <code>B</code>들에 대해 <strong>Set</strong>으로 보내는 두 펑터를 아래와 같이 정의합니다.</p>
<figure>
<img src="../images/homFunctor.jpg" alt="Hom(A,-)와 Hom(-,B)" /><figcaption aria-hidden="true">Hom(A,-)와 Hom(-,B)</figcaption>
</figure>
<h2 id="hom-a---c---set">Hom (A, -): C -&gt; Set</h2>
<p><code>Hom(A, -)</code>는 마치 하스켈 타입 생성자 같기도 하고, 함수를 인자로 받아, 가지고 있는 함수를 변형하는 고차 함수 같기도 합니다. 쓰고나서 보니, 펑터 인스턴스가 있는 타입 생성자와 <code>fmap</code>, 즉 펑터입니다.</p>
<p><code>Hom(A, -)</code>에서, 설명을 위해 <code>A</code>는 일단 고정한 채로<br />
아래와 같이 카테고리<code>C</code>에 있는 <code>X</code>,<code>Y</code>,<code>...</code> 대상을 <code>Set</code>카테고리의 대상 hom-Set에 매핑합니다.<br />
<code>X</code> —&gt; <code>Hom(A,X)</code> : <code>A</code>를 주면 <code>X</code>가 되는 함수<br />
<code>Y</code> —&gt; <code>Hom(A,Y)</code> : <code>A</code>를 주면 <code>Y</code>가 되는 함수<br />
…</p>
<p><code>Hom</code>펑터는 <strong>펑터</strong>니까 모피즘도 매핑해야 합니다.<br />
<code>f:X -&gt; Y</code> —&gt; <code>Hom(A,</code><strong>f</strong><code>): Hom(A,</code><strong>X</strong><code>) -&gt; Hom(A,</code><strong>Y</strong><code>)</code><br />
그런데, 여기 눈여겨 봐야할 성질이 하나 숨어 있습니다. 하스켈에서 펑터는</p>
<ul>
<li><code>f</code>를 변형한다고 보기도 하고, <code>(a -&gt; b) -&gt; (f a -&gt; f b)</code></li>
<li>새로운 구조 안에 있는 대상에 <code>f</code>를 적용한다고 해석하기도 합니다. <code>(a -&gt; b) -&gt; f a -&gt; f b</code></li>
</ul>
<blockquote>
<p>주의: 함수 안에 들어 있는 걸 바꾸는 건 다른 문제입니다. 한참 헤맸는데, <code>Maybe x</code>일 때 <code>fmap</code>으로 <code>x</code>에 함수를 적용할 순 있어도, 생각 스트레칭에서 말했듯이, <code>Maybe (x -&gt; y)</code>에선 함수를 깨버리고 들어갈 수가 없습니다. <code>x</code>와 <code>y</code>는 보이지 않습니다. <code>(x -&gt; y)</code> 자체가 대상object입니다. 대상을 변형할 수는 없고, 전에 합성을 하든, 후에 합성을 하는 수 밖에 없습니다. 안에 있는 <code>x</code>에 <code>f</code>를 적용한다는 메타포로 보면, <code>Maybe</code> 안에 있는 <code>(x -&gt; y)</code>에 <code>f</code>를 적용할 순 있어도, 더 들어가 <code>x</code>에 적용할 순 없습니다.<br />
※ 함수 펑터가 가지고 있는 <code>fmap</code>을 쓴다면 <code>(-&gt;) a b</code>에서 <code>a</code>에 접근할 수 있습니다. 여기선 <code>Maybe</code>의 <code>fmap</code>으론 함수 펑터 안에 있는 대상에 도달하지 못한다는 말입니다.</p>
</blockquote>
<p><code>A-&gt;</code><strong>X</strong>를 변환해서 <code>A-&gt;</code><strong>Y</strong>가 되게 하려면, <code>A-&gt;</code><strong>X</strong> 다음에 <code>f:</code> <strong>X</strong><code>-&gt;</code><strong>Y</strong>를 합성(<strong>(X-&gt;Y) ∘ (A-&gt;X)</strong>)하면 됩니다. 또는 새로운 구조 <code>A-&gt;</code><strong>X</strong> 안 쪽에 있는 <strong>X</strong>에 <code>f</code>를 적용하는 것이 아니라, <code>A-&gt;X</code>의 결과로 함수를 빠져나올 <code>X</code>에 <code>f</code>를 적용합니다.</p>
<p>하나의 <strong>hom-Set</strong> <code>Hom(A,X)</code>에 들어 있는 모피즘(:<strong>A-&gt;X</strong>)을 <code>g1</code>, <code>g2</code>, <code>...</code> 라 하면, <strong>Hom-Functor</strong> <code>Hom(A,-)</code>는 이 모피즘들을 각 각 <code>f:</code><strong>(X-&gt;Y) ∘</strong>와 합성합니다. 결국 <strong>hom-set</strong> <code>Hom(A,Y)</code>에 있는 모피즘(:<strong>A-&gt;Y</strong>) <code>f∘g1</code>, <code>f∘g2</code>, <code>...</code>로 매핑하는 모양이 됩니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>g1 ----&gt; f∘g1</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>g2 ----&gt; f∘g2</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div>
<p>※ 모피즘 매핑을 보면 <code>X</code> <strong>-&gt;</strong> <code>Y</code>에 펑터를 적용한 결과가 <code>X</code> <strong>-&gt;</strong> <code>Y</code> 그대로여서 Covariant 펑터라 합니다.</p>
<p>(※ 보통 카테고리 이론에서는 대상을 구조가 없는, 아무 성질도 없는 점 쯤으로 생각합니다. 그런데, 만일 <code>Hom(A,-)</code> 펑터를 적용하니, 위와 같은 합성 성질이 나왔다면, 대상이 <code>A-&gt;X</code>를 가지고 있다고 유추할 수 있을 것 같습니다. (검증 필요))</p>
<h2 id="hom---b-c---set">Hom (-, B) : C -&gt; Set</h2>
<p>※ <code>Hom (A,-)</code>는 컴퓨테이션을 거친 결과가 <code>A</code>는 아니라서, 전 Contravariant한 <code>Hom (-,B)</code>가 더 생각하기에 편한 듯 합니다.</p>
<p><code>B</code>는 일단 고정한 채로<br />
<code>Hom(-,B)</code>는 아래와 같이 매핑하는 펑터입니다.<br />
<code>X</code> —&gt; <code>Hom(X,B)</code> : <code>X</code>를 주면 <code>B</code>가 되는 함수<br />
<code>Y</code> —&gt; <code>Hom(Y,B)</code> : <code>Y</code>를 주면 주면 <code>B</code>가 되는 함수<br />
…</p>
<p>모피즘 매핑을 보겠습니다.<br />
(1) <code>h:X -&gt; Y</code> —&gt; <code>Hom(</code><strong>h</strong><code>,B): Hom(</code><strong>X</strong><code>,B) -&gt; Hom(</code><strong>Y</strong><code>,B) -- ???</code><br />
(2) <code>h:X -&gt; Y</code> —&gt; <code>Hom(</code><strong>h</strong><code>,B): Hom(</code><strong>Y</strong><code>,B) -&gt; Hom(</code><strong>X</strong><code>,B)</code><br />
(1)처럼 Covariant하게 정의하면 될 것 같은데, (2)로 Contravariant하게 정의하고 있습니다. <strong><em>왜 이렇게 정의했을까요?</em></strong> (1)이 뭐가 문제인지 보기 위해, (1)로 정의해 보겠습니다. <code>X-&gt;B</code> 모피즘을 <code>Y-&gt;B</code>로 변환하려 합니다. 어떤 변환 과정을 거치든 시작이 <code>Y</code>이고 끝이 <code>B</code>입니다. <code>X-&gt;Y</code>와 <code>X-&gt;B</code>만 가지고선 <strong>시작에 Y</strong>를 둘 방법이 없습니다. <strong>끝에 B</strong>를 둘 수 있는 <code>X-&gt;B</code>는 있으니, <code>∘ (Y-&gt;X)</code>가 있으면 딱입니다. <code>h^op:Y-&gt;X</code>가 필요합니다. (<code>h:X-&gt;Y</code>에서 화살표가 뒤집어졌다고 <code>^op</code>posite를 붙입니다.) <code>X-&gt;B</code>모피즘을 <code>g1</code>, <code>g2</code>, …라 하면, <code>g1∘h^op</code>, <code>g2∘h^op</code>, …와 매핑합니다. 결국, 함수의 입력 쪽에 <code>X</code>가 있다면 Contravariant한 정의만 가능합니다.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>g1 ----&gt; g1∘h^op</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>g2 ----&gt; g2∘h^op</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>-- 텍스트에 따라 아예 h: Y -&gt; X로 뒤집어 두고 설명을 시작하기도 합니다. 그러면</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>g1 ----&gt; g1∘h</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>g2 ----&gt; g2∘h</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div>
<p>또는 다음처럼 볼 수 있습니다. 이미 모피즘들은 반대op 방향 모피즘을 모두 가지고 있습니다. 그들 중 어떤 것과 짝을 지어 줘야 구조가 보존되는가를 보면 됩니다. 위에는 보통의 펑터도 F^op가 같이 있는 상황에서 매핑을 대상을 고르는 것이고, 아래는 홈펑터 얘깁니다. 함수형에서는, 모든 데이터들이 그 때 그 때 생성이 아니라, 마치 예정된 미래처럼 모두 있다고 생각하는 게 도움이 될 때가 있습니다.</p>
<figure>
<img src="../images/contravariant.jpg" alt="Contravariant도 항상 같이 있다." /><figcaption aria-hidden="true">Contravariant도 항상 같이 있다.</figcaption>
</figure>
<p>※ 파란색 굵은 화살표와 빨간색 굵은 화살표를 매핑하는 게 목표입니다.</p>
<p><code>∘ (X-&gt;Y)</code>도 있고, <code>∘ (Y-&gt;X)</code>도 이미 존재하는데, <code>X-&gt;Y</code> 모피즘의 구조를 보존하려면, 어느 것과 매핑해야 구조가 보존되는가입니다. <code>X-&gt;B</code>에서 <code>Y-&gt;B</code>로 연결, 혹은 변환되어야 합니다. <code>∘ (Y-&gt;X)</code>를 붙여 <code>Y-&gt;X-&gt;B</code>로 변환합니다.</p>
<p>대상을 깰 수는 없습니다. 대상이 함수라면, 입력 쪽에 있는 것에 영향을 미치려면 먼저 영향을 줘야 하고, 출력 쪽에 있다면 나중에 영향을 주는 수 밖에 없습니다. <code>(X-&gt;Y)</code>이 한 덩어리로 대상입니다.</p>
<blockquote>
<p>입력에 두는 것이 Contravariant가 필요하게 되는 게 오묘합니다. 최종 결과 모양이 <code>Y-&gt;B</code>로 <code>Y</code>가 입력에 있는 걸 원하니, <code>∘ (Y-&gt;X)</code>가 필요한 게 당연하긴 한데, 여전히 속 뜻이 더 있지 않을까 싶습니다.</p>
<p>상상<br />
<code>X</code>를 <code>X-&gt;X</code> 항등 함수로, <code>Y</code>를 <code>Y-&gt;Y</code> 항등 함수로 두면 (<strong>모든 걸 Computation으로 두면</strong>) 그동안 편하게 해오던, <code>f:X-&gt;Y</code>를 <code>X</code>에 적용해서 <code>Y</code>가 되는 건, <code>f:(X-&gt;X)-&gt;(Y-&gt;Y)</code>으로 두면, <code>Id_X:X-&gt;X</code>가 변환되어 최종 모양이 <code>Id_Y:Y-&gt;Y</code>가 되어야 하기 때문에</p>
<p><strong>Y-&gt;</strong><code>X ---&gt; X-&gt;X ---&gt; X-&gt;</code><strong>Y</strong><br />
<code>Y -------------------&gt; Y</code></p>
<p>로 볼 수 있습니다.<br />
<code>X</code>에서 <code>Y</code>가 아닌 , <code>Id_X</code>가 <code>Id_Y</code>로 변환되려면(혹은 매핑하려면) Contravariant인 <code>Y-&gt;X</code>, Covariant인 <code>X-&gt;Y</code>가 모두 필요합니다.<br />
<code>Id:X-&gt;X</code>를 변환해서 <code>X-&gt;Y</code>로 만든다면, Contravariant를 없애고,<br />
<code>Id:X-&gt;X</code>를 변환해서 <code>Y-&gt;X</code>로 만든다면, Covariant를 없앱니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>Contravariant       Covariant</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>          X-&gt;X ---&gt; X-&gt;Y ----------&gt; X-&gt;Y </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>Y-&gt;X ---&gt; X-&gt;X           ----------&gt; Y-&gt;X </span></code></pre></div>
<p>대상 속에 <code>-&gt;</code>가 있다면(모든 게 Computation인 세상이라면), “Contravariant는 항상 따라다니고 있던 것이었다”라고 상상해 봤습니다.<br />
※ <code>Id_X</code>가 <code>Id_Y</code>로 가려면, <code>Y-&gt;X</code>, <code>X-&gt;Y</code>가 있어야 합니다. <a href="../posts/2023-12-05-adjunction_arrow_meaning.html">Adjunction</a>으로 생각이 이어집니다.</p>
<p><code>a-&gt;b</code>는 <code>a</code>라는 기준점을 봤을 때 <code>b</code>로 가는 길Computation입니다. <code>a</code>를 바꾼다는 건, 자로 길이를 잴 때 기준점을 바꾸는 것과 동일한 동작입니다. Contravariant합니다.</p>
</blockquote>
<p>※ 모피즘 매핑을 보면 <code>X</code> <strong>-&gt;</strong> <code>Y</code>에 펑터를 적용한 결과가 방향이 뒤집어진 <code>Y</code> <strong>-&gt;</strong> <code>X</code>여서 Contravariant 펑터입니다. 입력이었던 것이 출력이 되고, 출력이었던 것이 입력이 되었습니다.</p>
<p>참고 - <a href="../posts/2022-11-10-coContraVarint.html">Covariant, Contravariant, Positive, Negative</a></p>
<h3 id="natural-manner">Natural Manner</h3>
<p>첫 번째 인자를 고정하면 Covariant 펑터를 주고, 두 번째 인자를 고정하면 Contravariant 펑터를 줍니다. (위 설명하고 헛갈리지 말아야 합니다. variant한 값이 어디 있는지를 봐야 합니다.)</p>
<p><code>Hom(A, -)</code>, <code>Hom(-, B)</code>는 다음과 같은 가환 다이어그램이 성립합니다. <code>f: B -&gt; B'</code>, <code>h:A' -&gt; A</code>에서 아무거나 짝지으면 ※ <a href="https://en.wikipedia.org/wiki/Hom_functor">위키 Hom functor</a>에서 발췌</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>Hom(A,B) -----Hom(h,B)-----&gt; Hom(A',B)     -&gt; Hom(-,B) 변환</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>   |                            |</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>   | Hom(A,f)                   | Hom(A',f)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>   |                            |</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>   V                            V</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>Hom(A,B') ----Hom(h,B')----&gt; Hom(A',B')    -&gt; Hom(-,B')로 변환</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>   |                            |</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>   V                            V</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>Hom(A,-)로 변환              Hom(A',-)로 변환</span></code></pre></div>
<p>양 쪽 경로 모두 <code>g:A -&gt; B</code>를 <code>f∘g∘h:A' -&gt; B'</code>로 보냅니다. (※ 하나는 Covariant, 하나는 Contravariant로 정의한 덕에 <code>f∘g∘h</code> 모양으로 합성할 수 있게 됐습니다.) 이 가환이 갖는 의미가 뭘까요? Covariant 펑터 <code>Hom(A,-)</code>를 적용한 후에 Contravariant 펑터 <code>Hom(-,B)</code>를 적용하나, Contravariant 펑터를 적용 후 Covariant 펑터를 적용하나 결과가 같습니다. 이 걸 Natural Manner라고 부릅니다.</p>
<p>두 펑터를 합친 <code>Hom(-,-)</code>는 바이펑터bifunctor입니다. <code>C</code>카테고리에서 한 번만 뽑는게 아니라, 두 번 뽑아아야 하니 <code>C × C</code>에서 <code>Set</code>으로 가는 바이펑터인데, 첫 번째 인자를 고정하면 Covariant하고, 두 번째 인자를 고정하면 Contravariant합니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>Hom(-,-): C^op × C -&gt; Set</span></code></pre></div>
<p><code>C^op</code>는 <code>C</code>의 화살표를 모두 뒤집어 놓은 반대opposite 카테고리입니다.</p>
<p>※ “<code>C × C -&gt; Set</code>인 바이펑터로, 첫 번째 인자에 Contravariant하고, 두 번째 인자에 Covariant하다”라고 말로 쓰거나, <code>C^op × C -&gt; Set</code> 이렇게만 표기하거나 하는 것 같습니다 (검증필요)</p>
<p>※ 바이펑터는 적용할 대상도 2튜플로 받고, 결과도 2튜플로 내뱉습니다.<br />
<code>C^op × C</code> product 카테고리에서 대상 <code>(X, Y)</code>의 매핑은,<br />
<code>(X, Y)</code> —바이펑터(A를 고정한 펑터 Hom(A,-), B를 고정한 펑터 Hom(-,B)—&gt; <code>(Hom(A,X), Hom(Y,B))</code><br />
모피즘 매핑은<br />
<code>(f, h)</code> —바이펑터(A를 고정한 펑터 Hom(A,-), B를 고정한 펑터 Hom(-,B)—&gt; <code>(Hom(A,f), Hom(h,B))</code></p>
<blockquote>
<p>상상 <span class="citation" data-cites="todo">@todo</span><br />
<strong>C와 D가 같은가</strong>를 볼 때, <code>C</code>와 <code>D</code>의 대상을 사람이 눈으로 확인하듯 보는 게 아니라, <code>C</code>와 <code>D</code> 사이를 오가는 펑터가 <code>id</code>펑터들과 같은가를 봤습니다. 둘이 같은가를 표현하는데, 대상은 등장하지 않습니다. <strong>펑터만 보면 됩니다.</strong> 어떤 펑터와 어떤 펑터가 닮았는지, 같은지를 보면 됩니다. identity를 확인하는데, 주변과의 관계만 얘기하고 있습니다.</p>
<p>대상 <code>A</code>의 정체성?은 뭘까요? 대상 <code>A</code>는 무엇이다라고 결정하는 게 사실은 <strong>주변과의 관계</strong>로 결정됩니다. 카테고리가 동형인가를 보기 위해 펑터를 보듯, “대상이 무엇이다”라고 말하는 건, 한 대상이 다른 대상과 맺는 관계, 즉 모피즘들을 훑어 보면 됩니다. 홈펑터는 이 걸 뜻합니다.</p>
<p>Naturality Condition(Square)<br />
<code>C-&gt;D</code>인 <code>F</code>펑터와 <code>G</code>펑터가 Naturality Condition(Square)을 만족한다고 하면, 이 걸로 뭘 알 수 있을까요? <code>F</code>와 <code>G</code> 모두 <code>C</code>의 구조를 보존한 채로 <code>D</code>에 상image을 만듭니다. 이 두 상은 <strong><em>적어도 일부 구조는 같습니다.(보존 됐습니다.)</em></strong></p>
</blockquote>
<h2 id="요네다-보조-정리yoneda-lemma">요네다 보조 정리Yoneda lemma</h2>
<p>:렘마, 레마, 레머… 음차로 쓰는 말이 여럿인데, 여기선 보조 정리라 부르겠습니다.<br />
이제 요네다 보조 정리를 볼 준비가 끝났습니다. 짧은 지식에 카테고리 이론의 정수 중 하나라는 요네다 보조 정리를 꾸역 꾸역 이해하려고 하는 이유는, Lens 때문입니다. Lens에서 get, set 인터페이스를 하나의 형태로 통일하기 위해 쓴 “테크닉”이 바로 요네다 보조 정리라 하니, 궁금해서 붙들고 있습니다. (참고 - 요네다 보조 정리에 대해 전혀 모를 때 쓴 글입니다. <a href="../posts/2021-05-13-lens.html">Lens - 펑크터의 독특한 활용</a>)</p>
<p>또 다른 표기:<br />
<code>H_A = Hom(-, A)</code> Contravariant 펑터<br />
<code>H^A = Hom(A, -)</code> Covariant 펑터<br />
※ <code>^A</code>는 윗 첨자, <code>_A</code>는 아래 첨자. (홈펑터의 홈셋을 얘기할 일이 있어, 혼동을 줄이기 위해 좀 더 간결한 표현이 필요했을 거라 추측합니다.)</p>
<p>아래는 요네다 보조 정리의 특수한 경우라 할 수 있는데, 일단 이 것부터 보겠습니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(가) Hom(H_A, H_B) ~= Hom(A, B)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>(나) Hom(H^A, H^B) ~= Hom(B, A)</span></code></pre></div>
<p>왼 쪽, 오른 쪽 <code>Hom</code>의 의미가 다릅니다. 오른 쪽은 <strong>모피즘 집합</strong>을 의미하고, 왼 쪽은 펑터에서 펑터로 가는, 즉 <strong>자연 변환Natural Transformation 집합</strong>(펑터 사이의 모피즘이 자연 변환이니, 모피즘 집합이라 불러도 됩니다.)입니다.</p>
<h3 id="가-contravariant">(가) Contravariant</h3>
<p>“<code>A-&gt;B</code>모피즘은 <code>Hom(-,A) -&gt; Hom(-,B)</code> 자연 변환과 동형isomorphic이다.”<br />
홈펑터 정의를 그대로 넣어, 직관적으로 따라가 보겠습니다.</p>
<p><code>Hom(-,A)</code>홈펑터는<br />
<code>X1 ---&gt; Hom(X1,A)</code><br />
<code>X2 ---&gt; Hom(X2,A)</code><br />
…<br />
<code>Hom(-,B)</code>홈펑터는<br />
<code>X1 ---&gt; Hom(X1,B)</code><br />
<code>X2 ---&gt; Hom(X2,B)</code><br />
…<br />
머리가 복잡한데, 원래의 모피즘 <code>A-&gt;B</code>를 잠시 <code>X-&gt;Y</code>로 두겠습니다.<br />
<code>Hom(-,A)</code>홈펑터가 <code>X-&gt;Y</code>를 매핑한 모피즘은 <code>Hom(X,A) -&gt; Hom(Y,A)</code>입니다.<br />
<code>X-&gt;A</code>를 <code>Y-&gt;A</code>로 변환하려면, Contravariant하게 <code>∘(Y-&gt;X)</code>를 쓰면 됩니다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(X-&gt;A)∘(Y-&gt;X) -- Y-&gt;X-&gt;A -- Y-&gt;A</span></code></pre></div>
<p>같은 작업을 <code>Hom(-,B)</code>에도 하면</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>(X-&gt;B)∘(Y-&gt;X) -- Y-&gt;X-&gt;B -- Y-&gt;B</span></code></pre></div>
<p><code>Y-&gt;A</code>와 <code>Y-&gt;B</code>의 차이는 <code>A-&gt;B</code>입니다.</p>
<p><code>Y-&gt;</code><strong>A-&gt;B</strong></p>
<p>둘 간의 차이, 즉 <code>Hom(-,A)</code>홈펑터에서 <code>Hom(-,B)</code>홈펑터로 가는 자연 변환은, <code>Y-&gt;A</code> 후에 <strong>A-&gt;B</strong>를 하면 <code>Y-&gt;B</code>가 되니 <strong>A-&gt;B</strong>가 바로 자연 변환입니다. 두 홈펑터 사이의 자연 변환도 (<strong>A-&gt;B</strong>)∘가 나왔습니다. <code>Y</code>가 <code>B</code>인 경우를 보면,</p>
<p><code>B-&gt;</code><strong>A-&gt;B</strong><br />
<code>B----&gt;B</code></p>
<p>※ <code>1</code>과 <code>2</code>의 차이는 <code>+1</code>이라고 말하듯, <code>B-&gt;A</code>와 <code>B-&gt;B</code>의 차이(자연변환)는 <strong>A-&gt;B</strong>(<code>(A-&gt;B)∘</code>)입니다. 이런 결과가 나오는 게 당연해 보이기도 하고, 신기하기도 합니다.</p>
<h3 id="나-covariant">(나) Covariant</h3>
<p>“<code>B-&gt;A</code>모피즘은 <code>Hom(A,-) -&gt; Hom(B,-)</code> 자연 변환과 동형isomorphic이다.”</p>
<p><code>Hom(A,-)</code>홈펑터는<br />
<code>X1 ---&gt; Hom(A,X1)</code><br />
<code>X2 ---&gt; Hom(A,X2)</code><br />
…<br />
<code>Hom(B,-)</code>홈펑터는<br />
<code>X1 ---&gt; Hom(B,X1)</code><br />
<code>X2 ---&gt; Hom(B,X2)</code><br />
…<br />
역시, 원래의 모피즘 <code>A-&gt;B</code>를 잠시 <code>X-&gt;Y</code>로 두겠습니다.<br />
<code>Hom(A,-)</code>홈펑터가 <code>X-&gt;Y</code>를 매핑한 모피즘은 <code>Hom(A,X) -&gt; Hom(A,Y)</code>입니다.<br />
<code>A-&gt;X</code>를 <code>A-&gt;Y</code>로 변환하려면, Covariant하게 <code>(X-&gt;Y)∘</code>를 쓰면 됩니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(X-&gt;Y)∘(A-&gt;X) -- A-&gt;X-&gt;Y -- A-&gt;Y</span></code></pre></div>
<p>같은 작업을 <code>Hom(B,-)</code>에도 하면</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(X-&gt;Y)∘(B-&gt;X) -- B-&gt;X-&gt;Y -- B-&gt;Y</span></code></pre></div>
<p><code>A-&gt;Y</code>가 <code>B-&gt;Y</code>가 되려면 <code>∘(B-&gt;A)</code>이 있으면 됩니다.</p>
<p><strong>B-&gt;A</strong>-&gt;Y</p>
<p>두 홈펑터 사이의 자연 변환은 ∘(<strong>B-&gt;A</strong>)가 됩니다. <code>Y</code>가 <code>B</code>인 경우를 보면</p>
<p><strong>B-&gt;A</strong><code>-&gt;B</code><br />
<code>B----&gt;B</code></p>
<figure>
<img src="../images/yoneda.jpg" alt="요네다 보조 정리" /><figcaption aria-hidden="true">요네다 보조 정리</figcaption>
</figure>
<p>위에서는 <code>Hom(-,A) -&gt; Hom(-,B)</code>만 봤지만, <code>Hom(-,B)</code>자리에 <code>C^op -&gt; Set</code> 모양의 <strong>어떤 펑터든 성립한다</strong>고 합니다. 이를 식으로 쓰면, (※ 상상 - 카테고리 Set의 대상이 어떤 set인지는 보지 않고, Contravariant하기만 하면 동작이 성립할테니, 당연히 그럴 것 같긴 합니다.)</p>
<p>※ 위의 경우는 요네다 보조 정리의 <code>C^op -&gt; Set</code> 자리에 <code>Hom(-,B)</code>를 넣은 특수한 경우입니다.<br />
</p>
<pre><code>A -&gt; Hom(-,A)
B -&gt; Hom(-,B)
...</code></pre>
<p>이렇게 매핑하는 걸 요네다 임베딩embedding이라 부릅니다. <code>Set</code> 카테고리에 <code>A</code>와 대응하는 집합, <code>B</code>와 대응하는 집합, … 들을 모두 모아서 보면 <code>Set</code> 카테고리에 현재 카테고리 <code>C</code>와 대응되는 상image을 만든다고 볼 수 있겠습니다.</p>
<p><code>F펑터: C^op -&gt; Set</code>일 때,<br />
<code>Hom(-,A)홈펑터 -&gt; F펑터</code> 자연 변환이 <code>F(A)</code>와 (일대일 대응bijection | 동형?)</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>Nat(Hom(-,A),F) ~= F(A)</span></code></pre></div>
<p>위 식이 성립한다가 요네다 보조 정리입니다. 좀 더 정확히는</p>
<p>“<code>F</code>가 locally small category <code>C</code>에서 <code>Set</code>으로 가는 펑터일 때, C에 있는 각 대상 <code>A</code>에 대해, <code>h_A</code>에서 <code>F</code>로가는 자연 변환 <code>Nat(h_A,F) ≡ Hom(Hom(A,-),F)</code>는 <code>F(A)</code> 원소와 일대일 대응이다.”<br />
※ <code>Hom</code>이라 써도 되지만, 자연 변환임을 드러내기 위해 <code>Nat</code>가 더 적당해 보입니다.</p>
<blockquote>
<p>Let <code>F</code> be a functor from a locally small category <code>C</code> to <code>Set</code>. Then for each object <code>A</code> of <code>C</code>, the natural transformations <code>Nat(h_A,F) ≡ Hom (Hom(A,−),F)</code> from <code>h_A</code> to <code>F</code> are in one-to-one correspondence with the elements of <code>F(A)</code>.</p>
</blockquote>
<p>※ <code>Nat(Hom(-,A),F)</code>와 <code>F(A)</code>는 동형isomorphic이다라고 해도 될 것 같은데, 일대일 대응을 먼저 짚어 줍니다. 수식에는 동형(<code>~=</code>)이라 해놓고 설명 문장에는 일대일 대응이라 하는데 다른 이유가 있는지 잘 모르겠습니다. (자연 변환이라 일대일 대응만 봐도 동형이 되기 때문일거라 추측하고 있습니다.)</p>
<p>아주 추상적으로 어떤 정보를 가지고 있는지 살펴 보는 게 도움이 될 때가 자주 있습니다. 위 식에서 왼 쪽이 가지고 있는 정보는 <code>A</code>를 표현하는 다른 방법으로 <code>A</code>를 표현하고 있고, <code>F</code>를 가지고 있습니다. 오른 쪽도 <code>F</code>와 <code>A</code>를 가지고 있습니다. 둘이 동형에 가까울 거라 예측해 볼 수 있는 대목입니다.</p>
<p>저는 함수를 <strong>차이</strong>로 해석하기도 하는데, <code>Hom(-,A)</code>와 <code>F</code>의 차이를 나타내는 자연 변환과 <code>F A</code>가 같다고 직관적으로 읽히기도 합니다.</p>
<p>눈에 보이는대로 해석해 보면,</p>
<ul>
<li>임의의 펑터<code>F</code>를 대상<code>A</code>에 적용:<br />
<code>F:_ -&gt; 구현</code>을 <code>A</code>에 적용하면 <code>A -&gt; 구현</code>이 됩니다.</li>
<li>임의의 펑터<code>F</code>를 <code>A</code>를 가진 홈펑터와 차이로 변환:<br />
홈펑터<code>Hom(_,A)</code>와 <code>F</code>의 차이, 즉 자연 변환 <code>Φ</code>는 <code>_ -&gt; A</code>와 <code>_ -&gt; 구현</code>의 차이니 <code>(A -&gt; 구현)∘</code>이 됩니다.</li>
</ul>
<p><strong><code>Φ</code>에는 이미 <code>_-&gt;구현</code>도 <code>A</code>도 미리 들어가 있습니다.</strong></p>
<h3 id="증명">증명</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>                         f</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>           A     ----------------&gt;    X</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                     Hom(A,f)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a> id_A = Hom(A,A) ----------------&gt; Hom(A,X) = f</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>           |                           |</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>       Φ_A |                           | Φ_X</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>           v                           v</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>          F A    ----------------&gt;    F X</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>          = u           F f</span></code></pre></div>
<p>대부분의 텍스트들이 어째서 <code>u</code>만 결정되면, 위 가환 다이어그램이 완전히 정해지는지 후루룩 얘기하고 넘어 갑니다. 여러 텍스트를 봐도 이해가 잘 안가, 역시나 상상을 곁들여 쫓아가 봤습니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>F X = (  F f) u -- 아래 쪽 경로</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>F X = (Φ_X f)   -- 오른 쪽 경로</span></code></pre></div>
<p>우선 보이는 대로, 제 방식대로 직관적으로 읽으면, <strong>f를 F로 변환한 것과, f를 Φ_X로 변환한 것의 차이는 u</strong>입니다. <code>u</code>가 isomorphism에서 어떤 역할을 할 것 같이 보이는 대목입니다.</p>
<p>※ 여러 개의 텍스트를 동시에 보다 보니, 표기가 마구 섞여 있습니다. <code>Hom(-,A)</code>에 대한 것을 모두 확인했다면, <code>Hom(A,-)</code>는 화살표만 모두 뒤집으면 그대로 성립하는 듀얼이라 합니다. 듀얼에 대한 심상이 아직 명확하지 않지만, 어쨌든 한 쪽을 알면, 간단히 다른 한 쪽도 알 수 있어서, 그 때 그 때 필요한 걸로 설명을 풀어가고 있습니다.</p>
<h3 id="왜-u만-알면-가환-다이어그램이-결정되지">왜 u만 알면, 가환 다이어그램이 결정되지?</h3>
<p>좀 더 자세히 해석해 보겠습니다. (검증 필요)<br />
목표는 <code>Φ</code>와 <code>F</code>가 일대일 대응인지를, 즉 <code>Φ</code>가 정해지면 유일한 <code>F</code>가 정해지고, 거꾸로 <code>F</code>가 정해지면 유일한 <code>Φ</code>가 정해지는지를 봅니다.</p>
<ol type="1">
<li><p><code>F:C -&gt; Set</code>임을 상기하고,</p></li>
<li><p>우선 <code>F A</code>에 있는 원소에 <code>Φ</code>로 매핑하는 걸, 적어도 하나는 찾을 수 있습니다. <code>Φ</code>의 <code>A</code>성분 <code>Φ_A</code>는 어찌되나 보면,
<code>Φ_A: Hom(A,A) ------&gt; (F A)</code>로 변환합니다. <code>A-&gt;A</code>인 모피즘으로 <code>id_A</code>는 항상 존재하니, <code>id_A</code>와 대응 되는 <code>Φ_A(id_A)</code>가 <code>F A</code>에 존재합니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>Φ_A(id_A) ∈ F A</span></code></pre></div></li>
<li><p>이제 <code>F A</code>의 원소들을 <code>u1</code>, <code>u2</code>,… 라 하면, 이 중에 <code>Φ_A(id_A)</code>가 되는 <code>u_</code>가 있을테고, 이 <code>u_</code>가 <strong>유일한 자연 변환 Φ</strong>와 대응된다면, <code>u</code>만 정해지면 위 가환 다이어그램이 결정된다고 볼 수 있습니다.</p></li>
<li><p>홈펑터 <code>Hom(A,-)</code>와 <code>F</code> 펑터로 Naturality Condition을 보면, 위 가환 다이어그램이 나옵니다. 가환 다이어그램을 잘 쫓아가 보면, 여기에 <code>Φ_A(id_A) = u</code>(왼 쪽 아래 <code>F A</code>)가 있습니다.</p></li>
<li><p>상상 - <code>Φ2: Nat(Hom(B,-), F)</code>나 <code>Φ3: Nat(Hom(C,-), F)</code>…등의 가환 다이어그램은 <code>Φ2_A(id_A)</code>, <code>Φ3_A(id_A)</code> 정의가 없습니다. <code>Φ_A(id_A) = u</code>를 찾는 다면 유일하게 <code>Φ: Nat(Hom(A,-),F)</code>를 고를 수 있습니다.</p></li>
<li><p><code>F A</code>의 원소 중 <code>u</code>만 정해지면 <code>Φ</code>가 결정됐습니다. 목적지에 도달했습니다.</p></li>
</ol>
<p>위 다이어그램은 <code>F</code>, <code>A</code>에 대해서 Natural 합니다. 특정 <code>F</code>여야만, 특정 <code>A</code>여야만 성립하는 것이 아니란 말입니다. <code>C-&gt;Set</code>인 어떤 <code>F</code>를 받아도 성립하는 건 알겠는데, <code>A</code>는 <code>Hom(A,-)</code>로 정해진 게 아닌가 생각했습니다. 제대로 람다식은 아니지만, 마치</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>\F A -&gt; Nat(Hom(A,-),F) = F A</span></code></pre></div>
<p>이렇다는 말입니다. <code>F</code>는 펑터니, 모든 대상에 정의될테고, 그런 <code>F</code>를 고르고, 아무 대상 <code>A</code>를 골라도 이 식은 성립한다는 얘깁니다. Natural이란 말을 언제 쓰나 살짝 모호한감이 있었는데, 이런 의미인가 봅니다.</p>
<p>대상이나 모피즘이 아닌, 위 가환 다이어그램 자체를 하나의 단위 오브젝트처럼 생각할 수 있겠습니다. <code>F</code>, <code>A</code>가 결정되면 Naturality Condition(자연 변환의 가환 다이어그램)이 결정됩니다.</p>
<p>내가 관심 갖는 대상은 <code>B</code>라 했을 때, 이 <code>B</code>를 <code>F</code>로 옮기면, <code>F B</code>가 됩니다. <code>Hom(B,-)</code>는 이 <code>B</code>와 연관된 모피즘을 의미합니다. 자연 변환은 각 성분을 보는 게 도움이 될 때가 많습니다. 위 Naturality Condition은 <code>B</code>와 연관된 모든 모피즘에 <code>F</code>를 먼저 적용해 옮겨버릴 방법을 미리 준비하는 것과, <code>F</code>로 옮긴 상태의 관계입니다. 각 대상과 모피즘에 동작할 <code>F</code>의 성분들을 미리 변형해 둔 것과, 그냥 <code>F B</code> 를 한 상황에서 다른 모든 대상들과 관계를 표현한 <code>Hom(F B,-)</code>를 보면 같다는 뜻입니다. 비유해서 그리면</p>
<figure>
<img src="../images/yoneda3.jpg" alt="요네다 비유" /><figcaption aria-hidden="true">요네다 비유</figcaption>
</figure>
<p>두 점이 있는데, 한 점을 멀리 옮긴(<code>F</code>) 다음에 선을 긋든(<code>홈펑터</code>), 미리 선을 길게해서(<code>홈펑터</code>와 <code>F</code>의 자연변환) 준비해서 두 점 사이에 놓든 결과는 같습니다. 비유하자면, 자의 눈금을 바꾸고 쟀다거나, 기준점을 옮겼다고 상상해 볼 수 있습니다. 공부하면서, 중간 중간 혼동했는데, 화살표를 늘리는 “동작”과 결과 값인 “<code>F B</code>”가 같다가 아니라, 일대일 대응시킬 수 있다는 얘기입니다.</p>
<p>저는, ““<strong>내가 움직여서 내가 뭔가를 만들어내서 변한다면 Covariant하지만, 나는 가만히 있는데, 남이 무언가 만들어서(주변이 변해서) 내가 변한다면(변한 것처럼 된다면) Contravariant</strong>”란 심상을 가지고 있습니다.</p>
<p>요네다는 이런 아이디어를 완벽하게 수식으로 기술하고 있습니다. 홈펑터 아이디어 형식화부터도 신기한데, 여기에 펑터 적용한 게 원래의 것과 일정하게 대응되는 걸 보니 아름답네요. 카테고리란 체계를 만든 게 이런 아이디어를 표현하는데 딱일 것을 미리 상상했을까요. 천재들의 머릿속은 알 수 없으니, 감탄만 하고… 잘 써먹으면 됩니다.</p>
<blockquote>
<p>※ 단순히 화살표를 확장시키는 건, <code>F</code>가 엔도 펑터가 아닌데, 오해를 살 수 있다 지적해주셨습니다.<br />
이에 부연 설명을 하자면, <code>B</code>를 가리키는데는 주변 화살표의 “길이”로 <code>B</code>를 특정 짓는다고 가정해 보겠습니다. <code>F</code>펑터로 다른 카테고리로 보냈더니, 화살표의 길이가 달라졌습니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>h_B: Hom(-,B)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>Φ: h_B-&gt;F 자연변환</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>f_A: A-&gt;B 모피즘</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>f_B: B-&gt;B 모피즘</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>f_C: C-&gt;B 모피즘</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>((Φ_A(h_B))f_A)A = F B</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>^^^^^^^^^^^^^^^^</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    f_A변환</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>((Φ_B(h_B))f_B)B = F B</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>^^^^^^^^^^^^^^^^</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    f_B변환</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>((Φ_C(h_B))f_C)C = F B</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>^^^^^^^^^^^^^^^^</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    f_C변환</span></code></pre></div>
<p>이렇게 <code>C</code>카테고리에 있던 <code>A-&gt;B</code>,<code>B-&gt;B</code>,<code>C-&gt;B</code> 모피즘들이 <code>Set</code> 카테고리로 옮겨가면서 변환되는 걸 은유했습니다. (아주 특수한 경우로, <code>Set</code>로 가면서 오브젝트들과 멀어졌다는 상상을 했습니다.)</p>
<p>“<code>B</code>가 무슨 역할을 할지를 <code>A</code>,<code>C</code>와의 거리로 표현(은유?상징?)한다면,<br />
<code>B</code>를 움직이든, <code>B</code>는 가만히 두고 <code>A</code>,<code>C</code>를 벌리든 같은 정보를 표현할 수 있다”</p>
<p>로 요네다 정리를 이해하고 있습니다.</p>
</blockquote>
<p><strong>생각 스트레칭 - 상상</strong><br />
예를 들어 <code>func(f) = f x</code>의 구현을 결정 짓는 건 <code>x</code>에 달려 있습니다. <code>f</code>부분은 이 <code>func</code>의 특징이 아닙니다.<br />
<code>func1(f) = f 1</code>, <code>func2(f) = f 2</code>, … 이렇게 되어 있다면, <code>x=1</code>이라면 <code>func1</code>을 고를 것이며, <code>x=2</code>이라면 <code>func2</code>를 고를 것입니다. 다시 말해, <code>x</code>만 정해지면 <code>func1</code>, <code>func2</code>,…들 중에 무엇을 고를지 결정됩니다. 모피즘 <code>func~</code>와 대상<code>x</code>는 일대일 대응입니다. (<code>f</code>가 정수를 받는 함수라는 제약이 있긴 하지만, 여기선 이 게 <code>func1</code>과 <code>func2</code>의 구별 요소는 아니라는 얘깁니다.)</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>1 --&gt; func1</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>2 --&gt; func2</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>a --&gt; \f = f a </span></code></pre></div>
<p><code>(F f) u = Φ_X f</code><br />
이 식에서 <code>f</code>와 <code>X</code>는 외부에서 나중에 들어 올, 위 예시의 고차 함수가 같은 것들입니다. 이 식을 결정하는 건 <code>u</code>입니다.</p>
<h3 id="동형임을-보이려면">동형임을 보이려면</h3>
<p>여기 저기 텍스트를 찾아 다녔는데, 위 가환 다이어그램만 써서 증명이 끝나는 곳도 있고, 각 펑터로 바라보고 Natrual isomorphic을 확인해서 증명하는 곳도 있는 듯 합니다.</p>
<p>※ 첫 눈에는 자연 변환과 대상이 같다로 오해했는데, 같다가 아니라 동형입니다.
<code>Φ: Nat(Hom(A,-),F)</code>는 <code>u=F A</code>와 같다(<code>=</code>)가 아니라, 동형(<code>~=</code>)입니다.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>α: Φ -&gt; u </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>β: Φ &lt;- u </span></code></pre></div>
<p>두 함수가 있고, 이들을 합성해서 <code>α∘β = id_Φ</code>, <code>β∘α = id_u</code>가 되는 걸 보여야 <code>Φ</code>와 <code>u</code>, 즉 <code>F A</code>가 동형임을 보이게 됩니다.</p>
<p>우선 <code>α</code>부터 보겠습니다.
&gt;<code>haskell α : Nat(Hom(-,A),F) -&gt; F(A)</code></p>
<pre class="deafult"><code>     Hom(-,A)       F(A)
(A-&gt;A)와 F의 차이 -&gt; u1
(B-&gt;A)와 F의 차이 -&gt; u1 
(C-&gt;A)와 F의 차이 -&gt; u1
...

     Hom(-,A)       F(A)
(A-&gt;A)와 F의 차이 -&gt; u2
(B-&gt;A)와 F의 차이 -&gt; u2 
(C-&gt;A)와 F의 차이 -&gt; u2
...

...</code></pre>
<p><code>u</code>가 정해지면,<code>Φ</code> 가환 다이어그램으로 위 그룹 중 하나를 특정지을 수 있습니다.<br />
트릭으로 <code>(A-&gt;A)</code>로 <code>id_A</code>는 항상 존재하니, 가장 만만한 <code>(A-&gt;A)</code>를 골라서 보겠습니다.(<code>A</code>를 고르는 이유 검증 필요)</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>α <span class="ot">=</span> \Φ <span class="ot">-&gt;</span> Φ_A(id_A) <span class="co">-- Φ ↦ Φ_A(id_A) </span></span></code></pre></div>
<p>자연 변환 <code>Φ</code>에 <code>id_A</code>를 넣어 주면 <code>F A</code>를 알 수 있습니다. 만일 <code>(B-&gt;A)</code>인 어떤 모피즘을 넣어 준다해도, <code>id_A</code>일 때 나온 <code>F A</code>와 같아지는 <code>Φ</code>일테니, 무엇을 넣든, <code>id_A</code>로 결정된 <code>F A</code>는 바뀌지 않습니다. 한 마디로 <code>Hom(-,A)</code>에 속한 모피즘들 중 아무거나에 <code>Φ</code>를 적용하면 <code>F A</code>를 알 수 있는데, 그 중 가장 단순한 <code>id_A</code>를 넣고 있습니다. (<code>Φ</code>는 성분별로 봐야되는 걸 떠올리면 이해에 도움이 됩니다.)</p>
<p>이제 <code>β: u -&gt; Φ</code>를 보겠습니다.<br />
<code>u = F A</code>를 선택하면 유일한 <code>Φ</code>가 결정되어야 합니다.<br />
이미 이전 섹션에서 가환 다이어그램이 <code>F A</code>로 결정된다는 걸 보았습니다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>\u <span class="ot">-&gt;</span> (<span class="dt">F</span> f) u <span class="ot">=</span> Φ_X(f) 가환 다이어그램이 결정된다<span class="op">.</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>      <span class="op">^^^^^^^^^^^^^^^^</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>             Φ를 특정지을 수 있는 속성</span></code></pre></div>
<p>이 걸로 증명을 마무리하는 텍스트들이 많은데, 전 Natural isomorphic을 보는 쪽이 더 명확하게 보였습니다.</p>
<p><a href="https://youtu.be/BiWqNdtptDI?list=PLbgaMIhjbmElia1eCEZNvsVscFef9m0dm&amp;t=1328">Category Theory II 4.2: The Yoneda Lemma</a> 영상에서 보여주는 증명을 따라가 보겠습니다.<br />
<code>Nat(Hom(A,-)</code>와 <code>F A</code>가 동형인가를 보기 위해, 둘이 자연 동형Natural isomorphic인지 보는 방법입니다.<br />
(<span class="citation" data-cites="Ailrun님이">@Ailrun님이</span> 해석 방법을 알려주셨습니다. 감사합니다.)<br />
둘이 자연 동형인지 보려면 둘의 공통 근원이 되는 게 있어야 합니다.</p>
<p>(※ 대소문자 표기와, 홈펑터 표현들이 좀 다른데, 여기선 위 영상을 따라 가겠습니다.)<br />
<code>F a</code>를 <code>F:[C,Set]</code>와 <code>a:C</code>를 받아서 <code>Set</code>를 만드는 펑터로 봅니다.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>F a : [C,Set] × C -&gt; Set</span></code></pre></div>
<p><code>Φ:[C,Set](C(a,-),F)</code>도 마찬가지로 봅니다. 자연 변환이지만, 여기서는 Set로 가는 펑터로 보고 있습니다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>[C,Set](C(a,-),F) : C × [C,Set] -&gt; Set</span></code></pre></div>
<p>영상에서는 <code>C × [C,Set] -&gt; Set</code>으로 통일합니다.<br />
이제 이 두 펑터가 <code>C×[C,Set]</code>인 <code>(F,a)</code>를 변환하는 걸 Natural Square를 그려서 자연 동형을 확인합니다. 모든 F, a 조합에 Φ와 F a가 자연 동형임을 보이면 증명이 완성됩니다. <code>(F,a)</code>를 <code>Φ</code><strong>펑터</strong>를 거쳐 변환된 것과, <code>F</code><strong>펑터</strong>를 거쳐 변환된 것(영상에서 이 부분을 Functor Application이라 부르고 있습니다.)의 관계를 봅니다.</p>
<figure>
<img src="../images/yoneda_proof.jpg" alt="요네다 보조 정리 증명" /><figcaption aria-hidden="true">요네다 보조 정리 증명</figcaption>
</figure>
<p><code>(F,a) -&gt; (G,b)</code>와 <code>F a -&gt; G b</code>를 보겠습니다. <code>(F,a)</code>란 프로덕트 카테고리이니, <code>μ: F-&gt;G</code>, <code>u: a-&gt;b</code>를 각각 봐서 <code>(μ,u)</code>가 됩니다. <code>F</code>와 <code>G</code>는 펑터이니, 각 성분별로 보면 <code>μ_x: F x -&gt; G x</code>로 표현하고 있습니다. 그럼 <code>F a -&gt; G b</code>는 <code>F a</code>에 <code>μ</code>를 적용해서 <code>G a</code>로 바꾼 후 <code>G</code>의 <code>fmap</code>으로 <code>a</code>를 <code>b</code>로 바꿉니다. <strong>G u ∘ μ_x</strong><br />
※ 혹 <strong>G u</strong>가 어색하다면, 보통 <code>f</code>에 <code>F</code>를 적용해서 <code>F f</code>가 되는 걸, 코드로 생각하면 <code>F f</code>란 <code>F</code>의 <code>fmap</code>으로 <code>f</code>를 변환한 것입니다.</p>
<p><code>(F,a) - &gt; (G,b)</code>와 <code>[C,Set](C(a,-),F)</code> -&gt; <code>[C,Set](C(b,-),G)</code>를 보겠습니다.<br />
<code>C(a,-)</code>, <code>F</code>, <code>G</code>는 펑터니 자연 변환은 성분을 봐야합니다.<br />
<code>α_x = C(a,x) -&gt; F x ---&gt; (a-&gt;x) -&gt; F x</code><br />
<code>β_x = C(b,x) -&gt; G x ---&gt; (b-&gt;x) -&gt; G x</code><br />
<code>(b-&gt;x)</code>가 <code>(a-&gt;x)</code>가 되려면, <code>u: a-&gt;b</code>, <code>μ_x: F x-&gt;G x</code>를 써서 <strong>μ_x∘α_x∘u</strong><br />
보기 좋게 원래 원했던 식<code>(F f) u ~= ϕ_x(f)</code>과 딱 떨어지는 모양이 나오면 좋겠지만, 증명은 아래와 같이 끝납니다.</p>
<p>(가). <code>(F,a)</code>는 <code>F</code>와 <code>a</code>에만 의존해서 결정되니, <code>(G,b)</code>도 <code>u: a-&gt;b</code>, <code>μ:F-&gt;G</code>에만 의존해서 표현할 수 있습니다.<br />
(나). <code>F a</code>도 <code>F</code>와 <code>a</code>에만 의존해서 결정되니, <code>G b</code>도 <code>u</code>,<code>μ</code>에만 의존해서 표현할 수 있어야 합니다.<br />
(다). <code>[C,Set](C(a,-),F)</code>도 <code>F</code>와 <code>a</code>에만 의존해서 결정되니, <code>[C,Set](C(b,-),G)</code>도 <code>u</code>,<code>μ</code>에만 의존해서 표현할 수 있어야 합니다.</p>
<p>(가)는 <code>(μF, ua)</code><br />
(나)는 <code>G u ∘ μ_x</code><br />
(다)는 <code>μ_x∘α_x∘u</code></p>
<p>정리하면 <code>F a</code>도 <code>F</code>와 <code>a</code>에만 의존해서 결정되고, <code>Φ: [C,Set](C(a,-),F)</code>도 <code>F</code>와 <code>a</code>만 의존해서 결정되므로 둘은 동형이란 얘깁니다. 수식으로 딱 떨어지는 걸 보고 싶었는데, 영상에선 이렇게 끝을 맺고 있습니다.</p>
<h2 id="결론">결론</h2>
<p>더 추상적으로 얘기하면, 함수 두 개 <code>f</code>, <code>g</code>가 <code>f(a,b)</code>로 <code>a</code>, <code>b</code>에만 의존하고, <code>g(a,b)</code>도 역시 <code>a</code>, <code>b</code>에만 의존한다면 둘 사이의 일정한 대응 관계를 만들 수 있습니다. 값이 고정되어 있지 않은 폴리모픽, 즉 <code>forall a</code>, <code>forall b</code>와의 관계에만 의존해서 결과가 결정되는, 둘에게서 (어떤 절차를 거치면) 같은 정보를 뽑아낼 수 있습니다.<br />
<code>a</code>를 <code>b</code>에 적용할 함수(펑터)로 보면, 가장 간단하게 <code>a</code>, <code>b</code> 정보를 가지고 있는 식은 <code>a</code> <code>b</code> 입니다.</p>
<p>도메인, 코도메인이 같은 어떤 두 펑터 <code>F</code> (<code>a -&gt; Fa</code>,<code>f -&gt; Ff</code>)와 <code>G</code> (<code>a -&gt; Ga</code>,<code>f -&gt; Gf</code>)의 자연 변환 성분을 보면<br />
<code>Fa</code>와 <code>Ga</code>의 차이<br />
<code>Ff</code>와 <code>Gf</code>의 차이<br />
입니다. 자연 변환 자체는 <code>a</code>, <code>f</code>에만 의존하고 있습니다.<br />
</p>
<p>이 자연 변환이 바로 둘의 <strong>일정한 관계</strong>를 뜻합니다. 아주 확실한 건 아닙니다만, 아주 아주 축약해서 얘기하면, <strong><em>요네다는 자연 변환 성질을 얘기한 것</em></strong>인가라는 생각이 듭니다.</p>
<p><code>C</code> 카테고리 자체가 어떤 복잡한 구성, 구조를 가지고 있든 간에,<br />
[모든 구성원이 <code>a</code>에 의존하게 만드는 펑터(<code>:C-&gt;Set</code>)]와,<br />
[임의의 펑터 <code>F:C-&gt;Set</code>] 사이의<br />
자연 변환 자체는 <code>F</code>, <code>a</code>에만 의존할 거라 추측할 수 있습니다.</p>
<p>조금 더 복잡하게 얘기하면, 위 자연 변환 자체를 또 펑터로 보고(뎁스가 이렇게 깊어지는 건 저도 별로 안 좋아합니다만, 위 증명을 그대로 쓰면)<br />
[[모든 구성원이 a에 의존하게 만드는 펑터] -&gt; [임의의 펑터 F]] 펑터(여기선 자연 변환이 아닌 <code>[C,Set] × C -&gt; Set</code>펑터)와<br />
[(a,F) -&gt; F a] 펑터<br />
사이에 존재하는 자연 변환을 정의할 수 있으니, [모든 구성원이 a에 의존하게 만드는 펑터]는 <code>a</code>와 동등한 의미를 가지고 있다는 결론에 도달합니다.<br />
</p>
<p>너무 결론으로 훅 점프한 것 같긴한데, 조금 더 힌트가 될만한 말을 덧붙이자면, 펑터는 <code>C</code>를 변형하는 동작이지, <code>C</code>가 아닙니다. <code>F</code>를 <code>x</code>에 적용해서 나오는 “값”은 <code>x</code>에 의존하지만, <code>F</code>자체가 어떤 동작을 할지는 <code>x</code>에 의존하는 것이 아닙니다. <code>F i = +i</code> 함수를 <code>x</code>에 적용한다면, <code>x+i</code>가 됩니다. <code>F</code>는 <code>i</code>에 의존해서 동작이 결정되고, 이를 <code>x</code>에 적용합니다. 이 동작만 떼 내어 보는 겁니다. 홈펑터는 <code>홈펑터 a = a -&gt;</code>라는 함수로 보고, 이 홈펑터의 동작은 <code>a</code>에만 의존한다 말하고 있습니다.</p>
<p>요네다 벽을 넘고 나면, 카테고리 이론을 이해하는데 도움이 된다고 하는데, 자연 변환에 대한 인사이트(한 눈에 보이진 않지만, 본질적인 의미)가 생겨서 그렇다는 뜻 아닐까 합니다.</p>
<h2 id="하스켈에서-요네다-보조-정리의-의미">하스켈에서 요네다 보조 정리의 의미</h2>
<p>카테고리 이론의 지상 최대 과제는, “모든 것들을 관계로 설명하자”입니다. 요네다는 이 말을 그대로 이론으로 보여주고 있습니다. <code>A</code>에 <code>F</code>를 적용하는 것은 <code>A</code>를 나타내는 <code>Hom(A,-)</code>와 <code>F</code>의 자연 변환으로 대체할 수 있다는 말입니다. 안 그래도 추상화에 추상화로 머리가 터지는데, 애초에 홈펑터로 시작하면 얼마나 복잡할까 싶습니다. 함부로 건드릴 대상은 아니지만, 거의 모든 걸 함수, Computation으로 보려는 하스켈에서 무언가를 같게(동형) 보는 작업은 매우 중요합니다. 현재까지는, 동형으로 보기 위한 3대장 테크닉이 모나드, Adjunction, 요네다 정리로 생각됩니다. 모나드를 제외하면 직접적으로 쓸 일이 많지 않겠지만, 현실을 모델링할 때 영감을 주는 역할을 할 수 있을거라 믿습니다.<br />
※ 지금은 설명할 정도로 잘 알지 못하지만, 어렴풋이 셋의 연결 고리가 보입니다.</p>
<h2 id="하스켈-코드로-보는-요네다-보조-정리">하스켈 코드로 보는 요네다 보조 정리</h2>
<p><a href="https://gist.github.com/Icelandjack/02069708bc75f4284ac625cd0e2ec81f">Icelandjack/Yoneda_II.markdown</a><br />
<a href="https://scturtle.me/posts/2015-06-16-yoneda.html">scturtle.me - yoneda</a><br />
<a href="https://bartoszmilewski.com/2015/07/13/from-lenses-to-yoneda-embedding/">from Lenses to Yoneda embedding - 바르토즈 밀레프스키</a></p>
<p>아래 코드는 <a href="https://bartoszmilewski.com/2013/05/15/understanding-yoneda/">Understanding Yoneda - 바르토즈 밀레프스키</a>에서 발췌했습니다.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="ot">imager ::</span> <span class="kw">forall</span> r <span class="op">.</span> ((<span class="dt">Bool</span> <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> [r])</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>imager <span class="ot">=</span> <span class="op">???</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Blue</span>        <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Note</span>  <span class="ot">=</span> <span class="dt">C</span> <span class="op">|</span> <span class="dt">D</span> <span class="op">|</span> <span class="dt">E</span> <span class="op">|</span> <span class="dt">F</span> <span class="op">|</span> <span class="dt">G</span> <span class="op">|</span> <span class="dt">A</span> <span class="op">|</span> <span class="dt">B</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>colorMap x <span class="ot">=</span> <span class="kw">if</span> x <span class="kw">then</span> <span class="dt">Blue</span> <span class="kw">else</span> <span class="dt">Red</span> <span class="co">-- Bool -&gt; (r=Color)</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>heatMap  x <span class="ot">=</span> <span class="kw">if</span> x <span class="kw">then</span> <span class="dv">32</span>   <span class="kw">else</span> <span class="dv">212</span> <span class="co">-- Bool -&gt; (r=Int)</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>soundMap x <span class="ot">=</span> <span class="kw">if</span> x <span class="kw">then</span> <span class="dt">C</span>    <span class="kw">else</span> <span class="dt">G</span> <span class="co">-- Bool -&gt; (r=Note)</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> imager colorMap</span></code></pre></div>
<p>위 imager 함수를 구현할 때 요네다 보조 정리를 쓰면,</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>forall r. ((a -&gt; r) -&gt; f r) ~= f a</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>           ^^^^^^^^^^^^^^^^</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>      자연변환: Hom(a,-) -&gt; F -</span></code></pre></div>
<p>바로 <code>a</code>에서 다른 모든 대상 <code>forall r.</code>으로 가는 모피즘의 집합, Covariant 홈펑터 <code>Hom(a,-)</code>입니다.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">imager ::</span> <span class="kw">forall</span> r <span class="op">.</span>((<span class="dt">Bool</span>   <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span>  [r])</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="co">--                   (고정값 -&gt; r)   펑터[] </span></span></code></pre></div>
<p>요네다 보조 정리에 따라 위 식은 <code>[Bool]</code>과 같은 의미를 가지고 있습니다. 위 서명에 맞게 구현하려면, <code>[Bool]</code>에 따라 고유한 자연 변환 스퀘어가 나온다는 걸 요네다가 알려 줍니다. 예를 들어 <code>[True, False, True, True]</code> 이런 값이 있다면, 이에 대응하는 자연 변환은 한 가지 뿐입니다.<br />
반대로 <code>imager</code>이 갖고 있는 <code>[Bool]</code>을 찾고 싶다면, <code>Bool -&gt; r</code>자리에 <code>id</code> 를 넘겨주면 됩니다.</p>
<p>홈펑터부터 살펴 보겠습니다. 아래 그림에서 모피즘도 봐야되지만, 펑터들의 차이를 보기 위해 대상이 변환되는 것만 보겠습니다.</p>
<figure>
<img src="../images/yoneda_ex1.jpg" alt="Hom(A,-)펑터와 리스트 펑터" /><figcaption aria-hidden="true">Hom(A,-)펑터와 리스트 펑터</figcaption>
</figure>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">imager ::</span> <span class="kw">forall</span> r <span class="op">.</span> ((<span class="dt">Bool</span> <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> [r]) <span class="co">-- 자연 변환</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co">--                       홈펑터      F</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>imager iffie <span class="ot">=</span> <span class="fu">fmap</span> iffie [<span class="dt">True</span>, <span class="dt">False</span>, <span class="dt">True</span>, <span class="dt">True</span>] <span class="co">-- 자연 변환이 [Bool]을 가지고 있다.</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="ot">idBool ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>idBool x <span class="ot">=</span> x</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> imager idBool</span></code></pre></div>
<p><code>F: C -&gt; Set</code>인 어떤 펑터든 <code>Hom(A,-)</code>홈펑터와 자연 변환을 생각해 볼 수 있습니다. 마치, <strong>홈펑터를 기준으로</strong> 삼고, 다른 펑터들을 갖다 대서 비교해 본다고 생각할 수 있습니다. 여기선 리스트 <code>[]</code> 펑터로 예를 들고 있습니다.</p>
<p>※ 마치 기준점이 <code>0</code>일 때 <code>3</code>이면, 기준점을 <code>1</code>로 옮기면 <code>2</code>라는 값으로 Contravariant하게 바뀌는 것과 비슷합니다. HomFunctor로 기준점을 바꿔 놓는 걸로 비유할 수 있습니다.</p>
<figure>
<img src="../images/yoneda_ex2.jpg" alt="자연 변환이 Bool 리스트를 가지고 있다" /><figcaption aria-hidden="true">자연 변환이 Bool 리스트를 가지고 있다</figcaption>
</figure>
<p><code>Nat(Hom(A,-), F)</code>가 딱 <code>F a</code>가 나와야만 할 것처럼 오해할 수 있습니다. 딱 <code>F a</code>가 나오는 것은 아니고, up to isomorphism 동형입니다. <strong>자연 변환으로 변환한 펑터가 적용된 값이 아니라</strong>, 자연 변환 자체가 <code>F a</code>와 대응한다는 말입니다. 위 그림에서 <code>\h-&gt;fmap h [Bool]</code>이 자연 변환입니다. 이 자연 변환은 <code>[Bool]</code>과 일대일 대응할 수 있습니다.<br />
<code>[True]</code>라면 <code>\h-&gt;fmap h [True]</code><br />
<code>[True,False,True,False,True]</code>라면 <code>\h-&gt;fmap h [True,False,True,False,True]</code>와 대응합니다.<br />
자연 변환은 <code>F a</code>에 의해서 결정됩니다.</p>
<h2 id="어째서-이런-일이-생길까">어째서 이런 일이 생길까?</h2>
<p><strong><code>a</code>에 <code>F</code>를 적용해서 <code>F A</code></strong><br />
<strong><code>Hom(a,-)</code> 펑터와 <code>F</code>펑터의 차이(자연 변환)</strong></p>
<p>어째서 위 두 개가 같은 정보를 담을 수 있을까요? (두 개는 동형 up to isomorphism 입니다.)<br />
필요한 것은 <code>F</code>와 <code>a</code>입니다.<br />
<code>a</code>를 가리킬 수 있는 다른 표현, <strong><em>Hom(a,-)는 a와 (자신 포함) 모든 대상들과의 관계로 a를 가리킬 수 있습니다.</em></strong> 그럼 <code>a</code>에 <code>F</code>를 적용하듯, <code>Hom(a,-)</code>에도 <code>F</code>를 “적용”하는 것과 비슷한 동작을 찾아봐야 합니다. 그래서 동일하게 <code>F a</code>와 동형인 결과가 나오는지 확인해야, <code>Hom(a,-)</code>가 정말 <code>a</code>를 가리키는 또 다른 표현으로 받아들일 수 있습니다.<br />
<code>Hom(a,-)</code>는 모든 대상을 <code>a</code>와 연관 짓습니다. 이 걸 다른말로 하면, 모든 대상을 <code>a</code>를 받는 함수로 만든다는 말입니다. 그냥 <code>b</code>,<code>c</code>,…로 있던 대상들을 <code>a-&gt;b</code>,<code>a-&gt;c</code>,…로 <code>a</code>를 받아야만 값이 되도록 모두 바꿔 놓았습니다.</p>
<p><code>b</code>를 홈펑터 <code>Hom(a,-)</code>로 변환한 값은 <code>a</code>를 필요로 하는 <code>a-&gt;b</code>이지만, 펑터<code>F</code>로 변환한 값은 <code>F b</code>입니다. 이 때 두 펑터의 차이를 구한다면, 즉 <code>Hom(a,-)</code>를 거친 후 <code>F a</code>에 도달하려면 어떤 과정을 거쳐야 하는지 본다면,</p>
<p><strong>“어디엔가는 a가 있어야만 합니다.”</strong></p>
<p><code>Hom(a,-)</code>에는 <code>a</code>가 있지 않습니다. <code>a</code>를 받을 수 있지, 가지고 있지는 않습니다. 이 펑터가 <code>F a</code>에 도달하려면, 결국 <code>Hom(a,-)</code>와 <code>F</code>의 자연 변환이 <code>a</code>를 가지고 있어야만 합니다. 대상을 모피즘 집합으로 표현하면서, <strong><em>원래 대상은 자연 변환에 담아 뒀습니다.</em></strong></p>
<p>요네다를 모를 때, 프로그래머 지식으로 Contravariant를 해석한 직관이었는데, 요네다 동작을 살필 때도 떠올려 볼만합니다.</p>
<h2 id="lens">Lens</h2>
<p>이제, 이런 결과를 Lens에 어떻게 적용하는지 볼 차례입니다. 많은 내용을 그대로 얘기해야 하니 <a href="https://lionhairdino.github.io/posts/2021-05-13-lens.html#%EC%99%9C-%ED%8E%91%ED%81%AC%ED%84%B0%EA%B0%80-%EB%93%A4%EC%96%B4%EA%B0%80-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94">Lens 정의에 왜 펑터가 들어가 있을까요?</a>를 같이 봐주세요. 링크 글에서는 요네다 보조 정리를 모르는 상황에서 코드만으로 따라 갔는데, 이제 요네다 보조 정리를 알고 있는 상태에선 어떤 식으로 접근하는지 살펴 보겠습니다.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensModify</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> s)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensGetter</span> s a <span class="ot">=</span> s <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>둘을 모양이 비슷하게 보려합니다.</p>
<p>“<code>A-&gt;_</code>와 <code>B-&gt;_</code>의 차이는 <code>∘(B-&gt;A)</code>”이다는 요네다 임베딩을 적용하면, (<code>B</code>를 <code>s</code>로, <code>A</code>를 <code>a</code>로)<br />
<code>(g:a -&gt; _)</code>가 <code>(s -&gt; _)</code>가 되려면 <code>∘(h:s -&gt; a)</code> 필요합니다.<br />
그럼, 아래 모양을 같게 볼 수 있나라는 문제에 도달했습니다. (다른 텍스트를 보고 해석한 것이 아니라 저 혼자 추측이라 아직 확실하진 않습니다.)</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensModify</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> s)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensGetter</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> _) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> _) </span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co">--                    ^^^^^^^^^^^^^^^^^^^^</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co">--                    (a-&gt;s)와 (s-&gt;s)의 차이는 (s-&gt;a)입니다.      </span></span></code></pre></div>
<p>이제 GHC한테 맡길 방법을 찾아야 합니다. 아래와 같이 멀쩡한 타입에다 폴리모픽 펑터를 붙입니다.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensModify</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> f s) </span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensGetter</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> f a) <span class="co">-- _ 자리에 f a를 넣었습니다.</span></span></code></pre></div>
<p><code>f</code>를 폴리모픽하게 두고, GHC가 채워넣게 해서 어쩔 땐 <code>a</code>를, 어쩔 땐 <code>s</code>를 고르게 한다면, 하나의 모양으로 표기할 수 있습니다. (물론, <code>f</code>안의 값을 보기 위해 패턴매칭을 하는 <code>run f</code>과정이 필요하지만 가지고 있는 정보 자체는 달라지지 않습니다.)</p>
<p>펑터 타입을 열어 둔</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Lens</span> s a <span class="ot">=</span> <span class="kw">forall</span> f <span class="op">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> f s)</span></code></pre></div>
<p>를 만듭니다. 하지만 타입을 잘 보면 문제가 한가지 있습니다.<br />
</p>
<p><code>LensGetter</code>의 끝 부분을 보면 <code>f a</code>인데, 추상화한 타입 <code>Lens</code>의 끝 부분을 보면 <code>f s</code>입니다. 이대로는 추상화가 되지 않습니다. 이 부분을 해결하는 트릭이 번뜩입니다.<br />
아래는 아무리 요네다를 알고 있었다해도 어떻게 이런 걸 떠올렸지 싶은 트릭입니다.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> {<span class="ot"> runIdentity ::</span> a } <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Const</span>  a b <span class="ot">=</span> <span class="dt">Const</span>    {<span class="ot"> getConst    ::</span> a } <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensModify</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Identity</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> <span class="dt">Identity</span> s) </span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensGetter</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Const</span> a  a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> <span class="dt">Const</span> a  s)</span></code></pre></div>
<p>요네다 임베딩으로 보면 <code>(a -&gt; _) -&gt; (s -&gt; _)</code>에서 <code>_</code>부분에는 뭐가 들어가도, 같은 게 양쪽에 들어가면 상관없습니다. <code>Lens</code>에 <code>f</code>로 <code>Const a</code>를 넣고, 나중에 <code>runConst</code>를 거치면, 원하는대로 <code>(a -&gt; a) -&gt; (s -&gt; a)</code>가 나옵니다.</p>
<p>이제 GHC가 컨텍스트에 따라서 <code>Identity</code> 또는 <code>Const a</code>를 선택하게 하는 일만 남았습니다.<br />
</p>
<p>출력값은 아무 것이나 같기만 하면 된다는 말이 혼동되어 아무 펑터나 되는 것인가 궁금하다면 <code>Const</code>대신 <code>Maybe</code>를 한번 넣어서 확인하면 됩니다.<br />
</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LensGetter</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> s) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> s)</span></code></pre></div>
<p><code>runMaybe</code>가 없긴 하지만, 어찌해서 <code>Maybe</code>를 떼어냈다 해도 <code>(a -&gt; s) -&gt; (s -&gt; s)</code>입니다.<br />
</p>
<p><strong><em>Const a는 a를 가지고 들어가는 트릭이 있습니다.</em></strong><br />
</p>
<p>직관적으로 보면, 이렇게 간단히 해석되기도 하는데, <a href="https://www.twanvl.nl/blog/news/2011-05-19-lenses-talk">Twan van Laarhoven equivalence</a>를 따져서 Lens 분석을 하는 글이 있습니다. 혹시 이 글에서 위 트릭에 관한 이론이 있을지 찾아봐야겠습니다. <span class="citation" data-cites="todo">@todo</span><br />
<span class="citation" data-cites="todo">@todo</span> <a href="https://bartoszmilewski.com/2013/10/08/lenses-stores-and-yoneda/">Lenses, Stores, and Yoneda - 바르토즈 밀레프스키</a> 글을 해석 중입니다. - <a href="../posts/2024-01-06-LensYoneda.html">Lens와 요네다 보조 정리</a><br />
<a href="https://lens.github.io/">The Lens Library</a><br />
</p>
<hr />
<h3 id="참고">참고</h3>
<p><a href="https://en.wikipedia.org/wiki/Hom_functor">홈펑터 - 위키백과</a><br />
<a href="https://ko.wikipedia.org/wiki/%EC%9A%94%EB%84%A4%EB%8B%A4_%EB%B3%B4%EC%A1%B0%EC%A0%95%EB%A6%AC">요네다 보조정리 - 위키백과</a><br />
<a href="https://www.youtube.com/watch?v=c7nmC1pbVXw">The Yoneda Embedding Expresses Whether, What, How, Why</a> - 여기 글을 거의 다 작성했을 무렵 찾은 영상인데요, 다른 영상보다 제 입맛에 맞는 설명입니다. 정의만 읊어주는 영상들은 도통 이해하기 어렵습니다.<br />
<a href="https://www.johndcook.com/blog/2019/08/06/hom-functors/%3E">Hom functors and a glimpse of Yoneda</a> - 혼란스럽게 쓰이는 기호들을 짚어 줍니다.<br />
<a href="https://mathmemo.tistory.com/entry/Category-Yoneda-Lemma">수학기록지 - Yoneda Lemma</a> - 드물게 만나는 한글 자료입니다.</p>
<p><strong>Lens Law</strong>
<a href="https://hackage.haskell.org/package/lens-5.2.3/docs/Control-Lens-Lens.html#g:1">Control.Lens.Lens</a><br />
하스켈 문법만으론 표현할 수 없는 조건을 lens law라 해서 프로그래머한테 떠 넘깁니다. 전 <strong><em>법칙law이 보이면 문법으로 표현, 혹은 강제하지 못하는 조건이 있구나</em></strong>로 생각하고 접근합니다.</p>
<ol type="1">
<li><code>view l (set l v s) = v</code> <code>s</code>가 <code>v</code>를 가지고 있게 하고, 거기서 <code>v</code>를 꺼내면 <code>v</code>다.</li>
<li><code>set l (view l s) s = s</code> <code>s</code>에서 꺼내온 값을 다시 <code>s</code>에 넣으면, 그냥 처음과 같은 <code>s</code>다.</li>
<li><code>set l v' (set l v s) = set l v' s</code> <code>v</code>를 넣고, <code>v'</code>를 덮어 씌우면 <code>s</code>가 <code>v'</code>을 가지고 있다.</li>
</ol>
<p>당연한 말 들을 써놓은 것 같이 보입니다만, <code>view</code>와 <code>set</code>이 위 법칙을 지킨다는 건,</p>
<ol type="1">
<li><code>v</code>에서 <code>s</code>로 갔다가 다시 <code>v</code>로 돌아올 수 있으려면, <code>set l s</code> 는 모든 <code>s</code>에 대해 단사injective여야 합니다. One to One, 즉 어디서 왔는지 기억해서 돌아 갈 수 있으려면, 하나와 하나만 매핑되어야 합니다.</li>
<li><code>s</code>에서 <code>v</code>로 왔다가 다시 <code>s</code>로 돌아 가려면, <code>set l</code>은 전사surjective여야 합니다. <code>s</code>의 대상들이 빠짐없이 <code>v</code>와 매핑되어야 합니다.</li>
<li><code>v</code>와 <code>s</code>가 전단사bijective를 만족하면, <code>set l v</code>는 두 번, 세 번 반복해도 한 번 한 것과 같습니다.</li>
</ol>
<p>로 해석할 수 있습니다.</p>
<blockquote>
<p><strong><em>정보를 보존하며 변환할 때, injective인지, surjective인지는 중요한 속성을 가리킵니다.</em></strong><br />
<code>v-&gt;s</code>가 injective이면 적어도 <code>v</code>의 구조는 <code>s</code>에서 보존되었다는 말로, <code>v</code>에서 출발해서 <code>s</code>로 갔다가 <code>v</code>로 돌아 올 수 있다는 말은, <strong>s는 적어도 v이상의 정보량</strong>을 가지고 있다는 의미를 포함합니다.<br />
<code>v-&gt;s</code>가 surjective라면, <code>s</code>에 있는 모든 것은 <code>v</code>에 대응하는 대상이 있습니다. (하나가 아닐지라도요. <code>s</code>에서 <code>v</code>로는 매핑 경로가 여러 개가 나올 수 있습니다.) <strong>v는 적어도 s이상의 정보량</strong>을 가지고 있다는 말입니다.<br />
bijective하다면, <strong>같은 양의 정보</strong>를 가지고 있다는 말을 포함하고 있습니다. <code>x &gt;= y</code>, <code>y &lt;= x</code> 를 둘 다 만족하려면 <code>x = y</code> 인 경우만 있습니다.</p>
<p>Q. 그냥 <code>view</code>, <code>set</code>이 bijective한 동작을 해야 한다, 혹은 <code>v</code>,<code>s</code>는 bijective라고 쓰면 안될까?<br />
A. 같은 내용을 코드로 표현한 것입니다. 저 코드 모양이 만족하는지 검사하는 건, GHC 컴파일러가 아니고 프로그래머 몫입니다.</p>
</blockquote>
<p>Fri Dec 22 04:32:17 PM KST 2023 <span class="citation" data-cites="todo">@todo</span> 작성 중…</p>
<p><strong>카테고리 이론에서 무언가가 닮았는지 보는 방법</strong><br />
1단계 - 두 카테고리가 얼마나 닮았나 보려면, 두 카테고리 사이의 펑터를 보고<br />
2단계 - 두 펑터가 얼마나 닮았나 보려면, 두 펑터 사이의 자연 변환을 봅니다.<br />
3단계 - 그럼 자연 변환이 얼마나 닮았나 보려면?<br />
자연 변환의 각 성분들을 살펴 봅니다. 혹은 펑터 자체를 대상으로 하는 펑터 카테고리로 보면, 다시 1단계로 돌아갑니다. 그럼 자연 변환은, 대상 사이의 모피즘이 됩니다.</p>
<p><strong>↦ 세로바가 앞에 붙은 화살표</strong><br />
<a href="https://en.wikipedia.org/wiki/Maplet">Maplet</a>이라 부르고, 예상하듯 <a href="https://en.wikipedia.org/wiki/Function_(mathematics)#Arrow_notation">함수</a>를 뜻한다고 합니다. 매핑을 뜻하긴 하나, <code>x ↦ f (x)</code> 이렇게 쓰면, 람다 함수 <code>\x -&gt; f x</code>와 같은 의미입니다. 그래서 홈펑터를 다음처럼 표기하기도 합니다.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>hom(A,-): C -&gt; Set</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>hom(A,-): B ↦ hom(A,B)</span></code></pre></div>
<p>모피즘 <code>f: B-&gt;C</code> 매핑은</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>hom(A,f): hom(A,B) -&gt; hom(A,C)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>hom(A,f): g ↦ f∘g</span></code></pre></div>
<p><strong>locally small category</strong><br />
임의의 두 대상 사이의 모피즘 모음이 집합인 카테고리를 말합니다. 모음이 집합이 아닌 예로, 모든 집합 모음이 있습니다. 이 모음은 집합이 될 수 없습니다. 모든 집합의 모음이라 했으니까요. (러셀 역설) 그럼 locally small이 아닌 경우는 어떤 특징이 있는지 궁금하긴 한데, 일단 가던 길부터 잘 가고 생각해 봐야겠습니다. 텍스트들을 읽다 locally small을 만나면, 일단 “두 대상 사이에 모피즘 집합이 있군” 정도로 넘어 가려 합니다.</p>
<p><strong>자연 변환 Natrual Transformation 표기</strong><br />
카테고리 <code>C</code>, <code>D</code>, 펑터 <code>F: C -&gt; D</code>, <code>G: C-&gt; D</code> 일 때, 자연 변환 <code>η: F -&gt; G</code> …<br />
이렇게 얘기하는 걸 다음과 같이 표기합니다.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>[C,D](F,G)</span></code></pre></div>
<p>어떤 카테고리를 도메인, 코도메인으로 하고 있는지를 먼저 표시해 줍니다.</p>
<p>※ 아래는 <code>C-&gt;Set</code> 펑터를 나타냅니다. (역시나 펑터들이 대상이 되면, 모피즘과 혼동되지 않는 표기가 필요했을 거라 추측합니다.)</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>[C,Set] 또는 Set^C</span></code></pre></div>
<p>텍스트마다 다 다르긴 한데, 대체적으로<br />
영문 소문자는 대상<code>a</code>, 혹은 모피즘<code>f</code>들을 표시하고,<br />
영문 대문자는 카테고리<code>C</code>, 혹은 펑터<code>F</code>들을 표시하고,<br />
(둘 중 하나를 볼드 한다든지, 필기체를 쓴다든지, 구별되는 표시를 하는 경우도 많습니다.)<br />
그리스 알파벳 소문자는 자연 변환<code>η</code>을 표시합니다.<br />
A<code>α</code> 알파, B<code>β</code> 베타,<code>γ</code> 감마,<code>δ</code> 델타, E<code>ϵ</code> 입실론, H<code>η</code> 에타, <code>θ</code> 세타, M<code>μ</code> 뮤, N<code>ν</code> 뉴, <code>ξ</code> 크시, P<code>ρ</code> 로, S<code>σ</code> 시그마, T<code>τ</code> 타우, <code>ϕ</code> 피, <code>ψ</code> 프시, <code>ω</code> 오메가…<br />
H<code>η</code>는 homomorphism, M<code>μ</code>는 monad 처럼 연결 고리가 연상되는 것도 있지만, 딱히 그런 것 없이 쓰는 경우가 많은 것 같습니다.</p>
<p>추측 - <code>F</code>를 적용한 결과와 <code>G</code>를 적용한 결과는 둘단 <code>C</code>의 구조를 보존한 상태기 때문에 자연스럽게Natrually 변환이 존재한다인가 봅니다.</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
