<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - 수학 비전공자의 모나드 해석</title>

        <meta name="description" content="수학 비전공자가 카테고리 이론의 모나드에서 하스켈로 넘어온 핵심 아이디어가 뭔지 찾는 글입니다." />
        <meta property="og:description" content="수학 비전공자가 카테고리 이론의 모나드에서 하스켈로 넘어온 핵심 아이디어가 뭔지 찾는 글입니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="수학 비전공자의 모나드 해석" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2022-03-18-FactorizeCommuteMonad.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/monad_samejob.png" />

      <meta name="keywords" content="Monad, 모나드, 대리인">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
    </head>
    <body>
        <div id="header" style>
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../" style>lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 주의! 틀린 내용이 있을 수 있습니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않습니다.
            </div>
        </div>
        <div id="content">
            <h1>수학 비전공자의 모나드 해석</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on March 18, 2022
    
</div>

<p><em>소통을 위해 잠깐 오픈한 포스트로 정리가 끝나지 않았습니다.</em></p>
<p>카테고리 이론의 모나드를 정교하게 이해하기 위한 글이 아닙니다. 거기서 어떤 아이디어가 하스켈로 넘어왔는지 보기 위한 글입니다.<br />
직접적으로 아래와 같이 설명한 자료는 보지 못했습니다. 틀린 부분이, 아니면 전체가 틀렸을 수도 있습니다. <em>검증 필요</em> 카테고리 이론쪽에서 온 아이디어는 살리면서, 수학적 용어는 적절히 빼내어 조금 더 배경 지식이 덜 필요하도록 정리할 예정입니다.</p>
<h1 id="펑크터가-하는-일">펑크터가 하는 일</h1>
<p>카테고리 <code>C, D</code>, 펑크터 <code>F: C -&gt; D</code> 카테고리 <code>C</code>에 펑크터F를 적용하면 자신의 <em>구조를 보존하는homomorphic</em> image를 카테고리 <code>D</code>에 만듭니다. 만일 역변환inverse이 가능하다면 isomorphic한 image를 만들었다고 말할 수 있습니다. 펑크터는 자신과 비슷하지만 조금은 다른 것을 만들 수 있습니다. 어떤 대상 둘이 얼마나 비슷한가란 정보가 필요하다면 카테고리들끼리 펑크터로 관계를 만들어가며 비교하는 작업을 합니다.</p>
<p>자기 자신과 같은 카테고리 내에 비슷한(모양이 비슷할지, 다른 속성이 비슷할지..) 걸 만든다면, 펑크터 <code>G: C -&gt; C</code> 같은 펑크터로 자기 자신으로 매핑할 수도 있습니다. 이렇게 같은 카테고리내에서 매핑하는 걸 엔도펑크터endofunctor라 합니다.</p>
<blockquote>
<p>펑크터를 이용하면 나와 비슷한 다른 대상을 만들 수 있다.</p>
</blockquote>
<h1 id="멀리-돌아오든-바로-가든-출발과-목적지만-같으면-같다">멀리 돌아오든 바로 가든 출발과 목적지만 같으면 같다</h1>
<p>카테고리 <code>A,B,C,D</code>가 있을 때</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">F</span><span class="op">:</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">D</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">G</span><span class="op">:</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">C</span> <span class="ot">-&gt;</span> <span class="dt">D</span></span></code></pre></div>
<p><code>F</code>와 <code>G</code>는 “같은” 변환을 합니다.</p>
<p><span class="citation" data-cites="todo">@todo</span> Naturality Condition 추가</p>
<h1 id="a---m-b-함수와-출발-도착-타입은-같지만-대체commute길을-만들어-보자">a -&gt; m b 함수와 출발, 도착 타입은 같지만 대체commute길을 만들어 보자</h1>
<p><code>a -&gt; m b</code> 함수를 <code>id</code>펑크터로 보내고, <code>m</code>펑크터로 보내고, 둘 사이의 관계를 빨간색으로 표시한 다이아그램입니다.</p>
<p>빨간색 Natural Transformation을 잘 정의하면, 함수 <code>f</code>와 같은 <code>Id a</code> -&gt; <code>m a</code> -&gt; <code>m m b</code> -&gt; <code>Id (m b)</code> 인 다른 길이 생깁니다. (오른쪽 파란색 f와 붙어 있는 디귿 모양)</p>
<figure>
<img src="../images/monad_commute.png" alt="Commute" /><figcaption aria-hidden="true">Commute</figcaption>
</figure>
<p>아래 쪽 arrow가 위arrow와 서로 반대 방향인 걸 주의해서 보세요. <code>m m b -&gt; Id (m b)</code><br />
이렇게 정의하면 아래와 같이 대체하는 길을 만들 수 있습니다.</p>
<figure>
<img src="../images/monad_samejob.png" alt="같은 작업" /><figcaption aria-hidden="true">같은 작업</figcaption>
</figure>
<p>위 아래는 결과적으로 같은 작업이지만 가는 길이 다릅니다.</p>
<p><span class="citation" data-cites="doto">@doto</span> Naturality condition을 보이기 보다, 펑크터의 직관적인 작업 이미지를 보여 준다.</p>
<h1 id="쪼개면-이어-붙일-수-있는-부분합성이-보인다">쪼개면 이어 붙일 수 있는 부분(합성)이 보인다</h1>
<p>쪼개기 전 원래의 함수는 끝과 시작이 달라 연결 할 수 없지만, 쪼개진 작업은 품고 품게(연속 composition 또는 Chaining) 할 수 있는 부분이 보일 수 있습니다.</p>
<figure>
<img src="../images/monad_composition.png" alt="합성" /><figcaption aria-hidden="true">합성</figcaption>
</figure>
<h1 id="그래서-모나드가-하는-일은">그래서 모나드가 하는 일은?</h1>
<p>더도 말고, 덜도 말고 딱 <em>a -&gt; m b 를 연이어 연결</em>하는게 목표입니다.<br />
<span class="citation" data-cites="todo">@todo</span> a -&gt; m b 가 하스켈에서 중요한 이유 추가</p>
<h1 id="끝과-시작이-다른-타입인-함수를-어떻게-연결할까">끝과 시작이 다른 타입인 함수를 어떻게 연결할까?</h1>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> m b <span class="op">--?--&gt;</span> b <span class="ot">-&gt;</span> mc</span></code></pre></div>
<p>끝과 시작이 달라 그대로는 연결할 수 없습니다. 그래서 자신과 닮은 대리인을 세워(Functor 이용), 작업을 하고, 결과를 위한 또 다른 대리인으로부터 결과를 꺼내오게 작업을 바꾸면, 같은 작업이지만 이어 붙일 수 있는 부분을 찾을 수 있습니다. (프로그래밍 관점에서 보면 대리인과 주고 받는 <em>추가 절차</em>가 생겼으니, 체이닝을 하며 계속 반복해야 하는 컨텍스트 처리를 넣어 둘 곳이 생겼다고 볼 수 있습니다.)</p>
<p>※ 끝과 시작이 달라서 생기는 정보는 어떻게 할까요? 여기서 <code>a</code> 와 <code>m a</code>가, <code>m m a</code>와 <code>m a</code>가 isomorphic하지 않으면 안되지 않을까란 생각이 들었습니다. 하지만 <code>Id</code>와 <code>m</code>이, <code>m m</code>이 <code>m</code>과 isomorphic해야 된다는 조건은 없습니다. 펑크터 <code>m</code>으로 변환하는 동안 떼어내는 정보가 있다면, 이 정보는 <code>μ</code>가 책임져야 합니다. 그리고 최종 결과에 포함에서 돌려주는 것도 <code>μ</code>의 책임입니다. 이 일련의 과정이 마치 isomorphic하지 않은 관계를 여러 장치들로 isomorphic스럽게 처리한다처럼 보이는데, 반드시 그렇진 않기 때문에 이럴 때 정확히는 isomorphic이란 말은 틀립니다. 지금 당장은 inverse가 있는 것과 비슷하게 동작시킨다까지만 말하면 될 것 같습니다.</p>
<p>※ 하스켈에서는 보통 둘의 차이로 생겨난 정보를 체인이 끝날 때까지 람다 함수의 컨텍스트로 <em>계속 유지</em>시킵니다.</p>
<blockquote>
<p>핵심 아이디어: 작업을 쪼개면 이어 붙일 방법이 보일 수 있습니다.</p>
</blockquote>
<p>다르게 설명해 보면,</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">A</span>{a,b,c} <span class="op">---&gt;</span> <span class="dt">B</span>{<span class="dv">1</span>,<span class="dv">2</span>} 에서</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>a, b <span class="op">---&gt;</span> <span class="dv">1</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>c    <span class="op">---&gt;</span> <span class="dv">2</span></span></code></pre></div>
<p>로 연결되어 isomorphic하지 않을 때, 누군가가 <code>1</code>에 도착할 때마다 <code>a</code>에서 왔는지 <code>b</code>에서 왔는지 기록합니다. 그럼 <code>B -&gt; A</code>로 다시 돌아갈 때, 이 누군가의 도움만 받으면 마치 inverse가 존재할 때처럼 돌아갈 수 있습니다. <code>A -&gt; B</code>는 isomorphic하지 않지만, 누군가의 도움으로 isomorphic과 같은 결과, 마치 inverse가 가능한 것 같은 결과를 가져 옵니다. 얼마나 정확하게 돌아갈 것인지는 따로 제약이 있는 건 아닙니다. (반드시 isomorphic하게 돌아가야 하는 건 아니라는 말입니다.) “누군가”를 어떻게 정의하냐에 따라 다릅니다.</p>
<p>이게 모나드가 쓰는 방법이고, 이 방법을 이용해 체이닝을 합니다. 여기서 이 누군가를 Natural Transformation <code>μ</code>가 담당합니다.<br />
이 누군가의 정의에 따라 Reader 모나드, Writer 모나드, State 모나드, IO 모나드…등이 됩니다.</p>
<p>@ todo <code>μ</code>가 isomorphic하지 못해 떼어 낸 정보를 유지하는 예시. Maybe<br />
@ todo 왜 a -&gt; m b가 필요한지 추가<br />
@ todo 모나드가 각 각 다른 문제를 해결하는 이유를 컨텍스트를 이용해서 설명<br />
@ todo Adjunction으로 설명 추가</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <div id="footer">
            © 2021 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
