<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - Arrow 쓰는 방법 (스케치 중)</title>

        <meta name="description" content="Arrow가 뭔지에 대한 설명은 없습니다. 언제, 어떤 상황에서 Arrow를 떠올리면 되는지 알아내는 게 목표입니다." />
        <meta property="og:description" content="Arrow가 뭔지에 대한 설명은 없습니다. 언제, 어떤 상황에서 Arrow를 떠올리면 되는지 알아내는 게 목표입니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Arrow 쓰는 방법 (스케치 중)" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-09-22-using_arrow.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

      <meta name="keywords" content="Arrow, Monad, 합성, haskell, 하스켈, 함수형, Functional">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
<meta name="fediverse:creator" content="@lionhairdino@mastodon.social">
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px"></div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:20px;border:none" src="../images/bluesky.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://discordapp.com/users/lionhairdino#7687"><img style="width:20px;border:none" src="../images/discord.svg"></a></div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다. 처음 여기 글을 보시는 분은 <a href="warning.html">주의문</a>을 꼭 먼저 읽어 보세요.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>Arrow 쓰는 방법 (스케치 중)</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on September 22, 2023
    
</div>

<p>Sun Sep 24 03:19:40 AM KST 2023 아직 이해하지 못한 부분이 있어 계속 정리 중인 글입니다. 대부분 아직 상상입니다. 모나드보다 표현력이 좋다하지만, 모나드로 표현할 수 있는 건 굳이 Arrow로 표현하진 않는 것 같습니다. 어떤 문제, 대상을 보면 Arrow를 떠올려야 할지 찾고 있습니다.</p>
<p>Arrow가 무엇인지는 <a href="../posts/2023-09-14-arrow.html">Arrow는 모나드의 일반화</a>에 정리해 두었습니다. 여기선 언제 Arrow를 쓸 생각을 하면 되는지 찾는 게 목표입니다.</p>
<h2 id="생각-스트레칭">생각 스트레칭</h2>
<p><code>a -&gt; m b</code>를 받는 함수와 <code>m a</code>를 받는 함수 중 어느 게 더 표현력이 좋을까요? 혹은 더 추상적일까요?<br />
말을 바꾸면, 함수와 타입 중 어느 게 더 표현력이 좋을까요?
결론부터 말하면, 타입이 더 표현력이 좋습니다. 여기서 “표현력이 좋다”는, 함수가 하는 일은 타입으로도 할 수 있다는 말입니다.
타입 안에다 함수를 넣어 놓을 수도 있고,
타입을 타입 클래스의 인스턴스로 만들고, 메소드로 정의해 둔 함수가 돌게 할 수도 있습니다. 여기다, 함수와 연계되는 함수들을 지정할 수도 있고, 타입 체크를 위한 동작도 정해 줄 수 있습니다. 타입으로 만들면 많은 일이 일어납니다.</p>
<h2 id="파서를-arrow로-만들어-보자">파서를 Arrow로 만들어 보자</h2>
<p><a href="https://en.wikibooks.org/wiki/Haskell/Understanding_arrows">Haskell/Understanding arrows - wikibooks</a> # Using arrows<br />
Arrow 설명부터 활용까지 잘 나와 있는 위키북스에 있는 글인데요, 여기서는 활용 부분만 보면서, 노트한 글입니다. 아래 있는 코드들은 전부 이 페이지에서 발췌했습니다.</p>
<h2 id="느리고-특별할-것-없는-가장-기본-파서">느리고 특별할 것 없는, 가장 기본 파서</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Parser</span> s a <span class="ot">=</span> <span class="dt">Parser</span> {<span class="ot"> runParser ::</span> [s] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, [s]) }</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">--                                         입력스트림   (파싱결과, 남은 스트림)</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span> <span class="dt">Char</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>char c <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> \input <span class="ot">-&gt;</span> <span class="kw">case</span> input <span class="kw">of</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">:</span> xs <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="op">==</span> c <span class="kw">then</span> <span class="dt">Just</span> (c, xs) <span class="kw">else</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>글자 하나를 파싱하는 파서입니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runParser (char 'H') &quot;Hello&quot;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>Just ('H',&quot;ello&quot;)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runParser (char 'G') &quot;Hello&quot;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>Nothing</span></code></pre></div>
<p>위 구현만 있으면, 현재까지는 한 번 실행하는 모양만 가능한 인터페이스입니다. 이제 함수형에서 늘 그렇듯 합성이 가능하도록, 입력 스트림, 파싱 결과를 같이 받아서 잃어버리지 않고 다음으로 넘겨 주는 코드를 작성해야 합니다. 이 때 Monad나, Applicatives 인터페이스를 사용하면, 이들의 인터페이스 설계를 그대로 따르면 됩니다.
여기선 Applicatives를 보면,</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Parser</span> s) <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">Parser</span> (\s <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, s))</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Parser</span> p1) <span class="op">&lt;*&gt;</span> (<span class="dt">Parser</span> p2) <span class="ot">=</span> <span class="dt">Parser</span> (\s <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    (f, s1) <span class="ot">&lt;-</span> p1 s</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    (a,s2) <span class="ot">&lt;-</span> p2 s1</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> (f a, s2))</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="ot">isHel ::</span> <span class="dt">Parser</span> <span class="dt">Char</span> ()</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>isHel <span class="ot">=</span> char <span class="ch">'H'</span> <span class="op">*&gt;</span> char <span class="ch">'e'</span> <span class="op">*&gt;</span> char <span class="ch">'l'</span> <span class="op">*&gt;</span> <span class="fu">pure</span> ()</span></code></pre></div>
<p>한 글자가 아니라, 단어를 파싱하려면, 위와 같이 한 글자 파서를 이어 붙이는combine 작업을 하도록 아래같은 함수를 생각해 볼 수 있습니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span> <span class="dt">String</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>string <span class="ot">=</span> <span class="fu">traverse</span> char</span></code></pre></div>
<p>이제 <code>Alternative</code>의 <code>&lt;|&gt;</code>를 쓰면 다음 파서가 가능합니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solfege ::</span> <span class="dt">Parser</span> <span class="dt">Char</span> <span class="dt">String</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>solfege <span class="ot">=</span> string <span class="st">&quot;Do&quot;</span> <span class="op">&lt;|&gt;</span> string <span class="st">&quot;Re&quot;</span> <span class="op">&lt;|&gt;</span> string <span class="st">&quot;Mi&quot;</span></span></code></pre></div>
<p>잘 생각해 보면, 여기엔 퍼포먼스 문제가 있습니다. <code>"Fa"</code> 문자열을 받아 파서를 돌리면, 빠르게 <code>Nothing</code> 결과를 받으면 좋은데, <code>string "Do"</code>, <code>string "Re"</code>, <code>string "Mi"</code>를 모두 돌려 보기 전에는 결과를 받을 수 없습니다. <code>&lt;|&gt;</code>는 <code>Nothing</code>을 만난다고 바로 끝나지 않습니다. 나머지 Alternative들도 확인해야만 합니다. 만일, 하나 하나가 복잡한 파서로 입력 문자열을 많이 먹었다consume가 실패하면 다시 먹기 전으로 돌리는 작업이라면 퍼포먼스는 더 떨어질 겁니다. 다음 파서가 읽을 수도 있는 입력 문자열은 모두 메모리에 유지도 해야 합니다. 파서가 복잡해지면 유의미한 공간 누수space leak가 생길 수 있습니다.</p>
<h2 id="스마트-파서">스마트 파서</h2>
<p>Arrow의 쓰임새를 보여주려고, 파서 예를 드는데, 일단 파서의 동작을 이해해야 왜 Arrow가 적합한지 알 수 있을 것 같아 좀 자세히 뜯어 보았습니다. Swierstra와 Duponcheel은 다음 방법을 제안 했습니다. <code>"Do"</code>, <code>"Re"</code>, <code>"Mi"</code>를 파싱을 위해, 각각 첫 글자 <code>D</code>, <code>R</code>, <code>M</code> 파서를 먼저 돌립니다. 텍스트에선 첫 글자 파서를 추가한 파서를 스마트 파서라 부르고 있습니다.</p>
<p>스마트 파서는 <code>D</code>를 파싱했으면, 이어서 <code>o</code>를 파싱 시도할 거란 걸 알고 있고, <code>R</code>을 파싱했으면, 이어서 <code>e</code>를 파싱할 거란 걸 알고 있습니다. (텍스트에서 could look ahead가 이 뜻이 아닐까요?) 가베지 콜렉팅도 바로 할 수 있습니다. 예를 들어, <code>D</code> 파싱에 성공했다면, 더 이상 다른 파서가 <code>D</code>를 돌아볼 필요가 없기 때문에 바로 메모리에서 날려도 됩니다. 스마트 파서가 아니었다면, 다른 파서가 모두 돌 때까지 <code>D</code>를 날릴 수 없습니다.</p>
<ul>
<li>첫 글자 <code>D</code>, <code>R</code>, <code>M</code> 중 하나가 있는지 먼저 파싱하고</li>
<li>이들 중 하나가 있다면, 해당 글자에 따라 다음 파서를 고른다.</li>
</ul>
<p>제안한 방법은, 각 파서들이 <code>첫글자파서 + 나머지파서</code>를 가지고 있게 만듭니다. 텍스트에서는 나오지 않지만, 헛갈리지 않게 둘을 합친 파서를 <code>전체파서</code>라고 부르겠습니다. <code>전체파서</code> 둘을 받아 묶어 놓으려면, <code>첫글자파서</code>끼리 묶고, <code>나머지파서</code>끼리 묶어 놓아야 합니다. 그래야 <code>첫글자파서</code>만 먼저 돌리는게 가능할테니까요.</p>
<p><code>전체파서 = 첫글자파서 + 나머지파서</code></p>
<p>이렇게 생긴 것 세 개를 합성한다면</p>
<p><code>(첫글자파서1 | 첫글자파서2 | 첫글자파서3)</code> 를 먼저 돌리고,<br />
다음 돌리는 <code>나머지파서</code>는, 모두 돌릴 필요없이 <em>이전 결과에 따라 돌릴 파서를 선택</em>해야 합니다. 최종 합성한 <code>전체파서</code> 모양을 추측해보면,</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>전체파서 =</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  첫글자파서1 | 첫글자파서2 | 첫글자파서3      &lt;--- 정적?</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  위 작업이 실패면 Nothing, 아니면             &lt;--- 동적?</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    첫글자파서1이 성공이면 </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>      나머자파서1이 실패면 Nothing 아니면 결과</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    첫글자파서2가 성공이면 </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>      나머자파서2이 실패면 Nothing 아니면 결과</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    첫글자파서3이 성공이면 </span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>      나머자파서3이 실패면 Nothing 아니면 결과</span></code></pre></div>
<p>텍스트에선 이런 이유로 <code>첫글자파서</code>를 <code>정적 파서</code>, <code>나머지파서</code>를 <code>동적 파서</code>라고 이름 붙인 것 같습니다.</p>
<blockquote>
<p>Q. 스마트 파서는 모나드로 구현한 것과 비슷해 보이지만, export static information을 한다는 큰 차이가 있다고 합니다. 정적인 정보가 뭘까요? 그럼 모나드는 동적이란 얘기일텐데요.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>모나드 (혹은 체인)<span class="ot"> ::</span> a <span class="ot">-&gt;</span> m b</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">solfege            ::</span> <span class="dt">Parser</span> <span class="dt">Char</span> <span class="dt">String</span></span></code></pre></div>
<p><code>m</code>을 얻으려면 <strong><em>동적</em></strong>으로 <code>a</code>를 넣어 봐야 알게 되겠지만,<br />
<code>solfege</code>는 <code>Parser</code>타입이 가진 정보를 (<code>a</code>를 넣어 실행하는 것 같은 동적 작업 없이) 바로 볼 수 있습니다. 타입과 함수의 차이라고 봐도 되겠습니다. static information이란 이 걸 말하는 걸까요?</p>
<p>정적인 정보를 가지고 있게 하려면, 모나드로는 안되고 Arrow 인터페이스가 필요하다고 합니다.</p>
<p><span class="citation" data-cites="todo">@todo</span> <span class="citation" data-cites="재경님">@재경님</span> 설명 정리</p>
</blockquote>
<p>텍스트에선 파서(<code>전체파서</code>)를 정적 파서(<code>첫글자파서</code>), 동적 파서(<code>나머지파서</code>)로 부릅니다. 정적 파서는 빠르게 현재 입력값이 파싱 시도할만 한가만 알려주고, 동적 파서가 상대적으로 느리게 실제 파싱 작업을 합니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Category</span> <span class="kw">as</span> <span class="dt">Cat</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (union)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Parser</span> s a b <span class="ot">=</span> <span class="dt">P</span> (<span class="dt">StaticParser</span> s) (<span class="dt">DynamicParser</span> s a b)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StaticParser</span> s <span class="ot">=</span> <span class="dt">SP</span> <span class="dt">Bool</span> [s] <span class="co">-- SP 빈문자열여부 [첫글자]</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">DynamicParser</span> s a b <span class="ot">=</span> <span class="dt">DP</span> ((a, [s]) <span class="ot">-&gt;</span> (b, [s]))</span></code></pre></div>
<p><code>SP</code>는 왜 빈문자열 여부를 가리는 인자가 왜 필요한지, <code>DP</code>의 <code>a</code>, <code>b</code> 인자는 뭘 의미하는지 눈에 안들어와 더 뜯어 봤습니다.</p>
<h3 id="정적-파서">정적 파서</h3>
<p>정적 파서는 빈 문자열을 입력으로 받을 수 있는지 알려 주는 플래그와, 시작 글자 목록 조합으로 구성됩니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- sp는 static parser, A는 한 글자를 뜻하는 것 같다. </span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">spCharA ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">StaticParser</span> <span class="dt">Char</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>spCharA c <span class="ot">=</span> <span class="dt">SP</span> <span class="dt">False</span> [c]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">--             ^^^^^ ^^^</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span>   첫 글자 목록</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>               빈 문자열 못받음</span></code></pre></div>
<p>위 정적 파서 <code>spCharA</code>는 첫 글자 <code>c</code>를 위한 파서이며, 빈 문자열은 받지 못합니다.</p>
<blockquote>
<p>Q. 빈 문자열을 받을 수 있는지 여부를 왜 갖고 있어야 할까요?<br />
빈 문자열은 보통 에지 케이스로 쓰이는 경우가 많습니다. 문자열을 받아 조금씩 먹으며 재귀를 돌다가 빈 문자열이 되면 멈춘다든지 할 때 쓰입니다. 뒤에 나오는 <code>runParser</code>의 동작을 보면, 빈 문자열 플래그가 <code>True</code>이고, 빈 문자열 <code>[]</code>이 들어오면, 바로 동적 파서에 <code>(초기값, [])</code>을 넘겨 실행시킵니다.</p>
<p>추측1) 동적 파서가 빈 문자열이 들어와서 오류가 났다는 결과를 내뱉을 수 있다면, 빈 문자열이 의미 있을 수도 있겠습니다.</p>
<p>추측2) 만일 동적 파서가 빈 문자열 처리를 할 수 없다면, 이 옵션을 <code>False</code>로 만들어 정적 파서에서 걸러낼 수 있습니다. 아래에 나오는 <code>dpCharA</code> 같은 동적 파서는 <code>_:xs</code>로 패턴 매칭하므로, 빈 입력 문자열은 동적 파서까지는 오지 말아야 합니다.
아래 Arrow 인스턴스를 만들 대 <code>arr</code>이 옵션을 <code>True</code>로 쓰고 있습니다.<br />
<code>arr f = P (SP True []) (DP (\(b,s) -&gt; (f b, s)))</code><br />
여기 있는 정적 파서는, 정적 파서들 합성에서 id 같이 어떤 영향도 주지 않아야 하고 (하나라도 <code>False</code>면 전부 <code>False</code>가 되니, 영향을 미치지 않기 위해 <code>True</code>값을 가지고, 당연히 첫 글자 목록도 비어있어야 합니다.)<br />
동적 파서도, 동적 파서들 합성에서 id 같은 역할을 해야 합니다.<br />
<em>아직 확실한 이유는 모릅니다. 아시는 분은 댓글 부탁 드립니다.</em></p>
</blockquote>
<h3 id="동적-파서">동적 파서</h3>
<p>동적 파서는 <code>(a, [s]) -&gt; (b, [s])</code> 모양의 함수입니다. 금방 눈에 들어오진 않지만, 두 개의 파서를 순서대로 늘어 놓은 걸로 읽어도 된다고 합니다. <code>(이전 파서의 결과, 입력 문자열)</code>을 넣어 주면 <code>(b, [s])</code> 2튜플을 반환하는 함수입니다. 예를 들어, 현재까지 파싱된 글자수 <code>Int</code>를 결과로 가지는 <code>(Int, String) -&gt; (Int, String)</code> 같은 걸 생각해 볼 수 있습니다. <code>cake</code>란 문자열을 파싱하는 걸 보면,</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>첫 번째 (<span class="dt">Int</span>, <span class="dt">String</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">String</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span>    cake        <span class="dv">1</span>    ake</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                 두 번째 (<span class="dt">Int</span>, <span class="dt">String</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">String</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                           <span class="dv">1</span>    ake         <span class="dv">2</span>     ke</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>                                  세 번째 (<span class="dt">Int</span>, <span class="dt">String</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">String</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>                                            <span class="dv">2</span>     ke         <span class="dv">3</span>     e</span></code></pre></div>
<p>동적 파서는 이전 파서의 결과를 받아 뭔 짓(여기서는 <code>+1</code>)을 하고, 입력 문자열 하나를 먹는 두 가지 작업을 합니다. 작업을 타입으로 표현하면 <code>(a -&gt; b)</code> 작업과 <code>([s] -&gt; [s])</code> 작업, 두 개의 작업을 합니다. 두 개를 병행하는 걸 하나의 함수로 표현하려면 2튜플로 표현할 수 있습니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">DP</span> ((a, [s]) <span class="ot">-&gt;</span> (b, [s]))</span></code></pre></div>
<p>여러 글자가 아닌, 딱 한 글자를 파싱을 위한 동적 파서를 생각해 봅시다.</p>
<p>첫 번째 해야 할 작업은, 이전 파서의 결과를 무시하고, 입력 문자열에서 첫 글자를 먹은 걸로 만들고, 첫 글자를 반환해야 합니다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dpCharA ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">DynamicParser</span> <span class="dt">Char</span> a <span class="dt">Char</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>dpCharA c <span class="ot">=</span> <span class="dt">DP</span> ( \(_, _<span class="op">:</span>xs) <span class="ot">-&gt;</span> (c,xs) )</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span>   <span class="op">|</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span>   <span class="op">+</span>남은 문자열의 첫 글자 떼어내서 버리기</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>                   <span class="op">+</span> 이전 결과 무시  </span></code></pre></div>
<p>처음 텍스트를 봤을 때, 이 게 무슨 말인가 했습니다. 왜 이전 작업 결과는 무시하고, <code>x == c</code> 같은 작업은 왜 안 보일까요? 지금은 <code>Do</code>같이 여러 글자를 파싱하는 게 아니라, 오직 한 글자를 위한 파서에서 쓸 동적 파서입니다. 한 글자를 파싱하는 정적+동적 <code>전체파서</code>를 다음과 같이 정의할 수 있습니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">charA ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span> a <span class="dt">Char</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>charA c <span class="ot">=</span> <span class="dt">P</span> (spCharA c) (dpCharA c)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>            <span class="op">^^^^^^^^^^^</span> <span class="op">^^^^^^^^^^^</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span>        <span class="op">|</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span>        <span class="op">+</span> 실제 파싱 역할</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>                  <span class="op">+</span>한 글자를 보고 계속 파싱할지 말지를 결정하는 역할</span></code></pre></div>
<p>한 글자기 때문에 정적 파서가 이미 필요한 글자 매칭 여부는 들여다 봤습니다. 이게 성공해서 동적 파서로 넘어가면, 항상 그렇다는 게 아니라, 딱 이 경우에는 동적 파서가 하는 일이 없습니다. 그냥 정적 파서가 매칭 성공한 한 글자와, 앞 글자 하나를 떼어내고 나머지 문자열을 반환하면 됩니다.</p>
<p>파서를 실행하려면 정적 파서를 먼저 돌리고, 통과하면, 입력 문자열에 동적 파서를 적용하는 작업이 필요합니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runParser ::</span> <span class="dt">Eq</span> s <span class="ot">=&gt;</span> <span class="dt">Parser</span> s a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [s] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (b, [s])</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 먹을 게 없는 빈 문자열이 들어 왔을 때</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>runParser (<span class="dt">P</span> (<span class="dt">SP</span> emp _) (<span class="dt">DP</span> p))  a  [] </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> emp <span class="ot">=</span> <span class="dt">Just</span> (p (a, [])) <span class="co">-- emp는 불린값, 빈 문자열을 허용한다면, </span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>                           <span class="co">-- (a, [])로 동적 파서를 부른다. </span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- 먹을 문자열이 있을 때</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>runParser (<span class="dt">P</span> (<span class="dt">SP</span> _ start) (<span class="dt">DP</span> p))  a  input<span class="op">@</span>(x<span class="op">:</span>_) </span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> x <span class="ot">`elem`</span> start <span class="ot">=</span> <span class="dt">Just</span> (p (a, input)) <span class="co">-- 첫 글자들 중 하나라면, 동적 파서를 돌린다.</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>                                         <span class="co">-- 여기가 x == c 작업을 하는 곳</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runParser (charA 'D') () &quot;Do&quot;</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>Just ('D',&quot;o&quot;)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runParser (charA 'D') () &quot;Re&quot;</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>Nothing</span></code></pre></div>
<p>지금까지는 <code>전체파서</code>가 “한 글자”를 파싱하는 작업이었습니다. <code>runParser</code><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> 서명을 보면, <code>전체파서</code>와 초기값 <code>a</code>를 받아 <code>[s] -&gt; Maybe (b, [s])</code> 함수를 반환합니다. 모나드 액션과 같은 타입입니다.</p>
<p><code>Arrow</code>로 넘어가기 숨 차네요. 왜 필요한지 보이기 위한 “상황” 자체를 이해하는 것도 쉽지 않습니다.</p>
<h3 id="arrow-컴비네이터-활용">Arrow 컴비네이터 활용</h3>
<p><code>전체파서</code>에서 <code>동적파서</code>는 2튜플을 넣어 주며 “<em>실행compute</em>”하게 되지만, <code>정적파서</code>는 별다른 “실행” 없이도 어떻게 생겼는지 볼 수 있습니다. <code>전체파서</code> 3개를 합성했다면, <code>P (SP (True &amp;&amp; False &amp;&amp; True) ['a','b','c']) (...동적 파서 합성...)</code> 모양이 되고, 언제든 패턴 매칭만으로 <code>SP</code>를 꺼낼 수 있습니다. 외부 입력 값에 따라 <code>SP</code> 값은 변하지 않지만, <code>DP</code>는 값이 변합니다. 타입과 타입을 연결하는 게 아니라, 함수와 함수를 연결한다면, “정적”인 정보를 둘 데가 없습니다. 함수가 외부 통로를 열어 놨으니 더 융통성이 있을 것처럼 보이지만, 타입이 더 표현력이 좋습니다. 체인에서 정적인 정보가 병행하는 게 보이면 <code>Arrow</code>를 떠올려야 할 때입니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> s <span class="ot">=&gt;</span> <span class="dt">Arrow</span> (<span class="dt">Parser</span> s) <span class="kw">where</span></span></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  arr f <span class="ot">=</span> <span class="dt">P</span> (<span class="dt">SP</span> <span class="dt">True</span> []) (<span class="dt">DP</span> (\(b,s) <span class="ot">-&gt;</span> (f b, s)))</span></code></pre></div>
<p><code>arr</code>은 보통의 함수를 Arrow로 바꿔 줍니다. <code>arr</code> 적용해 얻은 Arrow는 파싱할 첫 글자가 없고, 동적 파서에서도 문자열을 먹거나 하지 않습니다. 나중에 <code>runParser</code>를 돌릴 때, 동작할 수 있도록 동적 파서에 <code>f</code>를 끼워 놓기만 합니다. 별다른 작업은 안하고 Arrow 흐름 안에 <code>f</code>를 적용하는 인터페이스 입니다.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>  first (<span class="dt">P</span> sp (<span class="dt">DP</span> p)) <span class="ot">=</span> (<span class="dt">P</span> sp (<span class="dt">DP</span> (\((b,d),s) <span class="ot">-&gt;</span> </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (c, s') <span class="ot">=</span> p (b, s) <span class="co">-- (b,d)에서 앞에 b에만 동적 파서p 적용</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span>  ((c, d), s')))) <span class="co">-- b는 c로 바뀌었지만, d는 손대지 않고 그대로 내보낸다.</span></span></code></pre></div>
<p><code>Category</code> 인스턴스도 만들어야 합니다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> s <span class="ot">=&gt;</span> <span class="dt">Cat.Category</span> (<span class="dt">Parser</span> s) <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="ot">=</span> <span class="dt">P</span> (<span class="dt">SP</span> <span class="dt">True</span> []) (<span class="dt">DP</span> (\(b,s) <span class="ot">-&gt;</span> (b, s)))</span></code></pre></div>
<p>이제 복잡한 <code>(.)</code>만 남았습니다. <code>정적+동적 파서</code> 두 개를 받아 합쳐서 잘 돌아가게 준비를 해야 합니다.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>(<span class="dt">P</span> (<span class="dt">SP</span> empty1 start1) (<span class="dt">DP</span> p1)) <span class="op">.</span> (<span class="dt">P</span> (<span class="dt">SP</span> empty2 start2) (<span class="dt">DP</span> p2)) <span class="ot">=</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>   <span class="op">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    p (<span class="dt">SP</span> (empty1 <span class="op">&amp;&amp;</span> empty2) </span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>          (<span class="kw">if</span> <span class="fu">not</span> empty1 <span class="kw">then</span> start1 <span class="kw">else</span> start1 <span class="ot">`union`</span> start2))</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">DP</span> (p2<span class="op">.</span>p1)) </span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- DP 안에 들어있는 (a,[s]) -&gt; (b,[s]) 타입의 함수는 cake 예시처럼 그냥 합성합니다.</span></span></code></pre></div>
<p><code>정적파서</code> 합성 부분이 좀 어렵습니다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>  empty1 <span class="op">&amp;&amp;</span> empty2 <span class="co">-- 하나라도 빈 문자열을 못 받으면, 빈 문자열 못 받는 걸로 </span></span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">if</span> <span class="fu">not</span> empty1 <span class="kw">then</span> start1 <span class="kw">else</span> start1 <span class="ot">`union`</span> start2))</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 첫 번째 정적 파서가 빈 문자열을 못 받는다면, 첫 번째 정적 파서의 시작 글자 목록을</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 그렇지 않으면 정적 파서 두 개가 갖고 있는 시작 글자 목록 모두 합치기</span></span></code></pre></div>
<p>텍스트 진행이 어디로 가는 건지 잘 모르겠습니다. <code>charA</code>는 아래 같이 조합해서 쓸 수 없습니다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runParser (charA 'D' &gt;&gt;&gt; charA 'o') () &quot;Do&quot;</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>Nothing</span></code></pre></div>
<p><code>charA</code>가 가진 동적 파서가 하는 일을 봐서는, 이렇게 합성하면 안될 게 뻔히 보입니다. 앞의 한 글자 파싱 예시가 어떻게 다음으로 연결되는지 아직 모르겠습니다.</p>
<p>Sun Sep 24 03:07:26 AM KST 2023 작성 중…</p>
<h2 id="모나딕으로-조합한-파서와-차이">모나딕으로 조합한 파서와 차이</h2>
<p>첫 글자 파서를 두는 건 모나드로 표현 못한다고 하는데, 왜 그럴까요? “<code>Do</code>”를 파싱 중이면,</p>
<blockquote>
<p>Q. 왜 첫 글자 파서를 운용할 때는 static infomation이 필요할까?<br />
추측 A. 뒷 파서를 compute하지 않아도, 첫 글자 파서가 뭔지는 알 수 있기 때문입니다.</p>
</blockquote>
<p>Arrow 인터페이스는 두 개의 파서(정적, 동적)를 transparently compose and manipulate할 수 있게 해줍니다.
Sun Sep 24 11:54:42 AM KST 2023 작성 중 …</p>
<h2 id="arrow도-수학에서-온-걸까">Arrow도 수학에서 온 걸까?</h2>
<p>Freyd-categories</p>
<p>※ 프로그래밍과 수학은 표현 방식이 조금 다를 뿐, 한 쪽에서 구조를 위한 패턴, 개념이 보이면 다른 쪽에도 존재하는 것 같다.</p>
<h2 id="정리">정리</h2>
<p>그냥 <code>a -&gt; b</code>, <code>b -&gt; c</code> 함수를 정의하고, <code>(.)</code>를 이용해서 <code>a --...--&gt; c</code>를 만든 것과, Arrow 인터페이스를 이용하는 것의 차이는 뭘까요?</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>              (-&gt;) a    b    .                 (-&gt;) b    c</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>              (-&gt;) a (m b)  &gt;=&gt;                (-&gt;) b (m c)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>ArrowInstance (-&gt;) a    b   &gt;&gt;&gt;  ArrowInstnace (-&gt;) b    c</span></code></pre></div>
<p>함수를 합성할 때마다, 반복되는 어떤 작업 (Effect를 잃어버리지 않기 위한 작업)이 있다면, 모나드 인터페이스가 딱이었습니다.
<code>a -&gt; b</code>의 합성과 <code>m (m a) -&gt; m a</code> 작업을 “병행”해 주는 작업이 필요하면 모나드를 떠올리면 됐습니다.<br />
추측) <code>a -&gt; b</code>든 <code>a -&gt; m b</code>든, 합성과 정적인 정보 유통<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>을 체인에서 병행해야 한다면 Arrow를 떠올리면 됩니다.</p>
<p>Sun Sep 24 03:20:50 AM KST 2023 작성 중…</p>
<p><span class="citation" data-cites="todo">@todo</span> 아래는 아직 생각 정리가 안된 끄적임입니다.</p>
<p>타입과 함수의 차이, <strong>생성generate 방법</strong>이 정해져 있는 타입과, 외부 정보에 의존하는 함수의 차이</p>
<pre><code>m1 a -&gt; (a -&gt; m2 b) -&gt; m3 b</code></pre>
<p>이미 <strong>생성 방법</strong>이 정해진 <code>m1</code>과 <code>a</code><br />
외부 정보 <code>a</code>에 의존해서 생성 방법을 결정될 <code>m2</code>, 그리고 <code>a</code>에 의존해서 결정될 <code>b</code></p>
<p>바인드 자체는 <code>m1</code>이 어떤 생성 방법을 쓸 것이라 결정된 상태로 <strong>예정</strong>하고 동작한다는 뜻이 아니라, 바인드로 들어 올 때부터 이미 정해진 상태로 들어온다는 뜻이다.</p>
<p>외부 정보를 받을 수 있는 인터페이스가 있는 것보다, 왜 타입이 표현력이 더 좋다고 할까?<br />
타입은 당장 동작해야 할 코드가 아니라, 나중에 어떤 동작을 하겠다는 표기이다. 함수는 표기와 동시에 동작하는 것이고, 타입은 표기해 두고, 동작은 나중으로 미룰 수도 있게 해주니 더 표현력이 좋다.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>이런 패턴이 선언형 프로그래밍의 좋은 예시 아닐까요? 딱, 양분할 순 없지만, 컴비네이터로 조합 할 때는, 할 일을 조합해서 목록(설계도)만 만들고, 실제 작업은 바로이런 <code>run~</code>이 붙은 것들이 “컴비네이터로 조합해서 만들어 둔 설계도”를 보고 합니다. 꼭 DSL처럼 완전 선언과 구현이 나뉘는 느낌은 아니더라도, 좀 감이 오는데 도움이 되는 것 같아 언급해 봤습니다.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>아직 유통distribution이란 말을 다른데서 본적이 없지만, 함수 합성으로 필요한 정보를 끌고 다니는 게 마치 “정보 유통” 체계를 잡는 느낌이 들어 써봤습니다.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
