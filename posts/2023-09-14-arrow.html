<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">

<head>
  <script>
    (function () {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark') {
        document.documentElement.classList.add('dark-mode');
      }
    })();

    function loadUtterances() {
      const savedTheme = localStorage.getItem('theme');
      const themeValue = savedTheme === 'dark' ? 'github-dark' : 'github-light';

      console.log("theme");
      console.log(themeValue);
      const script = document.createElement('script');
      script.src = 'https://utteranc.es/client.js';
      script.setAttribute('repo', 'lionhairdino/lionhairdino.github.io');
      script.setAttribute('issue-term', 'url');
      script.setAttribute('theme', themeValue);
      script.setAttribute('crossorigin', 'anonymous');
      script.async = true;
      document.body.appendChild(script);
    };

    function updateUtterancesTheme() {
      const savedTheme = localStorage.getItem('theme');
      const themeValue = savedTheme === 'dark' ? 'github-dark' : 'github-light';

      // Utterances iframe에 메시지 전송
      const utterances = document.querySelector('.utterances iframe');
      if (utterances) {
        utterances.contentWindow.postMessage(
          {type: 'set-theme', theme: themeValue},
          'https://utteranc.es'
        );
      }
    }

  </script>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>lionhairdino - Arrow로 함수 컴비네이션 (작성 중)</title>
  
  <meta name="description" content="주로 John hughes 텍스트를 보며 Arrow를 공부하면서 노트한 글입니다." />
  <meta property="og:description" content="주로 John hughes 텍스트를 보며 Arrow를 공부하면서 노트한 글입니다." />
  
  <link rel="stylesheet" type="text/css" href="../css/default.css" />
  <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
  <link rel="shortcut icon" href="../favicon.ico" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
  <link rel="manifest" href="../site.webmanifest" />
  <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
  <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
  <meta name="msapplication-TileColor" content="#ff7500" />
  <meta name="theme-color" content="#ffffff" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Arrow로 함수 컴비네이션 (작성 중)" />
  <meta property="og:site_name" content="Lionhairdino" />
  <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-09-14-arrow.html" />
  
  <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />
  
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-E9WZ6VXGHP');
  </script>
  <script src="../script/copycode.js"></script>

  <script src="../script/darkmode.js"></script>
  <script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
  <meta name="fediverse:creator" content="@lionhairdino@mastodon.social" />
  <link rel="alternate" type="application/rss+xml" title="상상 하스켈 - Lionhairdino" href="rss.xml" />
</head>

<body>
  <div id="header">
    <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
      <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
    </div>
    <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
      <a href="../">lionhairdino</a>
      <a href="../about.html">about</a>
      <!--<a href="/archive.html">archive</a>-->
    </div>
    <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
      <div style="display:inline-block;vertical-align: top;padding-top: 5px"></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:18px;border:none" src="../images/bluesky.svg"></a>
      </div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://discordapp.com/users/lionhairdino#7687"><img style="width:20px;border:none" src="../images/discord.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://x.com/lionhairdino"><img style="width:15px;border:none" src="../images/X.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://linkedin.com/in/lionhairdino-l-baaa54244"><img style="width:20px;border:none" src="../images/linkedin.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://github.com/lionhairdino"><img style="width:20px;border:none" src="../images/github.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://www.threads.net/@linohairdino"><img style="width:20px;border:none" src="../images/threads.svg"></a></div>
    </div>
    <div>
      <div style="display:inline-block;width:180px;">
        <div class="gcse-searchbox-only"></div>
        <div><button id="theme-toggle">
            <script>
              const savedTheme = localStorage.getItem('theme');
              if (savedTheme === 'dark')
                document.write("☉");
              else
                document.write("☾");
            </script>
          </button></div>
      </div>
    </div>
    <div>
      여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다. 여기 글을 처음 읽는 분은, 먼저 <a href="../warning.html">주의문</a>을 꼭 읽어보세요.
    </div>
  </div>
  <div class="js-toc-content">
    <h1>Arrow로 함수 컴비네이션 (작성 중)</h1>
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on September 14, 2023
    
</div>

<p>함수형은 여러 개의 함수들을 합성compose해서 프로그램을 만들어 갑니다. <code>Arrow</code>는 타입에 상관없이(<code>a -&gt; b</code>형태는, <code>a -&gt; m b</code> 형태든…), 합성하는 인터페이스를 통일하자는 것이니, 함수형의 근간을 이루는 구조, 패턴이 아닌가 싶은데, 실상은 모나드만큼 인기리에 쓰이고 있는 것처럼 보이진 않습니다. (제 기준으론 외모도 모나드의 <code>do</code>만큼 깔끔하게 똑 떨어지진 않습니다.) 이론들이 단 몇 년만에 도입되어 폭발적으로 쓰이거나 그러진 않으니, 아직도 서서히 성장 중인 걸지도 모르겠습니다. FRP 라이브러리나(Yampa), GUI 라이브러리(Fruit)등, 도입한 라이브러리가 꽤 있고, 다른 언어에서도 FRP 구현에선 중요한 역할을 하고 있는 이론인가 봅니다. 모나드를 대체하거나 하는 구조가 아니라, 특정 조건하에서는, 모나드보다 더 적합한 경우가 있다고 합니다.</p>
<p>공부하면서 계속 원문과 노트를 같이 넣다보니 글이 많이 길어졌습니다. 아마도 보실 분들은 거의 없을텐데요. <code>Arrow</code>를 공부하다 막히는 부분이 있을 때, 다른 관점은 없나 궁금할 때 Ctrl-F로 찾아보면 좋을 듯 합니다.</p>
<p>전체적인 글은 다음 순서로 흘러 갑니다.</p>
<ul>
<li>모나드를 일반화하자.</li>
<li><code>(&gt;&gt;&gt;)</code>, <code>arr</code> 로 모나딕 작업과 아닌 작업을 인터페이스를 같게 만든다.</li>
<li>위 두 개만으론, 바인드처럼 작업하는데 부족함이 있다.</li>
<li><code>first</code> 를 추가한다. 2-튜플의 앞에 것에만 작업을 한다는 것만으로 어찌 중간 단계의 값에 접근 할 수 있을까?</li>
<li>모나드가 할 수 있는 일은 다 할 수있고, 모나드가 못하는 일도 할 수 있다.<br />
(꼭 그렇지는 않다고 합니다. List 모나드나 Cont 모나드 같은 건 Arrow로 표현하기 어렵다고 합니다.)</li>
</ul>
<p><a href="https://www.cse.chalmers.se/~rjmh/afp-arrows.pdf">Programming with Arrows - John hughes</a><br />
위 텍스트를 읽으면서 가졌던 의문들과 알게된 답을 같이 적었습니다.</p>
<ul>
<li>모나드의 일반화? Arrow에 <code>join</code>이 있나?<br />
없습니다.</li>
<li><code>Arrow &gt;&gt;&gt; Arrow &gt;&gt;&gt; Arrow</code> 이런 식이면, 모나드처럼 동적인 Arrow는?<br />
Arrow를 위한 모나드 인스턴스를 만들 수 있습니다.</li>
<li>Arrow는 클로저를 안 쓰는데, 체인에서 각 단계의 결과를 개 별 접근하려면?<br />
튜플을 이용해서 중간 단계의 값을 저장할 수 있습니다.</li>
</ul>
<h2 id="생각-스트레칭">생각 스트레칭</h2>
<h3 id="타입이-할-수-있는-일검증-안된-혼자-상상입니다.">타입이 할 수 있는 일(검증 안된 혼자 상상입니다.)</h3>
<p>수학이 강한 분들은, 아래 같은 얘기를 별로 안 좋아하는 경우가 있습니다. 너무 “인문학”스럽게 접근하는 걸로 보이나 봅니다. 전, 논리적으로 딱 맞아 떨어져도, 아래 같은 이해를 하지 못하면 현실을 모델링할 때 써먹질 못합니다. 여하튼, 그다지 환영 받는 얘기는 아니니, 적당히 한 귀로 흘리시면서 보세요.</p>
<p><code>Int</code>, <code>Char</code>같은 프리미티브 타입이 아니라, 프로그래머가 만들어내는 타입들에 관한 얘기입니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Some</span> a <span class="ot">=</span> <span class="dt">Some</span> a</span></code></pre></div>
<p><code>Some</code> 타입같은 것을 볼 때, <code>Some a</code>가 아니라 <code>Some _</code>으로 보는게 편합니다. <code>Some</code>을 벗겨 보기 전엔 안에 뭐가 들어 있을지 알 수 없습니다. 또는 다른 시각에서 보면, <code>a</code>에 접근하려면 반드시 특정 절차가 필요할 경우 <code>Some a</code>로 만들면 됩니다. 죽었다 깨나도 <code>Some</code>을 열어 보기 전에는 <code>a</code>에 도달할 수 없습니다. 제가 눈여겨 보는 속성은, 값에 도달하려면 반드시 거쳐야 하는 <strong><em>한 단계 절차</em></strong> 를 가지고 있다는 것입니다. 타입 생성자로 쌓여 있는 것은, 말 그대로 언젠가 <strong><em>생성construct</em></strong>한다는 동작이 들어가 있습니다.</p>
<p>이런 저런 함수들을 붙여가며 작업을 하게 되는데, 따로 함수를 두지 않고, 타입으로 만들고, 함수로 할 일을 생성자나 메소드로 작성 해 놓으면, 해당 타입에서 값을 뽑아낼 때 마치 반드시 일어날 수 밖에 없는 디폴트 작업을 추가해 놓는 것과 비슷합니다. 또 다른 효과로, 타입으로 가려 두면(감싸 놓으면), 실행을 미루는 효과도 납니다. 나중에 타입을 벗겨내면서 예정했던 동작은 반드시 일어나니, 그 전에 신경쓰면서 잊지 않고 필요한 동작을 빠뜨리지 않았는지 신경 쓸 필요도 없습니다.</p>
<p>코드 조립할 때 단순히 조각들이 만나는 부분들이, 아귀(타입 매칭)가 잘 맞는지 보는 간단한 용도를 넘어, 타입은 볼 수록 여러 능력들을 가지고 있습니다.</p>
<h3 id="타입이-표현력이-좋을까-함수가-표현력이-좋을까">타입이 표현력이 좋을까? 함수가 표현력이 좋을까?</h3>
<p>A가 하는 일을 포함해서 B가 더 많은 일을 할 수 있다면, A보다 B가 표현력이 좋다는 뜻에서 표현력이 좋다라는 문장을 썼습니다.</p>
<p><code>a -&gt; b</code> 와 <code>data SomeType a b = SomeType (a -&gt; b)</code>를 비교하면,<br />
<code>applySome (SomeType f) a = f a</code>라는 함수나 메소드를 준비해 놓으면, <code>a -&gt; b</code>가 할 수 있는 일은 모두 할 수 있으며, 추가로 연계된 메소드를 둘 수도 있고,<br />
<code>specialApplySome (SomeType f) a = 추가 작업 후 f a</code> 등으로 함수를 적용할 때 항상 해야만 하는 일을 심어 둘 수도 있습니다. 이런 의미에서 전 타입이 더 표현력이 좋다 생각합니다.</p>
<p>타입이 함수의 일반화가 아닌가 생각한 적이 있는데요, 텍스트도 그리 말하는 곳이 없고, 가끔 저와 대화를 하는 분들 모두 “일반화”라고까지 말할 순 없다라고들 합니다. 저는 <code>Int</code> 타입이라고 하면 <code>Class DoNothing</code>의 인스턴스이거나, 특별한 메소드를 갖고 있지 않거나, 생성자 자체도 특별한 일을 하진 않는 함수로, <code>Value</code>에 접근 할 때 “아무것도 안하는 함수”를 실행하는 함수의 확장 정도로 보는 경우를 상상해 봤습니다. 그다지 그럴싸한 생각은 아닌가 봅니다. 이런 잡스러운 생각이, Arrow 인터페이스가 왜 모나드 인터페이스보다 표현력이 좋을까를 생각할 때 전 도움이 됐습니다.</p>
<h3 id="함수를-타입으로-감싸서-얻는-이득">함수를 타입으로 감싸서 얻는 이득</h3>
<p>함수를 래핑해서 별도의 인터페이스(컴비네이터)를 만들어 두면 얻을 수 있는, 기능 예시를 보겠습니다.</p>
<p>하스켈은 순수 함수만 있어, 인자로 넘어 오지 않으면 쓰질 못합니다. 전역 변수를 쓸 수 있는 <strong>순수하지 않은 상황</strong>에서, 함수를 합성해서 체인을 만들어 두는데, 각 함수들이 만들어 낸 결과들을 모두 개별로 유지할 필요가 있는 경우를 생각해 보면,</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>globalRes1;</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>globalRes2;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>globalRes3;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>chain init {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  globalRes1 = func1 init </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  globalRes2 = func2 globalRes1</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  globalRes3 = func3 globalRes2</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>another {</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  globalRes1 + globalRes2 + globalRes3  </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>(억지스럽긴 하지만) 대비 되게 보면 이런 식의 코드도 가능하겠지만, 순수 함수만 있는 동네에선 불가능합니다. 순수 함수로만 해결하려면,</p>
<p><strong>“결국, 필요한 정보는 다 가지고 다니는 수밖에 없습니다.”</strong></p>
<p>단, 결과값에만 신경쓸 수 있도록, 추가적인 정보(컨텍스트)를 가지고 다니는 건 눈에 잘 안 보이게 해주는 패턴이 필요합니다. 모나드 바인드에선 람다 함수의 클로저가 이 역할을 합니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>\x <span class="ot">-&gt;</span> \y <span class="ot">-&gt;</span> x <span class="op">+</span> y</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">^^^^^</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>            이 식에서 x를 쓸 수 있어야 편하게 구현할 수 있습니다<span class="op">.</span></span></code></pre></div>
<p>함수를 그냥 합성하지 않고, 합성할 때마다 모나드의 바인드처럼 추가 정보를 잃어버리지 않게 차곡 차곡 챙기려면 어떻게 할까요? 순수 함수만 있는 동네에선 2-튜플이 중요한 수단입니다. <code>(결과값, 추가 정보)</code> 형태로 추가 정보를 잃어버리지 않게 넣어 놓는 방법이 있습니다. 2-튜플을 쓰지 않는다면, 별도의 프로덕트 타입을 만들어서 해결해도 되는데, 이미 준비되어 있는 가장 단순한 2-튜플이 있으니, 이 걸 쓰면 됩니다. 아래 의사 코드를 보겠습니다.</p>
<pre><code>chain init {
  res1 = Arrow1 init
  res2 = Arrow2 res1 (혹은 init)
  return (res1, res2)
}</code></pre>
<p>원래는 <code>res1</code> 하나, <code>res2</code> 하나 이렇게 단일 값을 반환하던 함수를 두 개 묶어서 실행한다면, 두 개의 결과를 언제든 다시 분리할 수 있는 튜플로 <code>(res1, res2)</code> 결과를 반환합니다. 만일, 이 상태에서 또 Arrow를 추가한다면,</p>
<pre><code>chain2 init {
  (res1, res2) = chain1 {
    res1 = Arrow1 init
    res2 = Arrow2 res2
    return (res1, res2)
  }
  res3 = Arrow3 (res2만 뽑아내기)
  return ((res1, res2), res3)
}</code></pre>
<p>또 Arrow를 추가한다면 <code>(((res1, res2), res3), res4)</code> 이렇게 계속 2-튜플의 2-튜플로 유지한다면, 각 개별 결과에 언제든 접근할 수 있는 “가능성”이 생깁니다. 콕 찝어 “가능성”이라 한 이유는, 이 걸 인간이 계속 관리하면서 쓰기엔 사실 가능성만 있을 뿐, 실용적으로 쓰기는 힘들 겁니다.</p>
<p>그냥 함수와 함수를 <code>(.)</code>으로 합성하지 않고, <code>Arrow</code>로 래핑해서 합성하면, <code>Arrow</code>가 제공하는 컴비네이터들을 이용해 이 2-튜플들을 프로그래머가 신경쓰지 않아도, 알아서 안보이게 잘 가지고 다니게 할 수 있습니다. Arrow의 컴비네이터 내부에서는 합성하려던 함수가 <code>a -&gt; b</code>이면, <code>(.)</code>을 쓰고, <code>a -&gt; m b</code>이면 <code>&gt;&gt;</code>을 쓰면 됩니다.</p>
<p>이제, 마지막으로 이렇게 2-튜플의 2-튜플로 만든, 어떻게 보면 우악스러워 보이는 <code>((((...)...)...)...)</code> 형태의 각 각에 접근하는 방법을 모나드의 <code>do</code>표기처럼 쉽게 해 주는 뭔가가 필요합니다.<br />
<code>m1 &gt;&gt;= \r1 -&gt; m2 &gt;&gt;= \r2 -&gt; m3 &gt;&gt;= \r3 -&gt; m4...</code>로 쓰면 복잡하지만,</p>
<pre><code>do
  r1 &lt;- m1
  r2 &lt;- m2
  r3 &lt;- m3
  ...</code></pre>
<p>이렇게 이쁘게 쓸 수 있게 됐듯이, Arrow를 쓰기 편하게 해주는 확장이 있습니다. 아래에서 이어가도록 하겠습니다.</p>
<p>물론, Arrow의 특 장점이 이게 전부는 아닙니다. 체인을 만들면서, 병행 길을 만들기도, 조건에 따라 분기를 만들기도 할 수 있습니다. 위 스트레칭은 그냥 합성composition하지 않고, 타입으로 래핑해서 얻을 수 있는 능력의 일부를 보이려고 든 예시입니다.</p>
<p>모든 분들에게 어울리는 접근 방법은 아니겠지만, 저는 이렇게 뭘 위해 개념을 도입, 혹은 만들어 내고 있는 지 알면 텍스트를 쫓아가기가 편합니다.</p>
<h1 id="arrow">Arrow</h1>
<h2 id="입출력-타입에-의존하는-클래스">입,출력 타입에 의존하는 클래스</h2>
<p>출력 타입에만 의존하지 않고, 입,출력 모두에 의존하도록, 입출력 타입을 타입 매개 변수로 가진 클래스를 정의해, 출력뿐만이 아니라 입력이 달라질 때도 명시적인 리프팅 없이 작업을 할 수 있습니다.</p>
<p>실제 정의는 <code>Category</code> 클래스와 <code>Arrow</code> 클래스로 나누어져 있습니다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> cat <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  id ::</span> cat a a</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (.) ::</span> cat b c <span class="ot">-&gt;</span> cat a b <span class="ot">-&gt;</span> cat a c</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> arr <span class="ot">=&gt;</span> <span class="dt">Arrow</span> arr <span class="kw">where</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  arr ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> arr a b <span class="co">-- 메소드명 arr과 타입인자 arr는 다르다.</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                             <span class="co">-- 모나드 코드 m a에서 m에 해당하는데</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                             <span class="co">-- (b -&gt; c) -&gt; a b c로 표기하기도 한다.</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  first ::</span> a b c <span class="ot">-&gt;</span> a (b,d) (c,d)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  first <span class="ot">=</span> (<span class="op">***</span> <span class="fu">id</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  (***) ::</span> a b c <span class="ot">-&gt;</span> a b' c' <span class="ot">-&gt;</span> a (b,b') (c,c')</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  f <span class="op">***</span> g <span class="ot">=</span> first f <span class="op">&gt;&gt;&gt;</span> arr swap <span class="op">&gt;&gt;&gt;</span> first g <span class="op">&gt;&gt;&gt;</span> arr swap</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> swap <span class="op">~</span>(x,y) <span class="ot">=</span> (y,x)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- 최소 정의 arr, (first | (***))</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- 아래는 메소드가 아닌 별도 함수로 Category 모듈에 정의되어 있다.</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;&gt;) ::</span> <span class="dt">Category</span> arr <span class="ot">=&gt;</span> arr a b <span class="ot">-&gt;</span> arr b c <span class="ot">-&gt;</span> arr a c</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;&gt;&gt;</span> g <span class="ot">=</span> g <span class="op">.</span> f <span class="co">-- dot의 방향때문에 사람 버벅거리게 만든다. f가 먼저냐 g가 먼저냐.</span></span></code></pre></div>
<p>실제 정의는 위와 같이 되어 있지만, 단순하게 보기 위해 텍스트에선 아래 정의에서 설명을 시작합니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  arr ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> arr a b <span class="co">-- 메소드명 arr과 타입인자 arr는 다르다.</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                             <span class="co">-- 모나드 코드 m a에서 m에 해당하는데</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- (b -&gt; c) -&gt; a   b c 로 표기하기도 한다.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;&gt;) ::</span> arr a b <span class="ot">-&gt;</span> arr b c <span class="ot">-&gt;</span> arr a c</span></code></pre></div>
<p>함수 타입을 위한 인스턴스를 만들면,</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  arr <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&gt;&gt;&gt;</span>) <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">.</span>)</span></code></pre></div>
<p>위 <code>(&gt;&gt;&gt;)</code>는 함수 합성 <code>(.)</code>과 비슷하게 arrow를 합성하는데, 인자 순서만 <code>(.)</code>과 거꾸로입니다. 특별히 개별 함수들의 결과값을 튜플로 남긴다거나 하지 않고, 보통의 함수 체인처럼 이전 함수의 결과를 다음 함수의 입력으로 넣어주기만 합니다.</p>
<p>Effect가 있는 Kleisli 타입을 위한 인스턴스를 만들면,</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Kleisli</span> m a b <span class="ot">=</span> <span class="dt">Kleisli</span> {<span class="ot">runKleisli ::</span> a <span class="ot">-&gt;</span> m b}</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Arrow</span> (<span class="dt">Kleisli</span> m) <span class="kw">where</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  arr ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m a b <span class="co">-- (a -&gt; m b)가 아님</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  arr f <span class="ot">=</span> <span class="fu">return</span> <span class="op">.</span> f</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Kleisli</span> m a b <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m b c <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m a c</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  (f <span class="op">&gt;&gt;&gt;</span> g) a <span class="ot">=</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> f a </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                 g b</span></code></pre></div>
<p><code>Kleisli</code> 타입은 내부에서 이미 존재하는 <code>m</code>이 가지고 있는 바인드를 써서 <code>(&gt;&gt;&gt;)</code>를 구현합니다. <code>(-&gt;)</code>와 <code>Kleisli</code>의 <code>arr</code>이나 <code>(&gt;&gt;&gt;)</code>가 별다른 일을 하지 않고 있지만, <code>Arrow</code> 인스턴스가 되면서 <code>&amp;&amp;&amp;, ***, first, second</code>등을 쓸 수 있게 됩니다.</p>
<h2 id="arr-만-있으면-return-를-즉-모나드를-대체할-수-있을까">arr, (&gt;&gt;&gt;)만 있으면 return, (&gt;&gt;=)를, 즉 모나드를 대체할 수 있을까?</h2>
<p>Kleisli 타입을 가진 Arrow가 모나드와 같은 동작을 하고 있을까요? <code>(&gt;&gt;&gt;)</code>의 구현을 보면 바인드가 돌고 있습니다. <code>(&gt;&gt;&gt;)</code>는 그대로 바인드와 대응하는 것으로 보입니다. 텍스트를 보면, <code>(&gt;&gt;=)</code>는 두 번째 인자로 <code>a -&gt; m b</code> 함수를 받기 때문에, 두 개의 Effectful Computation을 순차적으로 실행(계산)하는 동안 어떤 하스켈 코드all of Haskell든 실행할 수 있는 기회가 있다고 얘기합니다. 반면, <code>Arrow</code>는 <code>Arrow</code>타입과 <code>Arrow</code> 타입을 합성하니, <code>Arrow</code>여야만 한다는 <strong>제약</strong>이 있고요.</p>
<p>그런데, 위에서 보듯 <code>(&gt;&gt;&gt;)</code>가 함수가 아닌 <code>Arrow</code>값 두개를 받긴 해도, 안에서 <code>(&gt;&gt;=)</code>가 도는데 차이가 없을 것처럼 보입니다. 원문에는 아래 같은 내용이 있습니다. (Programming with Arrows - John Hughes 발췌)</p>
<blockquote>
<p>In the case of monads, the second argument of (&gt;&gt;=) is a Haskell function, which permits the user of this interface to <strong><em>use all of Haskell to map the result of the first computation to the computation to be performed next. Every time we sequence two monadic computations, we have an opportunity to run arbitrary Haskell code in between them.</em></strong> But in the case of arrows, in contrast, the second argument of (&gt;&gt;&gt;) is just an arrow, an element of an abstract datatype, and the only things we can do in that arrow are things that the abstract data type interface provides. Certainly, the arr combinator enables us to have the output of the first arrow passed to a Haskell function — but this function is a pure function, with the type b -&gt; c, which thus has no opportunity to perform further effects. If we want the effects of the second arrow to depend on the output of the first, then we must construct it using operations other than arr and (&gt;&gt;&gt;)</p>
</blockquote>
<p>이 부분이 스윽 넘어가지지 않아, 아래와 같이 <code>Maybe</code>모나드로 풀어 봤습니다.</p>
<p>첫 컴퓨테이션 값이 <code>Nothing</code>이면, 다음 이어지는 컴퓨테이션에서 <code>a -&gt; m b</code>가 무슨 동작을 하든 <code>Nothing</code> 결과가 나옵니다. 타입을 눈에 보는 그대로 읽으면, <code>m</code>(the effect)도, <code>b</code>도 <code>a</code>에 의존합니다. 어떤 일을 하든지, 해당 타입의 함수만 들어오면 됩니다. 하지만, 바인드와 다르게 <code>(&gt;&gt;&gt;)</code>는 이미 <strong>결정된</strong> Arrow 컴퓨테이션 두 개만 받습니다. 이미 정해진 Arrow 컴퓨테이션에 할 수 있는 일은 Arrow가 제공하는 인터페이스를 이용해서 할 수 있는 일만 가능합니다. (Applicatives도 결정된 컴퓨테이션만 받으니, 둘이 연결되는 개념이 있지 않을까 합니다.) 만일, 지금 손에 쥔 인터페이스가 <code>arr</code>과 <code>(&gt;&gt;&gt;)</code>만 있다면, 어떤 일을 할 수 있는지 보겠습니다.</p>
<p>Mon Feb 5 01:04:47 PM KST 2024 작성 중…</p>
<blockquote>
<p>아래는 <span class="citation" data-cites="Ailrun">@Ailrun</span> 님의 설명을 옮겼습니다.<br />
예를 들어 <code>State</code>를 다음처럼 모나드 인터페이스를 쓰는 것과, <code>Arrow</code> 인터페이스를 쓰는 것을 비교하면</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Monad</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">State</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">set ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">Int</span> ()</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Arrow</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="ot">getA ::</span> <span class="dt">StateArr</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ot">setA ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StateArr</span> <span class="dt">Int</span> ()</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> getA <span class="op">&gt;&gt;&gt;</span> setA <span class="dv">5</span> <span class="co">-- 가능</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> get <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> set (x <span class="op">+</span> <span class="dv">1</span>)) <span class="co">-- 가능</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> getA <span class="op">&gt;&gt;&gt;</span> (\x <span class="ot">-&gt;</span> set (x <span class="op">+</span> <span class="dv">1</span>)) <span class="co">-- 불가능</span></span></code></pre></div>
<p><code>a b c</code> 와 <code>a c d</code> 를 섞는 것 뿐만 아니라<br />
<code>a b c</code> 와 <code>c -&gt; a d e</code> 도 섞을 수 있냐를 얘기하는 겁니다.</p>
<p><code>arr</code>과 <code>(&gt;&gt;&gt;)</code>만으론 다음처럼이 한계입니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mix ::</span> a b c <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a d e) <span class="ot">-&gt;</span> a b (a d e)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>mix p q <span class="ot">=</span> p <span class="op">&gt;&gt;&gt;</span> arr q <span class="co">-- q를 Arrow로 만들어야 하니 arr q</span></span></code></pre></div>
<p><code>first</code>나 <code>app</code> 등이 추가되어야 비로소 (<code>a</code>가 중첩되어 있는 <code>a b (a d e)</code>가 아닌) <code>a (b,d) e</code>를 얻을 수 있게 됩니다.</p>
<p><code>Arrow</code>가 모나드 동작을 할 수 있는가는, “언제 <strong><em>Uncurrying</em></strong>이 가능한 <code>a</code>를 얻을 수 있는가?”라고 볼 수도 있습니다.</p>
<p><code>Monad</code>의 핵심이<br />
<code>join        :: m   (m a)   -&gt; m a</code>이니, 이와 비교하기 좋게 바꿔서 보면,<br />
<code>joinLikeArr :: a b (a c d) -&gt; a (b, c) d</code>를 구현할 수 있냐 없냐가 <code>Arrow a</code>로 <code>Monad</code>가 하던 일을 할 수 있냐 없냐를 결정한다고 볼 수도 있겠습니다.<br />
<code>a b c</code>에서 <code>a</code>가 <code>(-&gt;)</code>인 경우 <code>joinLikeArr</code>은 <code>uncurry</code>와 같습니다.<br />
<code>uncurry :: (b -&gt; c -&gt; d) -&gt; ((b, c) -&gt; d)</code></p>
</blockquote>
<p>위 설명을 풀어 보겠습니다. Arrow의 모나드 인스턴스에 있는 <code>(&gt;&gt;&gt;)</code>는 잘 보면, 내부에서 바인드가 돌도록 되어 있습니다. <code>do</code>를 풀어 바인드가 보이게 하면</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>(f <span class="op">&gt;&gt;&gt;</span> g) a <span class="ot">=</span> f a <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span> g b</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>(<span class="dt">State</span> sa) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (a, s') <span class="ot">=</span> sa s</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">State</span> sb <span class="ot">=</span> f a</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> sb s'</span></code></pre></div>
<p>체이닝을 하려면 Arrow여야 하니, 일단 Arrow로 만들기 위해 <code>arr (\x -&gt; setA(x + 1))</code>을 생각해 보면,</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  arr ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a b c </span></code></pre></div>
<p><code>c</code> 부분에 <code>a d e</code>를 넣으면, 결과는 <code>a b (a d e)</code>가 됩니다. <code>getA &gt;&gt;&gt; arr(\x -&gt; setA(x+1))</code>을 타입을 보면,</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>a b c <span class="op">&gt;&gt;&gt;</span> a b (a d e)</span></code></pre></div>
<p>첫 번째 함수 <code>getA</code>에 <code>s0</code>를 넣어 돌려 <code>(r1, s1)</code>이 나오고, 결과 <code>r1</code>을 <code>b</code>로 받아 <code>\x -&gt; setA(x + 1)</code>를 <code>b</code>에 적용하면, <code>setA(r1 + 1)</code> 작업을 하고, 결과는 <code>State $\s -&gt; let ... in (State $ \s-&gt; ...)</code>이 됩니다. 이어지는 <code>\x -&gt; ...State ...</code>가 받을 수 없는 <code>State</code>가 중첩된 값이 돼버렸습니다. 이대로는 바인드처럼 체이닝을 할 수 없습니다.</p>
<p><code>StateArr Int (StateArr Int a)</code>의 의미는 뭘까요? <code>Int -&gt; StateArr Int a</code>인 함수인데, Arrow 인터페이스를 가지고 있다는 뜻입니다. 이 함수와 이어질 함수는 <code>StateArr</code>을 하나 벗긴 <code>StateArr Int a</code>을 받을 수 있어야 하는데, 액션 모양은 <code>Int -&gt; ...</code>로 <code>StateArr</code>을 받질 못합니다.</p>
<p>여기까지 <code>(&gt;&gt;&gt;)</code>와 <code>arr</code> 만으론 모나드가 하는 일을 표현할 수 없다를 봤습니다.</p>
<p>(※ <a href="https://lionhairdino.github.io/posts/2022-09-06-applicative_functor.html">모나드와 Applicatives의 차이</a>를 고민할 때, 모나딕한 동작을 하려면 <code>a -&gt; m b</code> 형태가 반드시 있어야 하고, <code>m b</code> 만으론 부족하다고 틀리게 생각했던 것과 약간 비슷한 요소가 보입니다. )</p>
<p>※ 모나드는 3개의 법칙만 있지만, Arrow는 20개가 있습니다. 여기에 Paterson이 추가한 것까지 합치면 27개입니다. 텍스트에서도 너무 정교한 설명말고 사용법 위주로 설명한다고 되어 있습니다.</p>
<blockquote>
<p><span class="citation" data-cites="bgl">@bgl</span> gwyng 님의 “정적인 정보를 가지고 있을 때 유용한 Arrow”에 대한 예시를 옮겨 왔습니다.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">WeigthedValue</span> a <span class="ot">=</span> <span class="dt">WeighteValue</span> {<span class="ot"> value::</span> a,<span class="ot"> weight::</span> <span class="dt">Int</span> }</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a <span class="ot">-&gt;</span> <span class="dt">WeightedValue</span> b</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> b <span class="ot">-&gt;</span> <span class="dt">WeightedValue</span> c</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="ot">h ::</span> c <span class="ot">-&gt;</span> <span class="dt">WeightedValue</span> d</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;&gt;&gt;</span> g <span class="op">&gt;&gt;&gt;</span><span class="ot"> h ::</span> a <span class="ot">-&gt;</span> <span class="dt">WeightedValue</span> d <span class="co">-- (가)</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">WeigthedFunction</span> a b <span class="ot">=</span> <span class="dt">WeigthedFunction</span> {<span class="ot"> f::</span> a <span class="ot">-&gt;</span> b,<span class="ot"> weight::</span> <span class="dt">Int</span> }</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="dt">WeightedFunction</span> fImpl <span class="dv">10</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>g <span class="ot">=</span> <span class="dt">WeightedFunction</span> gImpl <span class="dv">5</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>h <span class="ot">=</span> <span class="dt">WeightedFunction</span> hImpl <span class="dv">7</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;&gt;&gt;</span> g <span class="op">&gt;&gt;&gt;</span><span class="ot"> h ::</span> <span class="dt">WeightedFunction</span> a d <span class="co">-- (나)</span></span></code></pre></div>
<p>함수들이 실행 비용(실행 시간이라든가)을 정적인 정보로 가지고 있을 때,<br />
해당 타입의 모나드 체인 <code>(가)</code>의 경우 실행을 해 보기 전엔 알 수 없지만,<br />
Arrow 체인 <code>(나)</code>의 경우는 간단히 <code>weight (f &gt;&gt;&gt; g &gt;&gt;&gt; h)</code>로 실행전에 알 수 있습니다.</p>
</blockquote>
<h2 id="applicatives와-arrow-비교">Applicatives와 Arrow 비교</h2>
<p><span class="citation" data-cites="todo">@todo</span></p>
<h2 id="모나드가-하는-일을-할-수-있도록-인터페이스를-확장해-보자">모나드가 하는 일을 할 수 있도록 인터페이스를 확장해 보자</h2>
<p>Arrow가 모나드와 비슷한 동작을 할 수 있게 만드는 인터페이스입니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> a <span class="ot">=&gt;</span> <span class="dt">ArrowApply</span> a <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  app ::</span> a (a b c, b) c</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ArrowApply</span> (<span class="dt">StateArr</span> s) <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  app <span class="ot">=</span> \(arr, x) <span class="ot">-&gt;</span> arr x</span></code></pre></div>
<p>지금부터 2-튜플의 2-튜플…로 함수들의 결과들을 각 각 기억하는 방법을 위해 필요한 도구(<code>&amp;&amp;&amp;</code>,<code>***</code>,<code>first</code>,<code>second</code>)들을 보겠습니다.</p>
<p>모나드에 들어 있는 두 값을 더하는 것을 보면</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>addM a b <span class="ot">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>              y <span class="ot">&lt;-</span> b</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>              <span class="fu">return</span> (x <span class="op">+</span> y)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- 바인드가 보이게 하면</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>a <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> b <span class="op">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> <span class="fu">return</span> (x <span class="op">+</span> y)</span></code></pre></div>
<p>위를 읽을 때, <code>a</code> 계산식의 결과를 <code>b</code>가 받는 것으로 읽는 게 아닙니다. <code>a</code> 계산식의 결과를 <code>x</code>로 받고, (이 경우는) <code>a</code>의 결과와 상관 없이 <code>b</code>계산식의 결과를 <code>y</code>로 받아, 마지막에 둘을 <code>+</code>하는 작업입니다. 어떤 <code>M</code>이 들어왔냐에 따라, 숨어 있는 바인드 인스턴스가 알아서 Effect 작업을 담당합니다.</p>
<p>함수형에서는 스코프가 넒은 변수를 쓸 수가 없어, 여러 개의 정보를 “유통”시키려면 인자를 늘리거나 튜플을 씁니다.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addA ::</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> arr a <span class="dt">Int</span> <span class="ot">-&gt;</span> arr a <span class="dt">Int</span> <span class="ot">-&gt;</span> arr a <span class="dt">Int</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>addA f g <span class="ot">=</span> f_and_g <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="op">+</span>))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- uncurry는 인자를 두 개 받는 함수를 2-튜플 하나를 받는 함수로 바꿔줍니다.</span></span></code></pre></div>
<p><code>f</code>,<code>g</code> 계산을 튜플로 묶은 후 다음으로 넘기면 됩니다. 여기서 <code>f_and_g</code>는 <code>f, g, (&gt;&gt;&gt;), arr</code>만으론 구현할 수 있을까요?</p>
<p><code>... &gt;&gt;&gt; f &gt;&gt;&gt; ...</code>로 체인을 만들어 두면 <code>f</code>가 나온 뒤에는 <code>f</code>의 결과값 말고는 다 잃어버립니다. 위에 모나드 예시로 보면 <code>x</code>를 기억시키지 못합니다. <code>g</code>의 출력도, 제일 처음에 입력으로 받았던 값도 모두 잃어버립니다.</p>
<blockquote>
<p>Q. 어차피 타입에 따른 인스턴스를 만들어야 하는데, 이 때 메소드를 잘 만들면 가능하지 않을까요?<br />
A. <code>(&gt;&gt;&gt;)</code>를 “자유”롭게 만들 수 있는 건 아닙니다. 서명이 <code>Arrow.. -&gt; Arrow.. -&gt; Arrow..</code>으로 정해져 있습니다.</p>
</blockquote>
<h2 id="section">(&amp;&amp;&amp;)</h2>
<p>그래서 2-튜플을 이용해 각 각의 결과를 유지하기 위해 <code>Arrow</code>에 다음 컴비네이터를 추가합니다. 2-튜플은 두 개의 값을 담아 둘 수 있으니, <code>(&amp;&amp;&amp;)</code>를 적절히 구현해서 두 <code>Arrow</code>의 결과가 각각 2-튜플에 담기도록 하면, 일단 필요한 정보는 살릴 수 있습니다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&amp;&amp;&amp;) ::</span> arr a b <span class="ot">-&gt;</span> arr a c <span class="ot">-&gt;</span> arr a (b, c)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>                                       <span class="op">^^^^^^</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>                                        <span class="dv">2</span><span class="op">-</span>튜플</span></code></pre></div>
<p><code>Arrow</code> 두 개를 받아 각 각의 Computation을 실행하고, <code>(&gt;&gt;&gt;)</code>처럼 이어지는 Computation에 결과를 넘기는 게 아니라, 결과를 2-튜플로 만드는 컴비네이터입니다. 이제, 이를 이용하면 <code>f_and_g</code>를 구현할수 있습니다.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>addA f g <span class="ot">=</span> f <span class="op">&amp;&amp;&amp;</span> g <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="op">+</span>))</span></code></pre></div>
<p>위에서 봤던 함수와 Kleisli 타입을 위한 인스턴스를 다음과 같이 구현할 수 있습니다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  (f <span class="op">&amp;&amp;&amp;</span> g) a <span class="ot">=</span> (f a, g a)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Arrow</span> (<span class="dt">Kleisli</span> m) <span class="kw">where</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Kleisli</span> f <span class="op">&amp;&amp;&amp;</span> <span class="dt">Kleisli</span> g <span class="ot">=</span> <span class="dt">Kleisli</span> <span class="op">$</span> \a <span class="ot">-&gt;</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> f a</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>                                               c <span class="ot">&lt;-</span> g a</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>                                               <span class="fu">return</span> (b, c)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- stream 함수 `SF`의 경우는 `f`와 `g`의 출력을 `zip`하면 된다.</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">SF</span> <span class="kw">where</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SF</span> f <span class="op">&amp;&amp;&amp;</span> <span class="dt">SF</span> g <span class="ot">=</span> <span class="dt">SF</span> (f <span class="op">&amp;&amp;&amp;</span> g <span class="op">&gt;&gt;&gt;</span> <span class="fu">uncurry</span> <span class="fu">zip</span>)</span></code></pre></div>
<p>각각의 <code>Arrow</code>에 들어 있는 함수들의 결과를 튜플에 넣게만 만들면 됩니다.<br />
※ “각각” 돌기 때문에 <code>&amp;</code>를 쓴 것 같은데, 네이밍에 관한 설명은 따로 안 보입니다.</p>
<p>※ <code>(&amp;&amp;&amp;)</code>의 결과를 머릿속에서 단순한 모양으로 reduce하려 하지 말아야 합니다.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Kleisli</span> <span class="op">$</span> \a <span class="ot">-&gt;</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> f a</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>                   c <span class="ot">&lt;-</span> g a</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>                   <span class="fu">return</span> (b, c)</span></code></pre></div>
<p>이 자체가 가장 단순한 모양입니다.</p>
<h2 id="section-1">(***)</h2>
<p>다음으로 할 일은, 최대한 타입에 따라 바뀌지 않는 부분을 분리해기 위해 다음처럼 생각해 볼 수 있습니다. 위 구현을 보면 <code>a</code>를 한 번 받아 <code>f</code>에 한 번, <code>g</code>에 한 번씩 쓰고 있습니다. <code>a</code>를 복사duplicate하는 성질(<code>\x -&gt; (x,x)</code>)을 빼내면 다음 처럼 볼 수 있습니다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&amp;&amp;&amp;</span> g <span class="ot">=</span> arr (\x <span class="ot">-&gt;</span> (x, x)) <span class="op">&gt;&gt;&gt;</span> f <span class="op">***</span> g</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co">--              a -&gt;   b     &gt;&gt;&gt; b -&gt; c</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- b가 2-튜플 타입이고, (f *** g)는 2-튜플을 받는 함수를 가지고 있는 Arrow다.</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="kw">where</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  (***) ::</span> arr a b <span class="ot">-&gt;</span> arr c d <span class="ot">-&gt;</span> arr (a,c) (b,d)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- 따로 받던 a, c를 같이 튜플로 묶어서 받고, 결과값도 튜플로 묶는다. 그냥, 각각 동작할 함수들의 입력을 짝 짓고, 출력을 짝지어 묶어놨을 뿐이다.</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- a, b는 같을 필요 없다. 이 경우는 duplicate해서 들어오고 있다.</span></span></code></pre></div>
<p><code>(***)</code>는 두 개의 <code>Arrow</code>를 받아 2-튜플을 받고 뱉는 하나의 <code>Arrow</code>로 만듭니다. 이 건 하나의 <code>Arrow</code>를 2-튜플을 가진 <code>Arrow</code>로 리프팅해서 얻을 수도 있습니다. 저는 이 아이디어가 금방 눈에 들어오지 않았습니다.<br />
현재 목표는 값 하나를 넣어주면, 두 개로 만들어 (이 작업은 이미 <code>(***)</code>전에 이루어집니다.),<br />
<code>(***)</code>이 2-튜플로 결과를 반환 할 수 있어야 합니다.(<code>(***)</code>가 하는 일)</p>
<p>그런데, 이 전 구현보다 더 단순해진 것도 아니고, 굳이 이렇게 구현해야 하는 생각이 잠깐 들었습니다. 뒤에 보면, 2-튜플로 저글링을 많이 합니다. 아마도 이를 위한 컴비네이터 아닌가 싶습니다.</p>
<h2 id="first">first</h2>
<p>처음 봤을 때는, 이 것도 왜 필요한지 금방 눈에 들어오지 않았습니다.<br />
왜 모나딕한 동작을 위해서, <code>first</code>가 필요할까요? 텍스트에선 친절하게 말해주지 않습니다. (제가 못찾거나요)</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="kw">where</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  first ::</span> arr a b <span class="ot">-&gt;</span> arr (a,c) (b,c)</span></code></pre></div>
<p>first를 함수, Kleisli arrow, Stream function을 위한 구현을 보면</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 클래스에 있는 서명을 보면 first는 인자를 하나만 받고 있지만,</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- arr에 (-&gt;)를 넣으면</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- ((-&gt;) a b) -&gt; ((-&gt;) (a,c) (b,c))</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- 아래와 같이 2개의 인자를 받는 모양이 된다.</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="co">--      (a -&gt; b) -&gt; (a,c) -&gt; (b  ,c)</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  first     f       (a,c) <span class="ot">=</span>  (f a,c) </span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Arrow</span> (<span class="dt">Kleisli</span> m) <span class="kw">where</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  first (<span class="dt">Kleisli</span> f) <span class="ot">=</span> <span class="dt">Kleisli</span> (\(a,c) <span class="ot">-&gt;</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> f a</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>                                            <span class="fu">return</span> (b,c))</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">SF</span> <span class="kw">where</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>  first (<span class="dt">SF</span> f) <span class="ot">=</span> <span class="dt">SF</span> (<span class="fu">unzip</span> <span class="op">&gt;&gt;&gt;</span> first f <span class="op">&gt;&gt;&gt;</span> <span class="fu">uncurry</span> <span class="fu">zip</span>)</span></code></pre></div>
<p><strong><em>눈여겨 볼 부분은 현재 계산식에 영향을 미치지 않는 정보를 얹힐 <code>( ,c)</code>가 있는 겁니다.</em></strong><br />
구현을 말로 읽어 보면, 당장은 필요 없는 <code>c</code>를, 지금 필요한 <code>a</code>와 묶어서 넘기면 <code>a</code>에만 작업을 해주는 단순한 일을 하는 컴비네이터입니다. 물론 컨텍스트는 유지해 주면서요. 값 하나를 받아 하나만 반환하던 Arrow를 <code>first</code>로 변환하면, 튜플을 받고 튜플을 내뱉는 함수로 바뀝니다.</p>
<p><code>Arrow</code>클래스의 최소 정의를 보면 <code>first</code>또는 <code>(***)</code> 둘 중 하나만 구현하면, 구현된 걸로 나머지 하나를 구현할 수 있다고 되어 있습니다. <code>first</code>로 <code>(***)</code>을 구현하려면 우선 <code>second</code>를 정의합니다.</p>
<h2 id="second">second</h2>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">second ::</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> arr a b <span class="ot">-&gt;</span> arr (c,a) (c,b)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>second f <span class="ot">=</span> arr swap <span class="op">&gt;&gt;&gt;</span> first f <span class="op">&gt;&gt;&gt;</span> arr swap</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> swap (x,y) <span class="ot">=</span> (y,x)</span></code></pre></div>
<p><strong><em>역시 눈여겨 볼 부분은 현재 계산식에 영향을 미치지 않는 정보를 얹힐 <code>(c, )</code>가 있는 겁니다.</em></strong></p>
<p><code>second</code>는 <code>first</code>로 구현되기 때문에 따로 구현할 필요 없이, 위 디폴트 구현으로 어디든 쓰면 됩니다. <code>first</code>만 있다면 말입니다.</p>
<h2 id="다시-정의">(***) 다시 정의</h2>
<p>이제, <code>first</code>, <code>second</code>를 써서 <code>(***)</code>를 정의할 수 있습니다.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">***</span> g <span class="ot">=</span> first f <span class="op">&gt;&gt;&gt;</span> second g</span></code></pre></div>
<p>왜 이렇게 될까요?</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 비교하기 좋게 constraint는 생략하고 보면</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="ot">first  ::</span> arr a b <span class="ot">-&gt;</span> arr (a,c) (b,c)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="ot">second ::</span> arr x y <span class="ot">-&gt;</span> arr (d,x) (d,y)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;&gt;)  ::</span> arr a b         <span class="ot">-&gt;</span> arr b c         <span class="ot">-&gt;</span> arr a c</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>          arr (a,c) (b,c) <span class="ot">-&gt;</span> arr (d,x) (d,y) <span class="ot">-&gt;</span> arr (a,c) (d,y) </span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>                 <span class="co">-- (b,c) = (d,x) 가 같아야만 합니다.</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>                 <span class="co">-- d = b 이고, c = x 입니다.</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>                                             <span class="ot">-&gt;</span> arr (a,x) (b,y)</span></code></pre></div>
<p>최종 결과 타입만 보면 <code>arr (a,x) (b,y)</code>에<br />
처음 액션 혹은 함수인 <code>f</code>의 결과 값 <code>b</code>가 살아 있어야 하고,<br />
다음 액션 혹은 함수인 <code>g</code>의 결과 값 <code>y</code>가 살아 있어야 합니다.<br />
마지막 <code>(b,y)</code>에는 둘 다 살아 있으니 목표 달성인 건 맞을 것 같긴 합니다. 역시나 텍스트는 친절하지 않습니다.</p>
<p><code>first f &gt;&gt;&gt; second g</code>는 현재 목적에 맞는지 말로 읽어보면, 언젠가 값을 duplicate한 2-튜플을 받아 <code>f</code>에 한 번 넣어주고, <code>g</code>에 한 번 넣어줘서 각 결과값을 다시 튜플로 묶습니다. 두 번의 액션(혹은 함수)의 결과가 모두 살아 있으니 목표 달성입니다.</p>
<p>아이디어를 정리하면 <code>f</code>도 <code>a</code>가 필요하고, <code>g</code>도 <code>a</code>가 필요합니다.</p>
<ul>
<li><code>a</code>를 <code>(a,a)</code>로 만듭니다.</li>
<li><code>f</code>로 앞에 <code>a</code>만 바꿉니다. <code>(f a, a)</code></li>
<li><code>g</code>로 뒤에 <code>a</code>만 바꿉니다. <code>(f a, g a)</code></li>
</ul>
<p>만일 <code>(***)</code>가 먼저 위와 같은 동작을 하도록 정의되어 있다면,</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>first f <span class="ot">=</span> f <span class="op">***</span> arr <span class="fu">id</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- (***) :: arr a b -&gt; arr c d -&gt; arr (a,c) (b,d)</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- arr a b *** arr b b = arr (a,b) (b,b)</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- 2-튜플을 받아 앞에 것에만 작업 할 수 있게 했을 뿐, 별다른 작업은 없습니다.</span></span></code></pre></div>
<p><code>f</code>는 <code>a -&gt; b</code> 함수고, <code>first f</code>는 <code>(a,dontTouch) -&gt; (b,dontTouch)</code>함수 입니다.<br />
<code>second</code>도, <code>(***)</code>도 <code>first</code>만 있으면 구현할 수 있습니다. 이제 <code>first</code>만 있으면 합성하며, 이전 액션(혹은 함수)의 결과를 다음에 넘기는 일을 할 수 있습니다.</p>
<p>그 외, <code>(^&gt;&gt;)</code>, <code>(&gt;&gt;^)</code>, <code>(&lt;&lt;^)</code>, <code>(^&lt;&lt;)</code> 들은 순수 함수들을 합성compose할 때 <code>arr</code>을 매 번 쓰는 귀찮음을 덜어주는 편의 컴비네이터들입니다.</p>
<p><code>(***)</code>, <code>first</code>, <code>second</code> 모두 어떤 함수가 들어오든 상관없이 <strong>튜플 구조에만</strong> 관여하는 컴비네이터들로, 이들 중 하나만 구현되어 있으면, 그 걸로 나머지를 구현할 수 있습니다.</p>
<h2 id="조건부로-arrow-컴비네이션하기">조건부로 Arrow 컴비네이션하기</h2>
<p>지금부턴 Arrow를 막강하게 해주는 특징, 다이내믹한 흐름을 위한 도구(<code>|||</code>, <code>mapA</code>, <code>+++</code>, <code>left</code>, <code>right</code>)들을 보겠습니다.</p>
<p>If Then Else - ifte</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ifte ::</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> arr a <span class="dt">Bool</span> <span class="ot">-&gt;</span> arr a b <span class="ot">-&gt;</span> arr a b <span class="ot">-&gt;</span> arr a b</span></code></pre></div>
<p><code>ifte p f g</code>는 불린값 <code>p</code>가 참이면 <code>f</code>, 거짓이면 <code>g</code></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- (&amp;&amp;&amp;) :: arr a b -&gt; arr a c -&gt; arr a (b, c)</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>ifte p f g <span class="ot">=</span> p <span class="op">&amp;&amp;&amp;</span> arr <span class="fu">id</span> <span class="op">&gt;&gt;&gt;</span> f <span class="op">|||</span> g</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>             <span class="op">^^^^^^^^^^^^</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- 왜 이렇게 할까요?</span></span></code></pre></div>
<p><code>p &amp;&amp;&amp; arr id</code>는 왜 해주는 걸까요? <code>p</code>는 조건에 맞는지 검사 후 <code>Bool</code>값을 반환하는 함수입니다.<br />
<code>arr a Bool &amp;&amp;&amp; arr a a = arr a (Bool, a)</code><br />
원래의 함수는 <code>Bool</code>만 돌려주는데, <strong>변환한 함수</strong>는 결과에 <code>Bool</code>값과 처음 입력한 값을 같이 2-튜플에 남겨 둘 수 있습니다.</p>
<h2 id="section-2">(|||)</h2>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">&amp;&amp;&amp;</span> arr<span class="ot"> id ::</span> arr a (불린값, f나g에 넣어줄 입력값)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">|||</span><span class="ot"> g ::</span> arr (a, b) c</span></code></pre></div>
<p><code>(|||)</code>는 불린값에 따라 <code>f</code> 혹은 <code>g</code>를 고르고 입력값을 넣어줍니다.</p>
<p>입력값을 2-튜플이 아닌 <code>Either</code>를 받도록 하면 좀 더 매끄러울 수 있습니다. <code>(True, a)</code>를 <code>Left a</code>로, <code>(False, a)</code>를 <code>Right a</code>로 하면 <code>Left</code>일 때와 <code>Right</code>일 때 다른 타입을 갖고 있게 할 수 있어 표현력이 늘어 납니다.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> <span class="dt">ArrowChoice</span> arr <span class="kw">where</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  (|||) ::</span> arr a c <span class="ot">-&gt;</span> arr b c <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a b) c</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>                                     <span class="op">^^^^^^^^^^^^</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- 여기를 2-튜플이 아닌 Either로 바꾼다.</span></span></code></pre></div>
<p>아직 duality에 대한 지식이 없어 정확한 “감탄”은 못하지만, 위 서명에서 <code>arr</code>의 인자 순서를 바꾸고, <code>Either a b</code>를 <code>(a, b)</code>로 대체하면 <code>(&amp;&amp;&amp;)</code>가 나옵니다.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  (|||) ::</span> arr a c <span class="ot">-&gt;</span> arr b c <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a b) c</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&amp;&amp;&amp;) ::</span> arr a b <span class="ot">-&gt;</span> arr a c <span class="ot">-&gt;</span> arr a (b, c)</span></code></pre></div>
<p>conditional을 쓴 예시로 <code>mapA</code> 함수를 보겠습니다.</p>
<h2 id="mapa">mapA</h2>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapA ::</span> <span class="dt">ArrowChoice</span> arr <span class="ot">=&gt;</span> arr a b <span class="ot">-&gt;</span> arr [a] [b]</span></code></pre></div>
<p><code>mapA</code>는 choice가 필요합니다. 왜 필요할까요?</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> _ []     <span class="ot">=</span> [] <span class="co">-- base case 혹은 edge case</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> <span class="fu">map</span> f xs <span class="co">-- recursive case</span></span></code></pre></div>
<p><code>map</code>은 보통 base, recursive를 구분해야 합니다. 다음처럼 표현할 수 있습니다.<br />
<code>base case ||| recursive case</code></p>
<p>우선 입력을 <code>Either</code> 타입으로 바꿔주는 보조 함수를 만들고,</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>listcase [] <span class="ot">=</span> <span class="dt">Left</span> ()</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>listcase (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Right</span> (x,xs)</span></code></pre></div>
<p>이제 <code>mapA</code>를 구현하면</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>mapA f <span class="ot">=</span> arr listcase <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>         arr (<span class="fu">const</span> []) <span class="op">|||</span> (f <span class="op">***</span> mapA f <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="op">:</span>)))</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="co">--                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co">--                      map의 f x : map f xs 와 비슷한 동작을 한다.</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="co">--            uncurry는 인자 두 개를 받던 함수를 2-튜플 하나 받는 걸로 바꾼다.</span></span></code></pre></div>
<p>컴비네이터 스타일의 우아함이 폭발하는데, 저는 금방 우아할 수가 없습니다. 어렵습니다.</p>
<h2 id="section-3">(+++)</h2>
<p><code>f ||| g</code>는 <code>f</code>와 <code>g</code>가 같은 타입의 출력이어야 하는데, <code>Either</code>를 쓰면 다른 타입도 가능합니다.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> <span class="dt">ArrowChoice</span> arr <span class="kw">where</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  (+++) ::</span> arr a b <span class="ot">-&gt;</span> arr c d <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a c) (<span class="dt">Either</span> b d)</span></code></pre></div>
<p><code>(+++)</code>과 <code>(|||)</code>의 관계는 <code>(***)</code>과 <code>(&amp;&amp;&amp;)</code>의 관계와 비슷합니다. <code>(|||)</code>를 직접 구현하는 것 보다는 <code>(+++)</code>를 먼저 구현하고, <code>(+++)</code>을 써서 <code>(|||)</code>를 구현하는 게 편합니다.</p>
<p><code>(+++)</code>는 <code>(***)</code>와 dual입니다. <code>Either</code> 타입을 2-튜플로 바꾸고, <code>arr</code>의 인자 순서를 바꾸면 <code>(|||)</code>의 정의는</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">|||</span> g <span class="ot">=</span> f <span class="op">+++</span> g <span class="op">&gt;&gt;&gt;</span> arr join <span class="co">-- 라이브러리에선 join대신 untag란 이름을 쓴다.</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> join (<span class="dt">Left</span> b)  <span class="ot">=</span> b</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>        join (<span class="dt">Right</span> b) <span class="ot">=</span> b</span></code></pre></div>
<p><code>(***)</code>를 <code>first</code>로 표현하듯, <code>(+++)</code>는 <code>Either</code>의 <code>left</code>로 리프팅하는 단순한 컴비네이터로 정의할 수 있습니다.</p>
<p><code>(***)</code>는 두 개의 Arrow를 받아 2-튜플로 묶는 작업을 했고,(두 Arrow 모두 실행)<br />
<code>(+++)</code>는 두 개의 Arrow를 받아 <code>Either</code>로 묶는 작업을 했습니다. (두 Arrow 중 하나만 실행하기 위한 사전 동작?)<br />
</p>
<h2 id="left">left</h2>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> <span class="dt">ArrowChoice</span> arr <span class="kw">where</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  left ::</span> arr a b <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a c) (<span class="dt">Either</span> b c)</span></code></pre></div>
<p><code>left f</code>는 <code>Left</code>라고 태깅된 입력은 <code>f</code>에 넣어주고, <code>Right</code>라고 태깅된 입력은 그냥 통과시킵니다.</p>
<h2 id="right">right</h2>
<p><code>first</code>로 <code>second</code>를 정의하듯 <code>left</code>로 <code>right</code>를 정의할 수 있습니다.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>right f <span class="ot">=</span> arr mirror <span class="op">&gt;&gt;&gt;</span> left f <span class="op">&gt;&gt;&gt;</span> arr mirror</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> mirror (<span class="dt">Left</span> a) <span class="ot">=</span> <span class="dt">Right</span> a <span class="co">-- swap을 정의하 듯</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>        mirror (<span class="dt">Right</span> a) <span class="ot">=</span> <span class="dt">Left</span> a</span></code></pre></div>
<p>…작성 중</p>
<h2 id="다시-정의-1">(+++) 다시 정의</h2>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">+++</span> g <span class="ot">=</span> left f <span class="op">&gt;&gt;&gt;</span> right g</span></code></pre></div>
<h2 id="사용-예시">사용 예시</h2>
<p><a href="../posts/2023-09-22-using_arrow.html">Arrow 쓰는 방법</a></p>
<h2 id="arrow-확장">Arrow 확장</h2>
<p><a href="../extensions/2023-09-14-arrow-extension.html">확장 Arrows</a></p>
<p>마치 함수를 일반 수처럼 여러 연산자들로 식을 만드는 것 같이 보입니다. Arrow 대수라고 불러도 되지 않을까 싶은데요. 따로 대수라고 부르는데는 못 봤습니다. 컴비네이터 패턴이란게 다 대수와 같은 것들 아닌가 싶습니다.</p>
<p>참고<br />
시간과 머리가 허락한다면, <a href="https://wiki.haskell.org/Arrow#Parser">wiki.haskell.org - Arrow</a> 사이트에 있는 링크를 쫓아다니며 공부하면 Arrow 마스터!가 될 수도 있겠습니다만, 분량이 너무 많습니다.</p>
<h1 id="추가">2025.2 추가</h1>
<p>아래는 모두 Programming with Arrows - John hughes에서 발췌한 소스입니다.</p>
<h2 id="a---b-와-a---m-b-모양-함수들을-체이닝">a -&gt; b 와 a -&gt; m b 모양 함수들을 체이닝</h2>
<p>단어 <code>w</code>가 몇 번 나타나는지 찾는 작업</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- count :: String -&gt; String -&gt; Int</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> count w <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">==</span>w) <span class="op">.</span> <span class="fu">words</span> <span class="co">--(가)</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> count <span class="st">&quot;ab&quot;</span> <span class="st">&quot;ab bc ab&quot;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span></code></pre></div>
<p>만일 파일에서 읽어와 화면에 출력하려면 <code>print</code>와 <code>readFile</code>을 합성해야 합니다.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>count w <span class="ot">=</span> <span class="fu">print</span> <span class="op">.</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">==</span>w) <span class="op">.</span> <span class="fu">words</span> <span class="op">.</span> <span class="fu">readFile</span> <span class="co">-- 타입 불일치</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co">--        액션                   함수              액션</span></span></code></pre></div>
<p>하지만 이펙트가 있는 <code>IO</code>액션과 함수를 이렇게 합성할 수 없습니다. <code>(가)</code>를 리프팅해서 <code>IO</code> 컨텍스트로 들어가야 합니다.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>count w <span class="ot">=</span> (<span class="op">&gt;&gt;=</span><span class="fu">print</span>) <span class="op">.</span> liftM (<span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">==</span>w) <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">readFile</span></span></code></pre></div>
<p>둘이 합칠 때, 좀 더 이쁘게 보이도록 함수 타입을 위한 인스턴스를 만들고,</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  arr <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&gt;&gt;&gt;</span>) <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">.</span>)</span></code></pre></div>
<p>액션(<code>Kleisli</code>)을 위한 인스턴스를 만들면,</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Kleisli</span> m a b <span class="ot">=</span> <span class="dt">Kleisli</span> {<span class="ot">runKleisli ::</span> a <span class="ot">-&gt;</span> m b}</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Arrow</span> (<span class="dt">Kleisli</span> m) <span class="kw">where</span> </span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  arr ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m a b <span class="co">-- (a -&gt; m b)가 아님</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>  arr f <span class="ot">=</span> <span class="fu">return</span> <span class="op">.</span> f</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Kleisli</span> m a b <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m b c <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m a c</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>  (f <span class="op">&gt;&gt;&gt;</span> g) a <span class="ot">=</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> f a </span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>                   g b</span></code></pre></div>
<p>다음처럼 쓸 수 있습니다. (순서가 바뀌긴 했는데, <code>(.)</code>이 수학쪽 관습을 맞춘 것입니다. 먼저 작업해야 하는 걸 먼저 써주는 게 좋으니, 아래처럼 바뀌게 됩니다.)</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> count w <span class="ot">=</span> <span class="dt">Kleisli</span> <span class="fu">readFile</span> </span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>             <span class="op">&gt;&gt;&gt;</span> arr <span class="fu">words</span> </span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>             <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">filter</span> (<span class="op">==</span> w)) </span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>             <span class="op">&gt;&gt;&gt;</span> arr <span class="fu">length</span> </span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>             <span class="op">&gt;&gt;&gt;</span> <span class="dt">Kleisli</span> <span class="fu">print</span> </span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> runKleisli (count <span class="st">&quot;aa&quot;</span>) <span class="st">&quot;some.txt&quot;</span>  <span class="co">-- some.txt 내용: aa bb aa</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span></code></pre></div>
<p><strong>함수<code>a -&gt; b</code>와 액션<code>c -&gt; m d</code> 모양을 합성하는데, 어느 정도 통일된 모양으로 써줄 수 있게 됐습니다.</strong><br />
<code>arr</code>은 함수를 리프팅하는데, 함수를 먼저 합성한 후 리프팅해도 되니(자세하게는 Arrow 법칙을 봐야 하는데, 여기선 넘어 가겠습니다.) 다음처럼 써도 있습니다.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>count w <span class="ot">=</span> <span class="dt">Kleisli</span> <span class="fu">readFile</span> <span class="op">&gt;&gt;&gt;</span>    arr (<span class="fu">words</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">filter</span> (<span class="op">==</span>w) <span class="op">&gt;&gt;&gt;</span> <span class="fu">length</span>)    <span class="op">&gt;&gt;&gt;</span> <span class="dt">Kleisli</span> <span class="fu">print</span> </span></code></pre></div>
<p><code>arr</code>안에 있는 <code>&gt;&gt;&gt;</code>는 함수의 인스턴스고, 바깥에 있는 <code>&gt;&gt;&gt;</code>는 <code>Kleisli</code>의 인스턴스입니다.</p>
<h2 id="arrow는-입-출력에-매개-변수화-되어-있다">Arrow는 입, 출력에 매개 변수화 되어 있다</h2>
<p>“The way monadic programs take input cannot be varied by varying the monad”</p>
<p>모나딕 프로그램은 모나드를 변경하는 것만으로 다양한 입력을 받을 수 없다? 무슨 뜻일까요?<br />
출력에만 매개 변수화parameteriezed 되어 있는 것과, 입, 출력 둘에 매개 변수화 되어 있는 것의 차이는 뭘까요?</p>
<p><code>Maybe</code>는 출력 타입 하나를 인자로 받고, <code>Arrow</code>는 입력, 출력 두 개를 인자로 받습니다.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Maybe</span> a <span class="op">&gt;&gt;=</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="op">&gt;&gt;=</span> b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> c</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  arr a b <span class="op">&gt;&gt;&gt;</span>      arr b c <span class="op">&gt;&gt;&gt;</span>      arr c d</span></code></pre></div>
<p>텍스트에선 스트림(리스트) 인스턴스를 모나드가 표현하지 못하는 방식이라고 합니다.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">SF</span> <span class="kw">where</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  arr f <span class="ot">=</span> <span class="dt">SF</span> (<span class="fu">map</span> f)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SF</span> f <span class="op">&gt;&gt;&gt;</span> <span class="dt">SF</span> g <span class="ot">=</span> <span class="dt">SF</span> (f <span class="op">&gt;&gt;&gt;</span> g)</span></code></pre></div>
<p><code>arr f</code>에서 <code>f</code>가 스트림(리스트)을 받게 할 수 있는데, 모나드는 그러지 못한다고 합니다. 왜?</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> m b  <span class="op">&gt;=&gt;</span>  b <span class="ot">-&gt;</span> m c</span></code></pre></div>
<p>위 체인의 결과는 모나드 <code>m</code>이 표현할 수 있는 것들이 되고, 입력 <code>a</code>는 모나드 <code>m</code>과는 상관 없는 상태입니다.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>arr  a b  <span class="op">&gt;&gt;&gt;</span>  arr  b c</span></code></pre></div>
<p>위 체인의 결과는 <code>arr</code>이 표현할 수 있는 것들이고, 입력도 <code>arr</code>이 표현할 수 있는 것들로 되어 있습니다. 당연히, 모나드는 <code>m</code>을 뭘로 바꾸든 <code>a</code>를 바꿀 수 없지만, <code>arr</code>은 원하는 타입에 맞는 <code>arr</code> 인스턴스를 만들면 됩니다.</p>
<p><code>f :: a -&gt; b</code>란 함수가 있을 때 <code>arr f</code>와 <code>return . f</code>의 차이를 보겠습니다.<br />
<code>arr f = SF (map f)</code>를 하면 <code>SF</code>가 안에 <code>[a] -&gt; [b]</code>를 가진 상태가 됩니다. 입력 <code>a</code>를 <code>[a]</code>로 바꿀 수 있습니다.<br />
하지만 <code>return@[] . f</code>(<code>@[]</code>는 리스트의 인스턴스란 말입니다.)는 <code>a -&gt; [b]</code>가 됩니다. <code>a</code>를 스트림으로 바꾸지 못했습니다.</p>
<p>모나드만으론 <code>a -&gt; b</code> 함수의 입력을 변형variation하는 작업은 할 수 없습니다.</p>
<p>설명은 이해한 듯 한데, 이로 인해 얻는 이점은 사용해 봐야 알 것 같습니다.</p>
<h2 id="체이닝-되어-있는-함수-각-각의-결과에-접근">체이닝 되어 있는 함수 각 각의 결과에 접근</h2>
<p>다음 절차형 코드와 같이 <strong>각 함수의 결과에 개별 접근 작업</strong>을 순수 함수로 하려면 어떻게 할까요?</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>init <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> add1 init</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> add2 init</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> a <span class="op">+</span> b</span></code></pre></div>
<p>마지막에 <code>add1</code>함수의 결과와 <code>add2</code>함수의 결과에 각 각 접근하고 있습니다. 그냥 <code>(+2).(+1)</code>같이 합성하면, 각 각의 결과에 접근할 수 없습니다. 이럴 때 모나드 구조를 이용해 다음처럼 해결할 수 있습니다.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>add1 <span class="ot">=</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>add2 <span class="ot">=</span> (<span class="op">+</span><span class="dv">2</span>)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>comp <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> add1 </span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> add2 </span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> a <span class="op">+</span> b</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> comp <span class="dv">0</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span></code></pre></div>
<p>Arrow로 하려면 <code>arr</code>과 <code>(&gt;&gt;&gt;)</code>만으론 할 수 없습니다.</p>
<h2 id="튜플순서쌍">2-튜플(순서쌍)</h2>
<p>일단 함수 두 개의 경우만 보겠습니다. <strong>두 함수를 실행해서 두 함수의 결과를 모두 가지고 있어야 합니다.</strong> 두 개의 정보를 묶는데 가장 단순한 구조인 2-튜플(순서쌍)을 떠올릴 수 있습니다. 지금부터는 2-튜플이라 안 쓰고, 그냥 튜플이라 쓰겠습니다.</p>
<h3 id="section-4">(&amp;&amp;&amp;)</h3>
<p>두 개의 함수를 받아서 가지고 있다가, 인자를 넣어 주면 각 함수에 인자를 넣어 주고, 각 실행 후 결과를 튜플로 묶으면 됩니다.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&amp;&amp;&amp;</span> g <span class="ot">=</span> \x <span class="ot">-&gt;</span> (f x, g x)</span></code></pre></div>
<p>위 예시처럼 두 값을 더하려면, 인자 두 개를 받는 <code>(+)</code>를, 인자를 튜플로 묶어서 받도록 <code>uncurry</code>해서 이어 주면 됩니다.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&amp;&amp;&amp;</span> g <span class="op">&gt;&gt;&gt;</span> <span class="fu">uncurry</span> (<span class="op">+</span>)</span></code></pre></div>
<p>텍스트에선 여기서부터 기능을 단계별로 <strong>해부</strong>(기능을 잘게 쪼개기)하는데, 컴비네이터를 설계하는 예시를 볼 수 있는 기회이기도 합니다.</p>
<h3 id="section-5">(***)</h3>
<p><code>&amp;&amp;&amp;</code>보다 좀 더 프리미티브한 조각이 되도록 <code>f</code>와 <code>g</code>의 조합이 각 함수가 필요한 인자를 튜플로 받게 할 수 있습니다. (그럼, 나중에 같은 인자를 <code>f</code>와 <code>g</code>에 넣어주는 게 아니라, 다른 값을 넣어 주는 곳에서도 쓸 수 있습니다.)</p>
<ol type="1">
<li>인자 하나를 받으면, 인자를 복사해서 튜플로 만들고,</li>
<li><code>f</code>와 <code>g</code>를 조합해서 튜플을 받으면,</li>
<li>첫 번째 원소는 <code>f</code>에, 두 번째 원소는 <code>g</code>에 넣어주고, 결과값을 모아 다시 튜플로 만든다.</li>
</ol>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&amp;&amp;&amp;</span> g <span class="ot">=</span> arr (\x <span class="ot">-&gt;</span> (x,x)) <span class="op">&gt;&gt;&gt;</span> f <span class="op">***</span> g</span></code></pre></div>
<p><code>&amp;&amp;&amp;</code>에서 인자를 하나 복사해서 튜플로 만들던 기능을 빼냈습니다.<br />
여기서 좀 더 해부를 합니다. 3번, 튜플의 각 각의 원소에 함수를 적용하던 것을 둘로 나눌 수 있습니다.
1. 첫 번째 원소에 <code>f</code> 적용
1. 두 번째 원소에 <code>g</code> 적용</p>
<h3 id="first-1">first</h3>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- (-&gt;)의 인스턴스를 예로 보면</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>first f (a, c) <span class="ot">=</span> (f a, c)</span></code></pre></div>
<p><code>***</code>로 <code>first</code>을 표현한다면,</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>first f <span class="ot">=</span> f <span class="op">***</span> arr <span class="fu">id</span> </span></code></pre></div>
<p>거꾸로 <code>first</code>를 프리미티브하게 잡으면, <code>***</code>는 첫 번째 적용과, 두 번째 원소에 적용이 필요하니</p>
<h3 id="second-1">second</h3>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- second f (a, c) = (a, f c) 로 해도 되지만, 프리미티브를 많이 만들지 않기 위해</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>second f <span class="ot">=</span> arr swap <span class="op">&gt;&gt;&gt;</span> first f <span class="op">&gt;&gt;&gt;</span> arr swap</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> swap (x, y) <span class="ot">=</span> (y, x)</span></code></pre></div>
<p>이렇게 정의하고 나면</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">***</span> g <span class="ot">=</span> first f <span class="op">&gt;&gt;&gt;</span> second g</span></code></pre></div>
<p>덤으로 실행 순서도 잘 보이는 모양이 됐습니다. 텍스트에선 여기서 바로 모나드 구조를 대신하는 모습을 보여 주지 않고, 조건에 따라 실행하는 컴비네이터를 정의합니다.</p>
<h3 id="ifte">ifte</h3>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> (x <span class="ot">=</span> <span class="dv">1</span>) <span class="kw">then</span> f <span class="kw">else</span> g </span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="co">--    p         </span></span></code></pre></div>
<p><code>p</code>의 결과에 따라 <code>f</code> 또는 <code>g</code>를 선택합니다. 우선 두 부분으로 나누어,
1. <code>p</code>가 <code>True</code>인지 <code>False</code>인지 보는 부분
1. <code>f</code>와 <code>g</code> 중 선택
으로 나눌 수 있습니다. 1번 부터 표현하면,</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">&amp;&amp;&amp;</span> arr <span class="fu">id</span></span></code></pre></div>
<p><code>f &amp;&amp;&amp; g</code>는 <code>f</code>와 <code>g</code>를 묶어, 하나의 인자를 각 함수에 넣어서 실행 후 튜플을 내뱉는 함수로 바꿔 줍니다.<br />
<code>p :: x -&gt; Bool</code> 와 <code>id :: x -&gt; x</code> 둘을 묶으면, <code>(Bool, 입력값 x)</code> 결과를 뱉는 함수가 됩니다. 여기엔 <code>Bool</code>값과 입력값 두 개의 정보가 고스란히 담겨 있습니다. 이를 첫 번째 <code>Bool</code>에 따라 함수를 선택해서 <code>입력값 x</code>를 넣어주도록 만들면 됩니다.</p>
<h3 id="section-6">(|||)</h3>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">&amp;&amp;&amp;</span> arr <span class="fu">id</span> <span class="op">&gt;&gt;&gt;</span> f <span class="op">|||</span> g</span></code></pre></div>
<p><code>|||</code>는 받은 튜플의 첫 번째를 보고, <code>f</code> 또는 <code>g</code>를 고르는 함수입니다. 지금은 <code>f</code>와 <code>g</code>가 같은 인자를 받는 모양입니다. 좀 더 일반적으로 만들어 보겠습니다. <code>p</code>의 결과는 <code>(True, x)</code> 아니면 <code>(False, x)</code>입니다. 두 가지 옵션만 있는 타입이니 <code>Either</code>를 써서 <code>(True, x)</code>를 <code>Left x</code>, <code>(False, x)</code>를 <code>Right x</code>로 표현할 수 있습니다.</p>
<p><code>|||</code>는 <code>Either</code> 타입을 받아서 <code>f</code> 또는 <code>g</code>를 고르면 되는데, <code>Either</code>를 썼기 때문에 <code>f</code>와 <code>g</code>가 받는 인자 타입을 달리할 수 있게 됩니다.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(|||) ::</span> arr a c <span class="ot">-&gt;</span> arr b c <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a b) c</span></code></pre></div>
<p>그런데 여기서 <code>arr</code>에 있는 인자를 뒤집고, <code>Either</code>를 튜플로 바꾸면</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&amp;&amp;&amp;) ::</span> arr c a <span class="ot">-&gt;</span> arr c b <span class="ot">-&gt;</span> arr c (a, b)</span></code></pre></div>
<p>바로 <code>&amp;&amp;&amp;</code>와 같습니다. 텍스트에선 <code>|||</code>와 <code>&amp;&amp;&amp;</code>가 <strong>듀얼</strong> 관계에 있다고 말합니다. 이 게 어떤 인사이트를 주는 결과인 것 같은데, 어떤 인사이트인지는 특별히 설명하지 않고 있습니다. 흐름이 분기되는 <code>|||</code>과 병렬 흐름을 만드는 <code>&amp;&amp;&amp;</code>입니다. <code>AND</code>와 <code>OR</code>이 듀얼이고, 튜플과 <code>Either</code>가 듀얼입니다.</p>
<p>조건부 분기Conditionals의 예시로, <code>mapA</code>를 들고 있습니다. 왜 매핑에 조건부 표현이 필요할까라고 생각할 수 있는데, 매핑은 엣지 조건이냐 아니냐를 구분해서 동작합니다.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>listcase [] <span class="ot">=</span> <span class="dt">Left</span> () <span class="co">-- 엣지 조건</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>listcase (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Right</span> (x, xs)</span></code></pre></div>
<p>로 볼 수 있습니다. 이를 써서 Arrow로 <code>mapA</code>를 표현하면,</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>mapA f <span class="ot">=</span> arr listcase <span class="op">&gt;&gt;&gt;</span>  <span class="co">-- 엣지 조건 검사를 Either로 바꿔 아래 |||로 만든 컴비네이션에 넘긴다.</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>         arr (<span class="fu">const</span> []) <span class="op">|||</span> (f <span class="op">***</span> mapA f <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="op">:</span>)))</span></code></pre></div>
<p><code>[1,2]</code>에 <code>let f = (+10)</code>을 적용하는 걸 <code>mapA</code>로 작성해 보겠습니다. 엣지 조건 말고, 재귀 되는 부분을 살펴 보겠습니다.
<code>(f *** mapA f &gt;&gt;&gt; arr (uncurry (:)))</code>는 <code>(x, xs)</code>를 받습니다.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>((<span class="op">+</span><span class="dv">10</span>) <span class="dv">1</span>, mapA (<span class="op">+</span><span class="dv">10</span>) [<span class="dv">2</span>]) <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="op">:</span>))</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span><span class="dv">10</span>) <span class="dv">1</span> <span class="op">:</span> mapA (<span class="op">+</span><span class="dv">10</span>) [<span class="dv">2</span>]</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span><span class="dv">10</span>) <span class="dv">1</span> <span class="op">:</span> ((<span class="op">+</span><span class="dv">10</span>) <span class="dv">2</span>, []) <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="op">:</span>))</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span><span class="dv">10</span>) <span class="dv">1</span> <span class="op">:</span> (<span class="op">+</span><span class="dv">10</span>) <span class="dv">2</span> <span class="op">:</span> []</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="dv">11</span> <span class="op">:</span> <span class="dv">12</span> <span class="op">:</span> []</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">11</span>, <span class="dv">12</span>]</span></code></pre></div>
<h3 id="section-7">(+++)</h3>
<p><code>(&amp;&amp;&amp;)</code>에서 <strong>인자를 튜플로 만드는 작업</strong>을 빼내고 <code>(***)</code>를 정의한 것처럼,<br />
<code>(|||)</code>에서 <strong>Either값을 단일 값으로 바꾸는 작업</strong>을 빼낼 수 있습니다.</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">|||</span> g <span class="ot">=</span> f <span class="op">+++</span> g <span class="op">&gt;&gt;&gt;</span> arr join</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> join (<span class="dt">Left</span> b)  <span class="ot">=</span> b</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>        join (<span class="dt">Right</span> b) <span class="ot">=</span> b</span></code></pre></div>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(+++) ::</span> arr a b <span class="ot">-&gt;</span> arr c d <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a c) (<span class="dt">Either</span> b d)</span></code></pre></div>
<p><code>(***)</code>을 <code>first</code>, <code>second</code>로 쪼갰듯이, <code>(+++)</code>도 쪼갤 수 있습니다. <code>first</code>는 함수<code>(-&gt;)</code> 인스턴스를 보면 <code>a -&gt; b</code>인 함수를 <code>(a, c) -&gt; (b, c)</code>로 만들고, <code>second</code>는 <code>(c, a) -&gt; (c, b)</code>로 만드는 컴비네이터였습니다. <code>first</code>와 비슷하게</p>
<h3 id="left-1">left</h3>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="ot">left ::</span> arr a b <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a c) (<span class="dt">Either</span> b c)</span></code></pre></div>
<p>를 정의하고, <code>second</code>를 <code>first</code>와 <code>swap</code>으로 정의했던 것과 비슷하게</p>
<h3 id="right-1">right</h3>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>right f <span class="ot">=</span> arr mirror <span class="op">&gt;&gt;&gt;</span> left f <span class="op">&gt;&gt;&gt;</span> arr mirror</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> mirror (<span class="dt">Left</span> a) <span class="ot">=</span> <span class="dt">Right</span> a</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>        mirror (<span class="dt">Right</span> a) <span class="ot">=</span> <span class="dt">Left</span> a</span></code></pre></div>
<p>를 정의하면 다음처럼 써 줄 수 있습니다.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">+++</span> g <span class="ot">=</span> left f <span class="op">&gt;&gt;&gt;</span> right g</span></code></pre></div>
<p>그럴 거라 예측은 가지만, 자세한 동작이 금방 눈에 보이지 않습니다. 말로 풀면 쉽게 이해가 갑니다.<br />
<code>left</code>는 Arrow를 <code>Left</code>값일 때만 반응하게 만들고,<br />
<code>right</code>는 Arrow를 <code>Right</code>에만 반응하게 만듭니다.</p>
<p>스트림 인스턴스의 예시를 보겠습니다.</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>dalay x <span class="ot">=</span> <span class="dt">SF</span> (<span class="fu">init</span> <span class="op">.</span> (x<span class="op">:</span>)) <span class="co">-- init은 끝 원소 제거</span></span></code></pre></div>
<pre><code>&gt; runSF (mapA (delay 0)) [[1,2,3],[4,5,6],[7,8,9]]
[[0,0,0],[1,2,3],[4,5,6]]</code></pre>
<h3 id="sf-인스턴스-동작">SF 인스턴스 동작</h3>
<p>왜 <code>[[0,1,2],[0,4,5],[0,7,8]]</code>이 아니라 위와 같은 결과가 나올까요?</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>mapA f <span class="ot">=</span> arr listcase <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>         arr (<span class="fu">const</span> []) <span class="op">|||</span> (f <span class="op">***</span> mapA f <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="op">:</span>)))</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>         <span class="co">--------------     ------------------------------------</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>               g'                             h'</span></code></pre></div>
<p><code>(delay 0) [1,2,3] : mapA (delay 0) ...</code>으로 해석되는 게 아닌 걸까요? 그리 간단하지 않습니다.<br />
<code>f *** mapA f = (\(xs,yss) -&gt; ((init .(0:)) xs, mapA (delay 0) yss))</code>에 <code>&gt;&gt;&gt; arr (uncurry (:))</code>를 이어 붙이면, 얼핏 보면 엣지 조건으로 수렴하지 않는 모양으로 보일 수 있습니다. 놓친 게 있습니다. <code>listcase (z:zs)</code>를 <code>Right (z, zs)</code>로 첫 원소를 떼어 내면서 이미 엣지 조건을 향해가는 작업을 합니다.(혼동하지 않도록 <code>z</code>, <code>zs</code>로 바인드명만 바꿨습니다.)<br />
</p>
<p>단순화 하기 위해 <code>[[1,2]]</code>를 넣어 보겠습니다.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>g' <span class="op">|||</span> h' <span class="ot">=</span> left g' <span class="op">&gt;&gt;&gt;</span> right h' <span class="op">&gt;&gt;&gt;</span> arr join</span></code></pre></div>
<p><code>[Right (1, [2])]</code>가 들어 왔으니, <code>h'</code>만 반응합니다. <code>h'</code>에 <code>(1,[2])</code>을 그냥 적용하는 것이 아니라, <code>right</code>로 <code>[Right (1,[2])]</code>을 <code>h'</code>에 넣어 주게 됩니다. <code>h'</code>은 튜플을 받고 리스트로 내보내는 함수입니다.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> runSF (right (delay <span class="dv">0</span>)) [<span class="dt">Left</span> <span class="dv">1</span>, <span class="dt">Right</span> <span class="dv">1</span>]</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>[<span class="dt">Left</span> <span class="dv">1</span>, <span class="dt">Right</span> <span class="dv">0</span>]</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> runSF ( (delay <span class="dv">0</span>) <span class="op">***</span> mapA (delay <span class="dv">0</span>) ) [(<span class="dv">1</span>,[<span class="dv">2</span>]), (<span class="dv">3</span>,[<span class="dv">4</span>])]</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">0</span>,[<span class="dv">0</span>]), (<span class="dv">1</span>,[<span class="dv">2</span>])]</span></code></pre></div>
<p><code>delay 0 = SF (init . (0:))</code>으로 리스트를 받아야만 할 것 같은데, 튜플이 먼저 들어와서 타입 불일치가 일어날 것만 같이 보입니다. <code>***</code>이 <strong>튜플을 해체해서 각 각의 리스트</strong>로 만들어 준다면 말이 될 것처럼 보입니다. <code>SF</code>의 <code>first</code> 정의는 역시나 <code>unzip</code>을 포함한 <code>SF (unzip &gt;&gt;&gt; first f &gt;&gt;&gt; uncurry zip)</code>입니다.</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">unzip</span> [(<span class="dv">1</span>,[<span class="dv">2</span>]),(<span class="dv">3</span>,[<span class="dv">4</span>])]</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>([<span class="dv">1</span>,<span class="dv">3</span>], [[<span class="dv">2</span>],[<span class="dv">4</span>]])</span></code></pre></div>
<p>이제 눈에 보입니다. <code>h' = \(xs, ys) -&gt; (f xs : mapA f ys)</code>을 적용하기 전에 <code>unzip</code>이 포함된 <code>***</code>을 거치니 <code>([1],[[2]])</code>에 <code>h'</code>을 적용하면, <code>(0,[0])</code>를 <code>uncurry (:)</code>한 것들의 리스트, 즉 <code>[[0,0]]</code>이 나옵니다.</p>
<p>한참 헤맸는데, 결국은 각 인스턴스들의 구현을 대충 봐서 생긴 오해였습니다. 아래 코드를 GHCi에서 불러 와서 테스트해 보세요.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="kw">where</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  arr ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> arr a b</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;&gt;) ::</span> arr a b <span class="ot">-&gt;</span> arr b c <span class="ot">-&gt;</span> arr a c</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  first ::</span> arr a b <span class="ot">-&gt;</span> arr (a,c) (b,c)</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&amp;&amp;&amp;) ::</span> arr a b <span class="ot">-&gt;</span> arr a c <span class="ot">-&gt;</span> arr a (b, c)</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>  f <span class="op">&amp;&amp;&amp;</span> g <span class="ot">=</span> arr (\x <span class="ot">-&gt;</span> (x,x)) <span class="op">&gt;&gt;&gt;</span> (f <span class="op">***</span> g)</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  second ::</span> arr a b <span class="ot">-&gt;</span> arr (c,a) (c,b)</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>  second f <span class="ot">=</span> arr swap <span class="op">&gt;&gt;&gt;</span> first f <span class="op">&gt;&gt;&gt;</span> arr swap</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> swap (x,y) <span class="ot">=</span> (y,x)</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  (***) ::</span> arr a b <span class="ot">-&gt;</span> arr c d <span class="ot">-&gt;</span> arr (a,c) (b,d)</span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>  f <span class="op">***</span> g <span class="ot">=</span> first f <span class="op">&gt;&gt;&gt;</span> second g</span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> <span class="dt">ArrowChoice</span> arr <span class="kw">where</span></span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a><span class="ot">  (|||) ::</span> arr a c <span class="ot">-&gt;</span> arr b c <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a b) c</span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a>  f <span class="op">|||</span> g <span class="ot">=</span> f <span class="op">+++</span> g <span class="op">&gt;&gt;&gt;</span> arr join</span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> join (<span class="dt">Left</span> b) <span class="ot">=</span> b</span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a>          join (<span class="dt">Right</span> b) <span class="ot">=</span> b</span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-21"><a href="#cb84-21" aria-hidden="true" tabindex="-1"></a><span class="ot">  left ::</span> arr a b <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a c) (<span class="dt">Either</span> b c)</span>
<span id="cb84-22"><a href="#cb84-22" aria-hidden="true" tabindex="-1"></a><span class="ot">  right ::</span> arr a b <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> c a) (<span class="dt">Either</span> c b)</span>
<span id="cb84-23"><a href="#cb84-23" aria-hidden="true" tabindex="-1"></a>  right f <span class="ot">=</span> arr mirror <span class="op">&gt;&gt;&gt;</span> left f <span class="op">&gt;&gt;&gt;</span> arr mirror</span>
<span id="cb84-24"><a href="#cb84-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> mirror (<span class="dt">Left</span> a) <span class="ot">=</span> <span class="dt">Right</span> a</span>
<span id="cb84-25"><a href="#cb84-25" aria-hidden="true" tabindex="-1"></a>          mirror (<span class="dt">Right</span> a) <span class="ot">=</span> <span class="dt">Left</span> a</span>
<span id="cb84-26"><a href="#cb84-26" aria-hidden="true" tabindex="-1"></a><span class="ot">  (+++) ::</span> arr a b <span class="ot">-&gt;</span> arr c d <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a c) (<span class="dt">Either</span> b d) </span>
<span id="cb84-27"><a href="#cb84-27" aria-hidden="true" tabindex="-1"></a>  f <span class="op">+++</span> g <span class="ot">=</span> left f <span class="op">&gt;&gt;&gt;</span> right g</span>
<span id="cb84-28"><a href="#cb84-28" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb84-29"><a href="#cb84-29" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb84-30"><a href="#cb84-30" aria-hidden="true" tabindex="-1"></a>  arr <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb84-31"><a href="#cb84-31" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&gt;&gt;&gt;</span>) <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">.</span>)</span>
<span id="cb84-32"><a href="#cb84-32" aria-hidden="true" tabindex="-1"></a>  (f <span class="op">&amp;&amp;&amp;</span> g) a <span class="ot">=</span> (f a, g a)</span>
<span id="cb84-33"><a href="#cb84-33" aria-hidden="true" tabindex="-1"></a>  first f (a,c) <span class="ot">=</span>  (f a,c) </span>
<span id="cb84-34"><a href="#cb84-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-35"><a href="#cb84-35" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">SF</span> a b <span class="ot">=</span> <span class="dt">SF</span> {<span class="ot"> runSF ::</span> [a] <span class="ot">-&gt;</span> [b] }</span>
<span id="cb84-36"><a href="#cb84-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-37"><a href="#cb84-37" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">SF</span> <span class="kw">where</span></span>
<span id="cb84-38"><a href="#cb84-38" aria-hidden="true" tabindex="-1"></a>  arr f <span class="ot">=</span> <span class="dt">SF</span> (<span class="fu">map</span> f)</span>
<span id="cb84-39"><a href="#cb84-39" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SF</span> f <span class="op">&gt;&gt;&gt;</span> <span class="dt">SF</span> g <span class="ot">=</span> <span class="dt">SF</span> (f <span class="op">&gt;&gt;&gt;</span> g)</span>
<span id="cb84-40"><a href="#cb84-40" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SF</span> f <span class="op">&amp;&amp;&amp;</span> <span class="dt">SF</span> g <span class="ot">=</span> <span class="dt">SF</span> (f <span class="op">&amp;&amp;&amp;</span> g <span class="op">&gt;&gt;&gt;</span> <span class="fu">uncurry</span> <span class="fu">zip</span>)</span>
<span id="cb84-41"><a href="#cb84-41" aria-hidden="true" tabindex="-1"></a>  first (<span class="dt">SF</span> f) <span class="ot">=</span> <span class="dt">SF</span> (<span class="fu">unzip</span> <span class="op">&gt;&gt;&gt;</span> first f <span class="op">&gt;&gt;&gt;</span> <span class="fu">uncurry</span> <span class="fu">zip</span>)</span>
<span id="cb84-42"><a href="#cb84-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-43"><a href="#cb84-43" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ArrowChoice</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb84-44"><a href="#cb84-44" aria-hidden="true" tabindex="-1"></a>  left f (<span class="dt">Left</span> a) <span class="ot">=</span> <span class="dt">Left</span> (f a)</span>
<span id="cb84-45"><a href="#cb84-45" aria-hidden="true" tabindex="-1"></a>  left f (<span class="dt">Right</span> b) <span class="ot">=</span> <span class="dt">Right</span> b</span>
<span id="cb84-46"><a href="#cb84-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-47"><a href="#cb84-47" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ArrowChoice</span> <span class="dt">SF</span> <span class="kw">where</span></span>
<span id="cb84-48"><a href="#cb84-48" aria-hidden="true" tabindex="-1"></a>  left (<span class="dt">SF</span> f) <span class="ot">=</span> <span class="dt">SF</span> (\xs <span class="ot">-&gt;</span> combine xs (f [y <span class="op">|</span> <span class="dt">Left</span> y <span class="ot">&lt;-</span> xs]))</span>
<span id="cb84-49"><a href="#cb84-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-50"><a href="#cb84-50" aria-hidden="true" tabindex="-1"></a><span class="co">-- 주의: Left (y:xs) 가 아니라, 첫 원소가 Left y</span></span>
<span id="cb84-51"><a href="#cb84-51" aria-hidden="true" tabindex="-1"></a>combine (<span class="dt">Left</span> y<span class="op">:</span>xs) (z<span class="op">:</span>zs) <span class="ot">=</span> <span class="dt">Left</span> z<span class="op">:</span> combine xs zs</span>
<span id="cb84-52"><a href="#cb84-52" aria-hidden="true" tabindex="-1"></a>combine (<span class="dt">Right</span> y<span class="op">:</span>xs) zs <span class="ot">=</span> <span class="dt">Right</span> y<span class="op">:</span> combine xs zs</span>
<span id="cb84-53"><a href="#cb84-53" aria-hidden="true" tabindex="-1"></a>combine [] zs <span class="ot">=</span> []</span>
<span id="cb84-54"><a href="#cb84-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-55"><a href="#cb84-55" aria-hidden="true" tabindex="-1"></a><span class="ot">listcase ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Either</span> () (a,[a])</span>
<span id="cb84-56"><a href="#cb84-56" aria-hidden="true" tabindex="-1"></a>listcase [] <span class="ot">=</span> <span class="dt">Left</span> ()</span>
<span id="cb84-57"><a href="#cb84-57" aria-hidden="true" tabindex="-1"></a>listcase (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Right</span> (x, xs)</span>
<span id="cb84-58"><a href="#cb84-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-59"><a href="#cb84-59" aria-hidden="true" tabindex="-1"></a>mapA f <span class="ot">=</span> arr listcase <span class="op">&gt;&gt;&gt;</span> </span>
<span id="cb84-60"><a href="#cb84-60" aria-hidden="true" tabindex="-1"></a>         (arr (<span class="fu">const</span> []) <span class="op">|||</span> (f <span class="op">***</span> mapA f <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="op">:</span>))))</span>
<span id="cb84-61"><a href="#cb84-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-62"><a href="#cb84-62" aria-hidden="true" tabindex="-1"></a>delay x <span class="ot">=</span> <span class="dt">SF</span> (<span class="fu">init</span> <span class="op">.</span> (x<span class="op">:</span>))</span></code></pre></div>
<h2 id="고차-arrow">고차 Arrow</h2>
<p>다른 Arrow를 입력으로 받는 Arrow를, 위에서 언급한 컴비네이터들만으론 만들 수 없다고 합니다.<br />
Q. 왜 그럴까요? 그냥 <code>arr (arr a, b) c</code> 라는 Arrow가 있을 수 없다는 말일까요?<br />
Arrow가 되려면, 최소한 <code>arr</code>과 <code>first</code>를 만들 수 있어야 합니다.</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> cat <span class="kw">where</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  id ::</span> cat a a</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (.) ::</span> cat b c <span class="ot">-&gt;</span> cat a b <span class="ot">-&gt;</span> cat a c</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> arr <span class="ot">=&gt;</span> <span class="dt">Arrow</span> arr <span class="kw">where</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  arr ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> arr a b</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  first ::</span> a b c <span class="ot">-&gt;</span> a (b,d) (c,d)</span></code></pre></div>
<p><code>arr</code>메소드는 <code>(a -&gt; b)</code>를 <code>((arr a' a) -&gt; b)</code>쯤 될 것 같고,<br />
<code>first</code>메소드는 <code>a (a b' c') c -&gt; a ((a b' c'), d) (c,d)</code>쯤 될텐데,<br />
이들이 프리미티브한 요소들인데, 이들을 정의할 수 없다는 얘기일까요?</p>
<p>지금은 답을 먼저 알고 있으니, 답에서 들어가 보겠습니다. <code>app</code>이 어떤식으로 쓰이는지를 보면 보일지도 모릅니다.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span>  <span class="dt">ArrowApply</span> arr <span class="kw">where</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  app ::</span> arr (arr a b, a) b</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ArrowApply</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>  app (f, x) <span class="ot">=</span> f x</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ArrowApply</span> (<span class="dt">Kleisli</span> m) <span class="kw">where</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>  app <span class="ot">=</span> <span class="dt">Kleisli</span> (\(<span class="dt">Kleisli</span> f, x) <span class="ot">-&gt;</span> f x)</span></code></pre></div>
<p><code>app</code>정의의 안 쪽을 보면 <code>arr a b</code>와 <code>a</code>를 가지고 있습니다.</p>
<p><code>app</code>을 가지고 있는 Arrow는 모나드로 동작할 수 있습니다.</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ArrowMonad</span> arr a <span class="ot">=</span> <span class="dt">ArrowMonad</span> (arr () a)</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ArrowApply</span> a <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ArrowMonad</span> a) <span class="kw">where</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> x <span class="ot">=</span> <span class="dt">ArrowMonad</span> (arr (<span class="fu">const</span> x))</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ArrowMonad</span> m <span class="op">&gt;&gt;=</span> f <span class="ot">=</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ArrowMonad</span> (    m </span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>                <span class="op">&gt;&gt;&gt;</span> arr (\x <span class="ot">-&gt;</span> <span class="kw">let</span> <span class="dt">ArrowMonad</span> h <span class="ot">=</span> f x <span class="kw">in</span> (h, ()))</span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a>                <span class="op">&gt;&gt;&gt;</span> app)</span></code></pre></div>
<p><code>app</code>은 그저, <code>(함수, 인자)</code>를 받아 적용시켜주는 uncurry된 <code>$</code>처럼 보입니다. 이런 함수가 뭐 그리 대단한 일을 해낼까요?</p>
<p>Arrow를 <code>ArrowMonad</code>로 감싸고, <code>ArrowMonad</code>를 모나드 인스턴스로 만들고 있습니다. 아무 Arrow나 다 되는 건 아니고, <code>ArrowApply</code> 인스턴스인 경우만 됩니다. 바인드<code>&gt;&gt;=</code>는 이펙트를 <code>join</code>하는 동작이 있어야 합니다. <code>ArrowMonad</code>의 이펙트는 무엇이고, 어떤 모양으로 <code>join</code> 동작을 하고 있을까요? 텍스트에는 따로 언급이 없어 직접 찾아 봤습니다.</p>
<blockquote>
<p><strong>Maybe 모나드의 바인드에서 이펙트 찾기</strong><br />
펑터는, 실무에서 코드로 보면, <code>a</code>까지 도달하는데 반드시 실행해야 되는 절차를 <code>fmap</code>으로 구현한 구조를 말합니다. (좀 더 정화히는 pure도 있고, 펑터 법칙도 따라야 합니다만) 예를 들어,<br />
<code>Just (Just a)</code><br />
이러면, <code>a</code>에 도달할 때까지 <code>Nothing</code>인지 검사해서 하나를 통과하고, 또 <code>Nothing</code>인지 검사해서 <code>a</code>에 도달하게 됩니다. 더 나아가서 <code>Just 1</code>과 <code>Just (Just 1)</code>이 의미적으로 차이가 없다고 “결정”하고, <code>Just (Just 1)</code>은 <code>Just 1</code>로, <code>Just Nothing</code>은 <code>Nothing</code>으로 <code>join</code>하는 동작을 가지도록 한 구조를 <code>Maybe</code> 모나드라 합니다.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Just</span> x) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f x</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span> <span class="op">&gt;&gt;=</span> _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>“<code>Just</code>일 경우만 <code>f</code>를 적용하고, <code>Nothing</code>일 때는 적용하지 않는다”는 이펙트만 “함수 패턴 매칭Function Pattern Matching”으로 나타나고, <code>join</code>은 잘 안보입니다. <code>f</code>는 결과가 <code>Just</code>로, <code>Just x</code>에 적용하면 <code>Just (Just f x)</code>가 될텐데, <code>(Just x) &gt;&gt;= f</code>에서 <code>Just x</code> 패턴 매칭으로 <code>Just</code> 하나를 없애고 있습니다. ※ “값 생성자 패턴 매칭Constructor Pattern”이라 부르고, 해체Deconstructor, 구조 분해Destructuring라 부르기도 합니다. <code>x</code>는 <code>Just</code>안에 있는 값과 바인딩됩니다.</p>
</blockquote>
<p><code>ArrowMonad (arr () a)</code>에서 <code>a</code>에 도달하려면 어떤 작업을 해야 할까요? 입력으로 <code>()</code>를 받아 <code>a</code>를 돌려주는 함수를 가지고 있으니, 여기에 <code>()</code>를 줘서 <code>a</code>를 얻은 후 <code>f</code>를 적용합니다. 그러면,<br />
<code>ArrowMonad (arr () (ArrowMonad (arr () a)))</code><br />
상태가 됩니다. 깊숙히 안에 있는 <code>a</code>에 도달하기 위해 어떤 절차를 거쳐야 할까요?</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>                    m</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>                <span class="op">&gt;&gt;&gt;</span> arr (\x <span class="ot">-&gt;</span> <span class="kw">let</span> <span class="dt">ArrowMonad</span> h <span class="ot">=</span> f x <span class="kw">in</span> (h, ()))</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>                <span class="op">&gt;&gt;&gt;</span> app)</span></code></pre></div>
<p>위 체인의 결과가 <code>() -&gt; ArrowMonad (arr () a)</code>인데, 바깥에서 <code>ArrowMonad</code> 값 생성자가 한 번 더 적용되도록 되어 있습니다. 내부 Arrow가 가진 함수 <code>() -&gt; a</code>는 <code>Reader env</code>와 비슷하고, 입력 값이 <code>()</code>로 고정되어 있습니다. 두 번째 Arrow를 보면 <code>(h, ())</code> 튜플을 반환합니다. 왜 바로 <code>h ()</code>로 <code>a</code>를 만들지 않고 튜플로 반환할까요? <code>h</code>는 Arrow입니다. 바로 <code>()</code>에 적용할 수 없습니다.</p>
<blockquote>
<p>비슷하게 생긴 Reader 모나드 바인드 구현입니다.</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Reader</span> r a <span class="ot">=</span> <span class="dt">Reader</span> {<span class="ot"> runReader ::</span> r <span class="ot">-&gt;</span> a }</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Reader</span> ra) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Reader</span> <span class="op">$</span> \r <span class="ot">-&gt;</span> runReader (f (ra r)) r</span></code></pre></div>
</blockquote>
<p>함수 형태 <code>_ -&gt; a</code>에서 <code>a</code>에 도달하기 위해선, 적용apply 동작이 반드시 필요함을 알 수 있습니다. 나중에 runArrow 같은 것들을 붙였을 때, 해석되게 하려고 <code>(함수, 인자)</code>를 바깥 Arrow 컨텍스트에 넣어 놓는다고 볼 수 있습니다.</p>
<p>왜 이런 구현을 해 놓았는지는 알겠는데, 써먹기까진 좀 더 훈련이 필요하겠습니다.</p>
<h2 id="maybe-모나드가-하는-일을-arrow로-표현한다면">Maybe 모나드가 하는 일을 Arrow로 표현한다면?</h2>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="ot">safeDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>safeDiv _ <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>safeDiv x y <span class="ot">=</span> <span class="dt">Just</span> (x <span class="ot">`div`</span> y)</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>chain <span class="fu">init</span> <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>  r1 <span class="ot">&lt;-</span> safeDiv <span class="dv">10</span> <span class="fu">init</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a>  safeDiv <span class="dv">4</span> r1</span></code></pre></div>
<div class="sourceCode" id="cb92"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>λ&gt; chain 5</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>Just 2</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>λ&gt; chain 11</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>Nothing</span></code></pre></div>
<p>위와 같은 동작을 하는 Arrow를 만들어 보겠습니다.
1. 나눌 수와 나누는 수를 튜플로 받습니다.<br />
결과는 <code>Left ()</code> 이거나 <code>Right Int</code> 입니다.<br />
<code>(Int, Int) -&gt; Either () Int</code>
1. <code>Just</code>와 <code>Nothing</code>으로 분기해야 하니 <code>ArrowChoice</code> 인스턴스여야 합니다.
1. <code>Just</code>는 <code>Right</code>로, <code>Nothing</code>은 <code>Left</code>에 대응 시킵니다.</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="ot">safeDivA ::</span> <span class="dt">ArrowChoice</span> a <span class="ot">=&gt;</span> a (<span class="dt">Int</span>, <span class="dt">Int</span>) (<span class="dt">Either</span> () <span class="dt">Int</span>)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>safeDivA <span class="ot">=</span> proc (x, y) <span class="ot">-&gt;</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> y <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> returnA <span class="op">-&lt;</span> <span class="dt">Left</span> ()</span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> returnA <span class="op">-&lt;</span> <span class="dt">Right</span> (x <span class="ot">`div`</span> y)</span></code></pre></div>
<p><code>(-&gt;)</code>의 Arrow 인스턴스에 있는 <code>&gt;&gt;&gt;</code>에는 <code>Maybe</code> 모나드처럼 흐름을 끊는 동작은 없습니다. <code>|||</code>를 이용해 <code>Left</code>와 <code>Right</code>에 따라 분기하게끔 합니다.</p>
<p>전체 소스</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE Arrows #-}</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((.), id)</span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a><span class="ot">safeDivA ::</span> <span class="dt">ArrowChoice</span> a <span class="ot">=&gt;</span> a (<span class="dt">Int</span>, <span class="dt">Int</span>) (<span class="dt">Either</span> () <span class="dt">Int</span>)</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>safeDivA <span class="ot">=</span> proc (x, y) <span class="ot">-&gt;</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> y <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> returnA <span class="op">-&lt;</span> <span class="dt">Left</span> ()</span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> returnA <span class="op">-&lt;</span> <span class="dt">Right</span> (x <span class="ot">`div`</span> y)</span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a><span class="ot">bindA ::</span> <span class="dt">ArrowChoice</span> a <span class="ot">=&gt;</span> a (<span class="dt">Int</span>, <span class="dt">Int</span>) (<span class="dt">Either</span> () <span class="dt">Int</span>) <span class="ot">-&gt;</span> a (<span class="dt">Int</span>, <span class="dt">Int</span>) (<span class="dt">Either</span> () <span class="dt">Int</span>) <span class="ot">-&gt;</span><span class="dt">Int</span> <span class="ot">-&gt;</span> a (<span class="dt">Int</span>, <span class="dt">Int</span>) (<span class="dt">Either</span> () <span class="dt">Int</span>)</span>
<span id="cb94-14"><a href="#cb94-14" aria-hidden="true" tabindex="-1"></a>bindA ar1 ar2 z <span class="ot">=</span> proc (x,y) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb94-15"><a href="#cb94-15" aria-hidden="true" tabindex="-1"></a>  r1 <span class="ot">&lt;-</span> ar1 <span class="op">-&lt;</span> (x,y)</span>
<span id="cb94-16"><a href="#cb94-16" aria-hidden="true" tabindex="-1"></a>  arr (\_ <span class="ot">-&gt;</span> <span class="dt">Left</span> ()) <span class="op">|||</span> (arr (\n <span class="ot">-&gt;</span> (z,n)) <span class="op">&gt;&gt;&gt;</span> ar2) <span class="op">-&lt;</span> r1</span></code></pre></div>
<p>이런 경우에는 그다지 쓸모 있어 보이진 않습니다. (제가 잘 못 구현해서 그럴 수도 있습니다.)</p>

<div class="comment">
  <script>
    document.addEventListener('DOMContentLoaded', loadUtterances, { once: true });
  </script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>

  </div>
  <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
  <script>
    tocbot.init({
      tocSelector: '.js-toc',
      contentSelector: '.js-toc-content',
      headingSelector: 'h2, h3',
      hasInnerContainers: true,
    });
  </script>
  <div id="footer">
    © 2025 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
  </div>
</body>

</html>
