<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - Arrow로 함수 컴비네이션</title>

        <meta name="description" content="주로 John hughes 텍스트를 보며 Arrow를 공부하면서 노트한 글입니다." />
        <meta property="og:description" content="주로 John hughes 텍스트를 보며 Arrow를 공부하면서 노트한 글입니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Arrow로 함수 컴비네이션" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-09-14-arrow.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>Arrow로 함수 컴비네이션</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on September 14, 2023
    
</div>

<p>함수형은 여러 개의 함수들을 합성compose해서 프로그램을 만들어 갑니다. <code>Arrow</code>는 타입에 상관없이, 합성하는 인터페이스를 통일하자는 것이니, 함수형의 근간을 이루는 구조, 패턴이 아닌가 싶은데, 실상은 모나드만큼 인기리에 쓰이고 있는 것처럼 보이진 않습니다. (제 기준으론 외모도 모나드의 <code>do</code>만큼 깔끔하게 똑 떨어지진 않습니다.) 이론들이 단 몇 년만에 도입되어 폭발적으로 쓰이거나 그러진 않으니, 아직도 서서히 성장 중인 걸지도 모르겠습니다. FRP 라이브러리나(Yampa), GUI 라이브러리(Fruit)등, 도입한 라이브러리가 꽤 있고, 다른 언어에서도 FRP 구현에선 중요한 역할을 하고 있는 이론인가 봅니다.</p>
<p>공부하면서 계속 원문과 노트를 같이 넣다보니 글이 많이 길어졌습니다. 아마도 보실 분들은 거의 없을텐데요. <code>Arrow</code>를 공부하다 막히는 부분이 있을 때, 다른 관점은 없나 궁금할 때 Ctrl-F로 찾아보면 좋을 듯 합니다.</p>
<p>전체적인 글은 다음 순서로 흘러 갑니다.</p>
<ul>
<li>모나드를 일반화하자.</li>
<li><code>(&gt;&gt;&gt;)</code>, <code>arr</code> 로 모나딕 작업과 아닌 작업을 인터페이스를 같게 만든다.</li>
<li>위 두 개만으론, 바인드처럼 작업하는데 부족함이 있다.</li>
<li><code>first</code> 를 추가한다. 2튜플의 앞에 것에만 작업을 한다는 것만으로 어찌 모나드스러울 수 있을까?</li>
<li>모나드가 할 수 있는 일은 다 할 수있고, 모나드가 못하는 일도 할 수 있다.</li>
</ul>
<p><a href="https://www.cse.chalmers.se/~rjmh/afp-arrows.pdf">Programming with Arrows - John hughes</a><br />
위 텍스트를 읽으면서 가졌던 의문들과 알게된 답을 같이 적었습니다. 늘 그렇듯, 읽는 이가 스스로 감수자가 되어 읽어주셔야 합니다.</p>
<h2 id="생각-스트레칭">생각 스트레칭</h2>
<h3 id="타입이-할-수-있는-일검증-안된-혼자-상상입니다.">타입이 할 수 있는 일(검증 안된 혼자 상상입니다.)</h3>
<p>수학이 강한 분들은, 아래 같은 얘기를 별로 안 좋아하는 경우가 있습니다. 너무 “인문학”스럽게 접근하는 걸로 보이나 봅니다. 전, 논리적으로 딱 맞아 떨어져도, 아래 같은 이해를 하지 못하면 현실을 모델링할 때 써먹질 못합니다. 여하튼, 그다지 환영 받는 얘기는 아니니, 적당히 한 귀로 흘리시면서 보세요.</p>
<p><code>Int</code>, <code>Char</code>같은 프리미티브 타입이 아니라, 프로그래머가 만들어내는 타입들에 관한 얘기입니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Some</span> a <span class="ot">=</span> <span class="dt">Some</span> a</span></code></pre></div>
<p><code>Some</code> 타입같은 것을 볼 때, <code>Some a</code>가 아니라 <code>Some _</code>으로 보는게 편합니다. <code>Some</code>을 벗겨 보기 전엔 안에 뭐가 들어 있을지 알 수 없습니다. 또는 다른 시각에서 보면, <code>a</code>에 접근하려면 반드시 특정 절차가 필요할 경우 <code>Some a</code>로 만들면 됩니다. 죽었다 깨나도 <code>Some</code>을 열어 보기 전에는 <code>a</code>에 도달할 수 없습니다. 제가 눈여겨 보는 속성은, 값에 도달하려면 반드시 거쳐야 하는 <strong><em>한 단계 절차</em></strong> 를 가지고 있다는 것입니다. 타입 생성자로 쌓여 있는 것은, 말 그대로 언젠가 <strong><em>생성construct</em></strong>한다는 동작이 들어가 있습니다.</p>
<p>이런 저런 함수들을 붙여가며 작업을 하게 되는데, 따로 함수를 두지 않고, 타입으로 만들고, 함수로 할 일을 생성자나 메소드로 작성 해 놓으면, 해당 타입에서 값을 뽑아낼 때 마치 반드시 일어날 수 밖에 없는 디폴트 작업을 추가해 놓는 것과 비슷합니다. 또 다른 효과로, 타입으로 가려 두면(감싸 놓으면), 실행을 미루는 효과도 납니다. 나중에 타입을 벗겨내면서 예정했던 동작은 반드시 일어나니, 그 전에 신경쓰면서 잊지 않고 필요한 동작을 빠뜨리지 않았는지 신경 쓸 필요도 없습니다.</p>
<p>코드 조립할 때 단순히 조각들이 만나는 부분들이, 아귀(타입 매칭)가 잘 맞는지 보는 간단한 용도를 넘어, 타입은 볼 수록 여러 능력들을 가지고 있습니다.</p>
<h3 id="타입이-표현력이-좋을까-함수가-표현력이-좋을까">타입이 표현력이 좋을까? 함수가 표현력이 좋을까?</h3>
<p>A가 하는 일을 포함해서 B가 더 많은 일을 할 수 있다면, A보다 B가 표현력이 좋다는 뜻에서 표현력이 좋다라는 문장을 썼습니다.</p>
<p><code>a -&gt; b</code> 와 <code>data SomeType a b = SomeType (a -&gt; b)</code>를 비교하면,<br />
<code>applySome (SomeType f) a = f a</code>라는 함수나 메소드를 준비해 놓으면, <code>a -&gt; b</code>가 할 수 있는 일은 모두 할 수 있으며, 추가로 연계된 메소드를 둘 수도 있고,<br />
<code>specialApplySome (SomeType f) a = 추가 작업 후 f a</code> 등으로 함수를 적용할 때 항상 해야만 하는 일을 심어 둘 수도 있습니다. 이런 의미에서 전 타입이 더 표현력이 좋다 생각합니다.</p>
<p>타입이 함수의 일반화가 아닌가 생각한 적이 있는데요, 텍스트도 그리 말하는 곳이 없고, 가끔 저와 대화를 하는 분들 모두 “일반화”라고까지 말할 순 없다라고들 합니다. 저는 <code>Int</code> 타입이라고 하면 <code>Class DoNothing</code>의 인스턴스이거나, 특별한 메소드를 갖고 있지 않거나, 생성자 자체도 특별한 일을 하진 않는 함수로, <code>Value</code>에 접근 할 때 “아무것도 안하는 함수”를 실행하는 함수의 확장 정도로 보는 경우를 상상해 봤습니다. 그다지 그럴싸한 생각은 아닌가 봅니다. 이런 잡스러운 생각이, Arrow 인터페이스가 왜 모나드 인터페이스보다 표현력이 좋을까를 생각할 때 전 도움이 됐습니다.</p>
<h3 id="함수를-타입으로-감싸서-얻는-이득">함수를 타입으로 감싸서 얻는 이득</h3>
<p>함수를 래핑해서 별도의 인터페이스(컴비네이터)를 만들어 두면 얻을 수 있는, 기능 예시를 보겠습니다.</p>
<p>하스켈은 순수 함수만 있어, 인자로 넘어 오지 않으면 쓰질 못합니다. 전역 변수를 쓸 수 있는 <strong>순수하지 않은 상황</strong>에서, 함수를 합성해서 체인을 만들어 두는데, 각 함수들이 만들어 낸 결과들을 모두 개별로 유지할 필요가 있는 경우를 생각해 보면,</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>globalRes1;</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>globalRes2;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>globalRes3;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>chain init {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  globalRes1 = func1 init </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  globalRes2 = func2 globalRes1</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  globalRes3 = func3 globalRes2</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>another {</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  globalRes1 + globalRes2 + globalRes3  </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>(억지스럽긴 하지만) 대비 되게 보면 이런 식의 코드도 가능하겠지만, 순수 함수만 있는 동네에선 불가능합니다. 순수 함수로만 해결하려면,</p>
<p><strong>“결국, 필요한 정보는 다 가지고 다니는 수밖에 없습니다.”</strong></p>
<p>단, 결과값에만 신경쓸 수 있도록, 추가적인 정보(컨텍스트)를 가지고 다니는 건 눈에 잘 안 보이게 해주는 패턴이 필요합니다. 모나드 바인드에선 람다 함수의 클로저가 이 역할을 합니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>\x <span class="ot">-&gt;</span> \y <span class="ot">-&gt;</span> x <span class="op">+</span> y</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">^^^^^</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>            이 식에서 x를 쓸 수 있어야 편하게 구현할 수 있습니다<span class="op">.</span></span></code></pre></div>
<p>함수를 그냥 합성하지 않고, 합성할 때마다 모나드의 바인드처럼 추가 정보를 잃어버리지 않게 차곡 차곡 챙기려면 어떻게 할까요? 순수 함수만 있는 동네에선 2튜플이 중요한 수단입니다. <code>(결과값, 추가 정보)</code> 형태로 추가 정보를 잃어버리지 않게 넣어 놓는 방법이 있습니다. 2튜플을 쓰지 않는다면, 별도의 프로덕트 타입을 만들어서 해결해도 되는데, 이미 준비되어 있는 가장 단순한 2튜플이 있으니, 이 걸 쓰면 됩니다.</p>
<pre><code>chain init {
  res1 = Arrow1 init
  res2 = Arrow2 res1 (혹은 init)
  return (res1, res2)
}</code></pre>
<p>원래는 <code>res1</code> 하나, <code>res2</code> 하나 이렇게 단일 값을 반환하던 함수를 두 개 묶어서 실행한다면, 두 개의 결과를 언제든 다시 분리할 수 있는 튜플로 <code>(res1, res2)</code> 결과를 반환합니다. 만일, 이 상태에서 또 Arrow를 추가한다면,</p>
<pre><code>chain2 init {
  (res1, res2) = chain1 {
    res1 = Arrow1 init
    res2 = Arrow2 res2
    return (res1, res2)
  }
  res3 = Arrow3 (res2만 뽑아내기)
  return ((res1, res2), res3)
}</code></pre>
<p>또 Arrow를 추가한다면 <code>(((res1, res2), res3), res4)</code> 이렇게 계속 2튜플의 2튜플로 유지한다면, 각 개별 결과에 언제든 접근할 수 있는 “가능성”이 생깁니다. 콕 찝어 “가능성”이라 한 이유는, 이 걸 인간이 계속 관리하면서 쓰기엔 사실 가능성만 있을 뿐, 실용적으로 쓰기는 힘들 겁니다.</p>
<p>그냥 함수와 함수를 <code>(.)</code>으로 합성하지 않고, <code>Arrow</code>로 래핑해서 합성하면, <code>Arrow</code>가 제공하는 컴비네이터들을 이용해 이 2튜플들을 프로그래머가 신경쓰지 않아도, 알아서 안보이게 잘 가지고 다니게 할 수 있습니다. Arrow의 컴비네이터 내부에서는 합성하려던 함수가 <code>a -&gt; b</code>이면, <code>(.)</code>을 쓰고, <code>a -&gt; m b</code>이면 <code>&gt;&gt;=</code>을 쓰면 됩니다.</p>
<p>이제, 마지막으로 이렇게 2튜플의 2튜플로 만든, 어떻게 보면 우악스러워 보이는 <code>((((...)...)...)...)</code> 형태의 각 각에 접근하는 방법을 모나드의 <code>do</code>표기처럼 쉽게 해 주는 뭔가가 필요합니다.<br />
<code>m1 &gt;&gt;= \r1 -&gt; m2 &gt;&gt;= \r2 -&gt; m3 &gt;&gt;= \r3 -&gt; m4...</code>로 쓰면 복잡하지만,</p>
<pre><code>do
  r1 &lt;- m1
  r2 &lt;- m2
  r3 &lt;- m3
  ...</code></pre>
<p>이렇게 이쁘게 쓸 수 있게 됐듯이, Arrow를 쓰기 편하게 해주는 확장이 있습니다. 아래에서 이어가도록 하겠습니다.</p>
<p>물론, Arrow의 특 장점이 이게 전부는 아닙니다. 체인을 만들면서, 병행 길을 만들기도, 조건에 따라 분기를 만들기도 할 수 있습니다. 위 스트레칭은 그냥 합성composition하지 않고, 타입으로 래핑해서 얻을 수 있는 능력의 일부를 보이려고 든 예시입니다.</p>
<p>모든 분들에게 어울리는 접근 방법은 아니겠지만, 저는 이렇게 뭘 위해 개념을 도입, 혹은 만들어 내고 있는 지 알면 텍스트를 쫓아가기가 편합니다.</p>
<h1 id="arrow">Arrow</h1>
<h2 id="입출력-타입에-의존하는-클래스">입,출력 타입에 의존하는 클래스</h2>
<p>출력 타입에만 의존하지 않고, 입,출력 모두에 의존하도록, 입출력 타입을 타입 매개 변수로 가진 클래스를 정의해, 출력뿐만이 아니라 입력이 달라질 때도 명시적인 리프팅 없이 작업을 할 수 있습니다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> cat <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  id ::</span> cat a a</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (.) ::</span> cat b c <span class="ot">-&gt;</span> cat a b <span class="ot">-&gt;</span> cat a c</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> arr <span class="ot">=&gt;</span> <span class="dt">Arrow</span> arr <span class="kw">where</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  arr ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> arr a b <span class="co">-- 메소드명 arr과 타입인자 arr는 다르다.</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                             <span class="co">-- 모나드 코드 m a에서 m에 해당하는데</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                             <span class="co">-- (b -&gt; c) -&gt; a b c로 표기하기도 한다.</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  first ::</span> a b c <span class="ot">-&gt;</span> a (b,d) (c,d)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  first <span class="ot">=</span> (<span class="op">***</span> <span class="fu">id</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  (***) ::</span> a b c <span class="ot">-&gt;</span> a b' c' <span class="ot">-&gt;</span> a (b,b') (c,c')</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  f <span class="op">***</span> g <span class="ot">=</span> first f <span class="op">&gt;&gt;&gt;</span> arr swap <span class="op">&gt;&gt;&gt;</span> first g <span class="op">&gt;&gt;&gt;</span> arr swap</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> swap <span class="op">~</span>(x,y) <span class="ot">=</span> (y,x)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- 최소 정의 arr, (first | (***))</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- 아래는 메소드가 아닌 별도 함수로 Category 모듈에 정의되어 있다.</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;&gt;) ::</span> <span class="dt">Category</span> arr <span class="ot">=&gt;</span> arr a b <span class="ot">-&gt;</span> arr b c <span class="ot">-&gt;</span> arr a c</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;&gt;&gt;</span> g <span class="ot">=</span> g <span class="op">.</span> f <span class="co">-- dot의 방향때문에 사람 버벅거리게 만든다. f가 먼저냐 g가 먼저나.</span></span></code></pre></div>
<p>실제 정의는 위와 같이 되어 있지만, 텍스트에선 아래에서 설명을 시작합니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  arr ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> arr a b <span class="co">-- 메소드명 arr과 타입인자 arr는 다르다.</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>                             <span class="co">-- 모나드 코드 m a에서 m에 해당하는데</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                             <span class="co">-- (b -&gt; c) -&gt; a b c로 표기하기도 한다.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;&gt;) ::</span> arr a b <span class="ot">-&gt;</span> arr b c <span class="ot">-&gt;</span> arr a c</span></code></pre></div>
<p>함수 타입을 위한 인스턴스를 만들면,</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  arr <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&gt;&gt;&gt;</span>) <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">.</span>)</span></code></pre></div>
<p>위 <code>(&gt;&gt;&gt;)</code>는 함수 합성 <code>(.)</code>과 비슷하게 arrow를 합성하는데, 인자 순서만 <code>(.)</code>과 거꾸로입니다. 특별히 개별 함수들의 결과값을 튜플로 남긴다거나 하지 않고, 보통의 함수 체인처럼 이전 함수의 결과를 다음 함수의 입력으로 넣어주기만 합니다.</p>
<p>Effect가 있는 Kleisli 타입을 위한 인스턴스를 만들면,</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Kleisli</span> m a b <span class="ot">=</span> <span class="dt">Kleisli</span> {<span class="ot">runKleisli ::</span> a <span class="ot">-&gt;</span> m b}</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Arrow</span> (<span class="dt">Kleisli</span> m) <span class="kw">where</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  arr ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m a b <span class="co">-- (a -&gt; m b)가 아님</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  arr f <span class="ot">=</span> <span class="fu">return</span> <span class="op">.</span> f</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Kleisli</span> m a b <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m b c <span class="ot">-&gt;</span> <span class="dt">Kleisli</span> m a c</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  (f <span class="op">&gt;&gt;&gt;</span> g) a <span class="ot">=</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> f a </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                 g b</span></code></pre></div>
<p><code>Kleisli</code> 타입은 내부에서 이미 존재하는 <code>m</code>이 가지고 있는 바인드를 써서 <code>(&gt;&gt;&gt;)</code>를 구현합니다. <code>(-&gt;)</code>와 <code>Kleisli</code>의 <code>arr</code>이나 <code>(&gt;&gt;&gt;)</code>가 별다른 일을 하지 않고 있지만, <code>Arrow</code> 인스턴스가 되면서 <code>&amp;&amp;&amp;, ***, first, second</code>등을 쓸 수 있게 됩니다.</p>
<h2 id="arr-만-있으면-return-를-즉-모나드를-대체할-수-있을까">arr, (&gt;&gt;&gt;)만 있으면 return, (&gt;&gt;=)를, 즉 모나드를 대체할 수 있을까?</h2>
<p>Kleisli 타입을 가진 Arrow가 모나드와 같은 동작을 하고 있을까요? <code>(&gt;&gt;&gt;)</code>의 구현을 보면 바인드가 돌고 있습니다. <code>(&gt;&gt;&gt;)</code>는 그대로 바인드와 대응하는 것으로 보입니다. 텍스트를 보면, <code>(&gt;&gt;=)</code>는 두 번째 인자로 <code>a -&gt; m b</code> 함수를 받기 때문에, 두 개의 Effectful Computation을 순차적으로 실행하는 동안 어떤 하스켈 코드all of Haskell든 실행할 수 있는 기회가 있다고 얘기합니다.</p>
<p>그런데, 위에서 보듯 <code>(&gt;&gt;&gt;)</code>가 함수가 아닌 <code>Arrow</code>값 두개를 받긴 해도, 안에서 <code>(&gt;&gt;=)</code>가 도는데 차이가 없을 것처럼 보입니다. 원문에는 아래 같은 내용이 있습니다. (Programming with Arrows - John Hughes 발췌)</p>
<blockquote>
<p>In the case of monads, the second argument of (&gt;&gt;=) is a Haskell function, which permits the user of this interface to <strong><em>use all of Haskell to map the result of the first computation to the computation to be performed next. Every time we sequence two monadic computations, we have an opportunity to run arbitrary Haskell code in between them.</em></strong> But in the case of arrows, in contrast, the second argument of (&gt;&gt;&gt;) is just an arrow, an element of an abstract datatype, and the only things we can do in that arrow are things that the abstract data type interface provides. Certainly, the arr combinator enables us to have the output of the first arrow passed to a Haskell function — but this function is a pure function, with the type b -&gt; c, which thus has no opportunity to perform further effects. If we want the effects of the second arrow to depend on the output of the first, then we must construct it using operations other than arr and (&gt;&gt;&gt;)</p>
</blockquote>
<p>이 부분이 스윽 넘어가지지 않아, 아래와 같이 <code>Maybe</code>모나드로 풀어 봤습니다.</p>
<p>첫 컴퓨테이션 값이 <code>Nothing</code>이면, 다음 이어지는 컴퓨테이션에서 <code>a -&gt; m b</code>가 무슨 동작을 하든 <code>Nothing</code> 결과가 나옵니다. 타입을 눈에 보는 그대로 읽으면, <code>m</code>(the effect)도, <code>b</code>도 <code>a</code>에 의존합니다. 하지만, 바인드와 다르게 <code>(&gt;&gt;&gt;)</code>는 이미 <strong>결정된</strong> Arrow 컴퓨테이션 두 개만 받습니다. 이미 정해진 Arrow 컴퓨테이션에 할 수 있는 일은 Arrow가 제공하는 인터페이스를 이용해서 할 수 있는 일만 가능합니다. (Applicatives도 결정된 컴퓨테이션만 받으니, 둘이 연결되는 개념이 있지 않을까 합니다.) 만일, 지금 손에 쥔 인터페이스가 <code>arr</code>과 <code>(&gt;&gt;&gt;)</code>만 있다면, 어떤 일을 할 수 있는지 보겠습니다.</p>
<p><code>arr</code>의 서명은 <code>(b -&gt; m c) -&gt; a b c</code>가 아니라 <code>(b -&gt; c) -&gt; a m b c</code> 입니다.<br />
<code>Kleisli Maybe</code> Arrow를 생각해 보면, <code>arr f</code>는 <code>Just . f</code>입니다. <code>Just</code>일지 <code>Nothing</code>일지 고르는 절차 없이 바로 <code>Just</code> 값 생성자를 쓸 뿐입니다. <code>arr</code>로 리프팅하여 만든 컴퓨테이션엔 이미 <code>Just</code>로 고정되어 있지, 바인드의 두 번째 인자 <code>a -&gt; m b</code>처럼, <code>a</code>에 따라 <code>m</code>이 <code>Just</code>인지 <code>Nothing</code>인지 결정하는 절차가 파고 들어갈 기회가 없습니다.</p>
<p>Mon Feb 5 01:04:47 PM KST 2024 작성 중…</p>
<blockquote>
<p>아래는 <span class="citation" data-cites="Ailrun">@Ailrun</span> 님의 설명을 옮겼습니다.<br />
예를 들어 <code>State</code>를 다음처럼 모나드 인터페이스를 쓰는 것과, <code>Arrow</code> 인터페이스를 쓰는 것을 비교하면</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Monad</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">State</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">set ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="dt">Int</span> ()</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Arrow</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="ot">getA ::</span> <span class="dt">StateArr</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ot">setA ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StateArr</span> <span class="dt">Int</span> ()</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> getA <span class="op">&gt;&gt;&gt;</span> setA <span class="dv">5</span> <span class="co">-- 가능</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> get <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> set (x <span class="op">+</span> <span class="dv">1</span>)) <span class="co">-- 가능</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> getA <span class="op">&gt;&gt;&gt;</span> (\x <span class="ot">-&gt;</span> set (x <span class="op">+</span> <span class="dv">1</span>)) <span class="co">-- 불가능</span></span></code></pre></div>
<p><code>a b c</code> 와 <code>a c d</code> 를 섞는 것 뿐만 아니라<br />
<code>a b c</code> 와 <code>c -&gt; a d e</code> 도 섞을 수 있냐를 얘기하는 겁니다.</p>
<p><code>arr</code>과 <code>(&gt;&gt;&gt;)</code>만으론 다음처럼이 한계입니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mix ::</span> a b c <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a d e) <span class="ot">-&gt;</span> a b (a d e)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>mix p q <span class="ot">=</span> p <span class="op">&gt;&gt;&gt;</span> arr q <span class="co">-- q를 Arrow로 만들어야 하니 arr q</span></span></code></pre></div>
<p><code>first</code>나 <code>app</code> 등이 추가되어야 비로소 (<code>a</code>가 중첩되어 있는 <code>a b (a d e)</code>가 아닌) <code>a (b,d) e</code>를 얻을 수 있게 됩니다.</p>
<p><code>Arrow</code>가 모나드 동작을 할 수 있는가는, “언제 <strong><em>Uncurrying</em></strong>이 가능한 <code>a</code>를 얻을 수 있는가?”라고 볼 수도 있습니다.</p>
<p><code>Monad</code>의 핵심이 <code>join :: m (m a) -&gt; m a</code>이니, 이와 비교하기 좋게 바꿔서 보면,<br />
<code>joinLikeArr :: a b (a c d) -&gt; a (b, c) d</code>를 구현할 수 있냐 없냐가 <code>Arrow a</code>로 <code>Monad</code>가 하던 일을 할 수 있냐 없냐를 결정한다고 볼 수도 있겠습니다.<br />
<code>a b c</code>에서 <code>a</code>가 <code>(-&gt;)</code>인 경우는 다음처럼 됩니다.<br />
<code>uncurry :: (b -&gt; c -&gt; d) -&gt; ((b, c) -&gt; d)</code></p>
</blockquote>
<p>(※ <a href="https://lionhairdino.github.io/posts/2022-09-06-applicative_functor.html">모나드와 Applicatives의 차이</a>를 고민할 때, 모나딕한 동작을 하려면 <code>a -&gt; m b</code> 형태가 반드시 있어야 하고, <code>m b</code> 만으론 부족하다고 틀리게 생각했던 것과 약간 비슷한 요소가 보입니다. )</p>
<p>※ 모나드는 3개의 법칙만 있지만, Arrow는 20개가 있습니다. 여기에 Paterson이 추가한 것까지 합치면 27개입니다. 텍스트에서도 너무 정교한 설명말고 사용법 위주로 설명한다고 되어 있습니다.</p>
<blockquote>
<p><span class="citation" data-cites="재경">@재경</span> 님의 예시
<span class="citation" data-cites="todo">@todo</span> 정리 중에 있습니다.</p>
</blockquote>
<h2 id="applicatives와-arrow-비교">Applicatives와 Arrow 비교</h2>
<p><span class="citation" data-cites="todo">@todo</span></p>
<h2 id="모나드가-하는-일을-할-수-있도록-인터페이스를-확장해-보자">모나드가 하는 일을 할 수 있도록 인터페이스를 확장해 보자</h2>
<p>지금부터 2튜플의 2튜플…로 함수들의 결과들을 각 각 기억하는 방법을 위해 필요한 도구(<code>&amp;&amp;&amp;</code>,<code>***</code>,<code>first</code>,<code>second</code>)들을 보겠습니다.</p>
<p>모나드에 들어 있는 두 값을 더하는 것을 보면</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>addM a b <span class="ot">=</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> a</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>              y <span class="ot">&lt;-</span> b</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>              <span class="fu">return</span> (x <span class="op">+</span> y)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- 바인드가 보이게 하면</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>a <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> b <span class="op">&gt;&gt;=</span> \y <span class="ot">-&gt;</span> <span class="fu">return</span> (x <span class="op">+</span> y)</span></code></pre></div>
<p>위를 읽을 때, <code>a</code> 계산식의 결과를 <code>b</code>가 받는 것으로 읽는 게 아닙니다. <code>a</code> 계산식의 결과를 <code>x</code>로 받고, (이 경우는) <code>a</code>의 결과와 상관 없이 <code>b</code>계산식의 결과를 <code>y</code>로 받아, 마지막에 둘을 <code>+</code>하는 작업입니다. 어떤 <code>M</code>이 들어왔냐에 따라, 숨어 있는 바인드 인스턴스가 알아서 Effect 작업을 담당합니다.</p>
<p>함수형에서는 스코프가 넒은 변수를 쓸 수가 없어, 여러 개의 정보를 “유통”시키려면 인자를 늘리거나 튜플을 씁니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addA ::</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> arr a <span class="dt">Int</span> <span class="ot">-&gt;</span> arr a <span class="dt">Int</span> <span class="ot">-&gt;</span> arr a <span class="dt">Int</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>addA f g <span class="ot">=</span> f_and_g <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="op">+</span>))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- uncurry는 인자를 두 개 받는 함수를 2튜플 하나를 받는 함수로 바꿔줍니다.</span></span></code></pre></div>
<p><code>f</code>,<code>g</code> 계산을 튜플로 묶은 후 다음으로 넘기면 됩니다. 여기서 <code>f_and_g</code>는 <code>f, g, (&gt;&gt;&gt;), arr</code>만으론 구현할 수 있을까요?</p>
<p><code>... &gt;&gt;&gt; f &gt;&gt;&gt; ...</code>로 체인을 만들어 두면 <code>f</code>가 나온 뒤에는 <code>f</code>의 결과값 말고는 다 잃어버립니다. 위에 모나드 예시로 보면 <code>x</code>를 기억시키지 못합니다. <code>g</code>의 출력도, 제일 처음에 입력으로 받았던 값도 모두 잃어버립니다.</p>
<blockquote>
<p>Q. 어차피 타입에 따른 인스턴스를 만들어야 하는데, 이 때 메소드를 잘 만들면 가능하지 않을까요?<br />
A. <code>(&gt;&gt;&gt;)</code>를 “자유”롭게 만들 수 있는 건 아닙니다. 서명이 <code>Arrow.. -&gt; Arrow.. -&gt; Arrow..</code>으로 정해져 있습니다.</p>
</blockquote>
<h2 id="section">(&amp;&amp;&amp;)</h2>
<p>그래서 2튜플을 이용해 각 각의 결과를 유지하기 위해 <code>Arrow</code>에 다음 컴비네이터를 추가합니다. 2튜플은 두 개의 값을 담아 둘 수 있으니, <code>(&amp;&amp;&amp;)</code>를 적절히 구현해서 두 <code>Arrow</code>의 결과가 각각 2튜플에 담기도록 하면, 일단 필요한 정보는 살릴 수 있습니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&amp;&amp;&amp;) ::</span> arr a b <span class="ot">-&gt;</span> arr a c <span class="ot">-&gt;</span> arr a (b, c)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                                       <span class="op">^^^^^^</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>                                        <span class="dv">2</span>튜플</span></code></pre></div>
<p><code>Arrow</code> 두 개를 받아 각 각의 Computation을 실행하고, <code>(&gt;&gt;&gt;)</code>처럼 이어지는 Computation에 결과를 넘기는 게 아니라, 결과를 2튜플로 만드는 컴비네이터입니다. 이제, 이를 이용하면 <code>f_and_g</code>를 구현할수 있습니다.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>addA f g <span class="ot">=</span> f <span class="op">&amp;&amp;&amp;</span> g <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="op">+</span>))</span></code></pre></div>
<p>위에서 봤던 함수와 Kleisli 타입을 위한 인스턴스를 다음과 같이 구현할 수 있습니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  (f <span class="op">&amp;&amp;&amp;</span> g) a <span class="ot">=</span> (f a, g a)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Arrow</span> (<span class="dt">Kleisli</span> m) <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Kleisli</span> f <span class="op">&amp;&amp;&amp;</span> <span class="dt">Kleisli</span> g <span class="ot">=</span> <span class="dt">Kleisli</span> <span class="op">$</span> \a <span class="ot">-&gt;</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> f a</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>                                               c <span class="ot">&lt;-</span> g a</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>                                               <span class="fu">return</span> (b, c)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- stream 함수 `SF`의 경우는 `f`와 `g`의 출력을 `zip`하면 된다.</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">SF</span> <span class="kw">where</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SF</span> f <span class="op">&amp;&amp;&amp;</span> <span class="dt">SF</span> g <span class="ot">=</span> <span class="dt">SF</span> (f <span class="op">&amp;&amp;&amp;</span> g <span class="op">&gt;&gt;&gt;</span> <span class="fu">uncurry</span> <span class="fu">zip</span>)</span></code></pre></div>
<p>각각의 <code>Arrow</code>에 들어 있는 함수들의 결과를 튜플에 넣게만 만들면 됩니다.<br />
※ “각각” 돌기 때문에 <code>&amp;</code>를 쓴 것 같은데, 네이밍에 관한 설명은 따로 안 보입니다.</p>
<p>※ <code>(&amp;&amp;&amp;)</code>의 결과를 머릿속에서 단순한 모양으로 reduce하려 하지 말아야 합니다.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Kleisli</span> <span class="op">$</span> \a <span class="ot">-&gt;</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> f a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>                   c <span class="ot">&lt;-</span> g a</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                   <span class="fu">return</span> (b, c)</span></code></pre></div>
<p>이 자체가 가장 단순한 모양입니다.</p>
<h2 id="section-1">(***)</h2>
<p>다음으로 할 일은, 최대한 타입에 따라 바뀌지 않는 부분을 분리해기 위해 다음처럼 생각해 볼 수 있습니다. 위 구현을 보면 <code>a</code>를 한 번 받아 <code>f</code>에 한 번, <code>g</code>에 한 번씩 쓰고 있습니다. <code>a</code>를 복사duplicate하는 성질(<code>\x -&gt; (x,x)</code>)을 빼내면 다음 처럼 볼 수 있습니다.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&amp;&amp;&amp;</span> g <span class="ot">=</span> arr (\x <span class="ot">-&gt;</span> (x, x)) <span class="op">&gt;&gt;&gt;</span> f <span class="op">***</span> g</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">--              a -&gt;   b     &gt;&gt;&gt; b -&gt; c</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- b가 2튜플 타입이고, (f *** g)는 2튜플을 받는 함수를 가지고 있는 Arrow다.</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="kw">where</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  (***) ::</span> arr a b <span class="ot">-&gt;</span> arr c d <span class="ot">-&gt;</span> arr (a,c) (b,d)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- 따로 받던 a, c를 같이 튜플로 묶어서 받고, 결과값도 튜플로 묶는다. 그냥, 각각 동작할 함수들의 입력을 짝 짓고, 출력을 짝지어 묶어놨을 뿐이다.</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- a, b는 같을 필요 없다. 이 경우는 duplicate해서 들어오고 있다.</span></span></code></pre></div>
<p><code>(***)</code>는 두 개의 <code>Arrow</code>를 받아 2튜플을 받고 뱉는 하나의 <code>Arrow</code>로 만듭니다. 이 건 하나의 <code>Arrow</code>를 2튜플을 가진 <code>Arrow</code>로 리프팅해서 얻을 수도 있습니다. 저는 이 아이디어가 금방 눈에 들어오지 않았습니다.<br />
현재 목표는 값 하나를 넣어주면, 두 개로 만들어 (이 작업은 이미 <code>(***)</code>전에 이루어집니다.),<br />
<code>(***)</code>이 2튜플로 결과를 반환 할 수 있어야 합니다.(<code>(***)</code>가 하는 일)</p>
<p>그런데, 이 전 구현보다 더 단순해진 것도 아니고, 굳이 이렇게 구현해야 하는 생각이 잠깐 들었습니다. 뒤에 보면, 2튜플로 저글링을 많이 합니다. 아마도 이를 위한 컴비네이터 아닌가 싶습니다.</p>
<h2 id="first">first</h2>
<p>처음 봤을 때는, 이 것도 왜 필요한지 금방 눈에 들어오지 않았습니다.<br />
왜 모나딕한 동작을 위해서, <code>first</code>가 필요할까요? 텍스트에선 친절하게 말해주지 않습니다. (제가 못찾거나요)</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  first ::</span> arr a b <span class="ot">-&gt;</span> arr (a,c) (b,c)</span></code></pre></div>
<p>first를 함수, Kleisli arrow, Stream function을 위한 구현을 보면</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 클래스에 있는 서명을 보면 first는 인자를 하나만 받고 있지만,</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- arr에 (-&gt;)를 넣으면</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- ((-&gt;) a b) -&gt; ((-&gt;) (a,c) (b,c))</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- 아래와 같이 2개의 인자를 받는 모양이 된다.</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="co">--      (a -&gt; b) -&gt; (a,c) -&gt; (b  ,c)</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  first     f       (a,c) <span class="ot">=</span>  (f a,c) </span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Arrow</span> (<span class="dt">Kleisli</span> m) <span class="kw">where</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>  first (<span class="dt">Kleisli</span> f) <span class="ot">=</span> <span class="dt">Kleisli</span> (\(a,c) <span class="ot">-&gt;</span> <span class="kw">do</span> b <span class="ot">&lt;-</span> f a</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>                                            <span class="fu">return</span> (b,c))</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">SF</span> <span class="kw">where</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  first (<span class="dt">SF</span> f) <span class="ot">=</span> <span class="dt">SF</span> (<span class="fu">unzip</span> <span class="op">&gt;&gt;&gt;</span> first f <span class="op">&gt;&gt;&gt;</span> <span class="fu">uncurry</span> <span class="fu">zip</span>)</span></code></pre></div>
<p><strong><em>눈여겨 볼 부분은 현재 계산식에 영향을 미치지 않는 정보를 얹힐 <code>( ,c)</code>가 있는 겁니다.</em></strong><br />
구현을 말로 읽어 보면, 당장은 필요 없는 <code>c</code>를, 지금 필요한 <code>a</code>와 묶어서 넘기면 <code>a</code>에만 작업을 해주는 단순한 일을 하는 컴비네이터입니다. 물론 컨텍스트는 유지해 주면서요. 값 하나를 받아 하나만 반환하던 Arrow를 <code>first</code>로 변환하면, 튜플을 받고 튜플을 내뱉는 함수로 바뀝니다.</p>
<p><code>Arrow</code>클래스의 최소 정의를 보면 <code>first</code>또는 <code>(***)</code> 둘 중 하나만 구현하면, 구현된 걸로 나머지 하나를 구현할 수 있다고 되어 있습니다. <code>first</code>로 <code>(***)</code>을 구현하려면 우선 <code>second</code>를 정의합니다.</p>
<h2 id="second">second</h2>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">second ::</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> arr a b <span class="ot">-&gt;</span> arr (c,a) (c,b)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>second f <span class="ot">=</span> arr swap <span class="op">&gt;&gt;&gt;</span> first f <span class="op">&gt;&gt;&gt;</span> arr swap</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> swap (x,y) <span class="ot">=</span> (y,x)</span></code></pre></div>
<p><strong><em>역시 눈여겨 볼 부분은 현재 계산식에 영향을 미치지 않는 정보를 얹힐 <code>(c, )</code>가 있는 겁니다.</em></strong></p>
<p><code>second</code>는 <code>first</code>로 구현되기 때문에 따로 구현할 필요 없이, 위 디폴트 구현으로 어디든 쓰면 됩니다. <code>first</code>만 있다면 말입니다.</p>
<h2 id="다시-정의">(***) 다시 정의</h2>
<p>이제, <code>first</code>, <code>second</code>를 써서 <code>(***)</code>를 정의할 수 있습니다.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">***</span> g <span class="ot">=</span> first f <span class="op">&gt;&gt;&gt;</span> second g</span></code></pre></div>
<p>왜 이렇게 될까요?</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 비교하기 좋게 constraint는 생략하고 보면</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="ot">first  ::</span> arr a b <span class="ot">-&gt;</span> arr (a,c) (b,c)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="ot">second ::</span> arr x y <span class="ot">-&gt;</span> arr (d,x) (d,y)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;&gt;)  ::</span> arr a b         <span class="ot">-&gt;</span> arr b c         <span class="ot">-&gt;</span> arr a c</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>          arr (a,c) (b,c) <span class="ot">-&gt;</span> arr (d,x) (d,y) <span class="ot">-&gt;</span> arr (a,c) (d,y) </span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>                 <span class="co">-- (b,c) = (d,x) 가 같아야만 합니다.</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>                 <span class="co">-- d = b 이고, c = x 입니다.</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>                                             <span class="ot">-&gt;</span> arr (a,x) (b,y)</span></code></pre></div>
<p>최종 결과 타입만 보면 <code>arr (a,x) (b,y)</code>에<br />
처음 액션 혹은 함수인 <code>f</code>의 결과 값 <code>b</code>가 살아 있어야 하고,<br />
다음 액션 혹은 함수인 <code>g</code>의 결과 값 <code>y</code>가 살아 있어야 합니다.<br />
마지막 <code>(b,y)</code>에는 둘 다 살아 있으니 목표 달성인 건 맞을 것 같긴 합니다. 역시나 텍스트는 친절하지 않습니다.</p>
<p><code>first f &gt;&gt;&gt; second g</code>는 현재 목적에 맞는지 말로 읽어보면, 언젠가 값을 duplicate한 2튜플을 받아 <code>f</code>에 한 번 넣어주고, <code>g</code>에 한 번 넣어줘서 각 결과값을 다시 튜플로 묶습니다. 두 번의 액션(혹은 함수)의 결과가 모두 살아 있으니 목표 달성입니다.</p>
<p>아이디어를 정리하면 <code>f</code>도 <code>a</code>가 필요하고, <code>g</code>도 <code>a</code>가 필요합니다.</p>
<ul>
<li><code>a</code>를 <code>(a,a)</code>로 만듭니다.</li>
<li><code>f</code>로 앞에 <code>a</code>만 바꿉니다. <code>(f a, a)</code></li>
<li><code>g</code>로 뒤에 <code>a</code>만 바꿉니다. <code>(f a, g a)</code></li>
</ul>
<p>만일 <code>(***)</code>가 먼저 위와 같은 동작을 하도록 정의되어 있다면,</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>first f <span class="ot">=</span> f <span class="op">***</span> arr <span class="fu">id</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- (***) :: arr a b -&gt; arr c d -&gt; arr (a,c) (b,d)</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- arr a b *** arr b b = arr (a,b) (b,b)</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- 2튜플을 받아 앞에 것에만 작업 할 수 있게 했을 뿐, 별다른 작업은 없습니다.</span></span></code></pre></div>
<p><code>f</code>는 <code>a -&gt; b</code> 함수고, <code>first f</code>는 <code>(a,dontTouch) -&gt; (b,dontTouch)</code>함수 입니다.<br />
<code>second</code>도, <code>(***)</code>도 <code>first</code>만 있으면 구현할 수 있습니다. 이제 <code>first</code>만 있으면 합성하며, 이전 액션(혹은 함수)의 결과를 다음에 넘기는 일을 할 수 있습니다.</p>
<p>그 외, <code>(^&gt;&gt;)</code>, <code>(&gt;&gt;^)</code>, <code>(&lt;&lt;^)</code>, <code>(^&lt;&lt;)</code> 들은 순수 함수들을 합성compose할 때 <code>arr</code>을 매 번 쓰는 귀찮음을 덜어주는 편의 컴비네이터들입니다.</p>
<p><code>(***)</code>, <code>first</code>, <code>second</code> 모두 어떤 함수가 들어오든 상관없이 <strong>튜플 구조에만</strong> 관여하는 컴비네이터들로, 이들 중 하나만 구현되어 있으면, 그 걸로 나머지를 구현할 수 있습니다.</p>
<h2 id="조건부로-arrow-컴비네이션하기">조건부로 Arrow 컴비네이션하기</h2>
<p>지금부턴 Arrow를 막강하게 해주는 특징, 다이내믹한 흐름을 위한 도구(<code>|||</code>, <code>mapA</code>, <code>+++</code>, <code>left</code>, <code>right</code>)들을 보겠습니다.</p>
<p>If Then Else - ifte</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ifte ::</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> arr a <span class="dt">Bool</span> <span class="ot">-&gt;</span> arr a b <span class="ot">-&gt;</span> arr a b <span class="ot">-&gt;</span> arr a b</span></code></pre></div>
<p><code>ifte p f g</code>는 불린값 <code>p</code>가 참이면 <code>f</code>, 거짓이면 <code>g</code></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- (&amp;&amp;&amp;) :: arr a b -&gt; arr a c -&gt; arr a (b, c)</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>ifte p f g <span class="ot">=</span> p <span class="op">&amp;&amp;&amp;</span> arr <span class="fu">id</span> <span class="op">&gt;&gt;&gt;</span> f <span class="op">|||</span> g</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>             <span class="op">^^^^^^^^^^^^</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- 왜 이렇게 할까요?</span></span></code></pre></div>
<p><code>p &amp;&amp;&amp; arr id</code>는 왜 해주는 걸까요? <code>p</code>는 조건에 맞는지 검사 후 <code>Bool</code>값을 반환하는 함수입니다.<br />
<code>arr a Bool &amp;&amp;&amp; arr a a = arr a (Bool, a)</code><br />
원래의 함수는 <code>Bool</code>만 돌려주는데, <strong>변환한 함수</strong>는 결과에 <code>Bool</code>값과 처음 입력한 값을 같이 2튜플에 남겨 둘 수 있습니다.</p>
<h2 id="section-2">(|||)</h2>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>p <span class="op">&amp;&amp;&amp;</span> arr<span class="ot"> id ::</span> arr a (불린값, f나g에 넣어줄 입력값)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">|||</span><span class="ot"> g ::</span> arr (a, b) c</span></code></pre></div>
<p><code>(|||)</code>는 불린값에 따라 <code>f</code> 혹은 <code>g</code>를 고르고 입력값을 넣어줍니다.</p>
<p>입력값을 2튜플이 아닌 <code>Either</code>를 받도록 하면 좀 더 매끄러울 수 있습니다. <code>(True, a)</code>를 <code>Left a</code>로, <code>(False, a)</code>를 <code>Right a</code>로 하면 <code>Left</code>일 때와 <code>Right</code>일 때 다른 타입을 갖고 있게 할 수 있어 표현력이 늘어 납니다.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> <span class="dt">ArrowChoice</span> arr <span class="kw">where</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  (|||) ::</span> arr a c <span class="ot">-&gt;</span> arr b c <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a b) c</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>                                     <span class="op">^^^^^^^^^^^^</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- 여기를 2튜플이 아닌 Either로 바꾼다.</span></span></code></pre></div>
<p>아직 duality에 대한 지식이 없어 정확한 “감탄”은 못하지만, 위 서명에서 <code>arr</code>의 인자 순서를 바꾸고, <code>Either a b</code>를 <code>(a, b)</code>로 대체하면 <code>(&amp;&amp;&amp;)</code>가 나옵니다.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">  (|||) ::</span> arr a c <span class="ot">-&gt;</span> arr b c <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a b) c</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&amp;&amp;&amp;) ::</span> arr a b <span class="ot">-&gt;</span> arr a c <span class="ot">-&gt;</span> arr a (b, c)</span></code></pre></div>
<p>conditional을 쓴 예시로 <code>mapA</code> 함수를 보겠습니다.</p>
<h2 id="mapa">mapA</h2>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapA ::</span> <span class="dt">ArrowChoice</span> arr <span class="ot">=&gt;</span> arr a b <span class="ot">-&gt;</span> arr [a] [b]</span></code></pre></div>
<p><code>mapA</code>는 choice가 필요합니다. 왜 필요할까요?</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> _ []     <span class="ot">=</span> [] <span class="co">-- base case 혹은 edge case</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> <span class="fu">map</span> f xs <span class="co">-- recursive case</span></span></code></pre></div>
<p><code>map</code>은 보통 base, recursive를 구분해야 합니다. 다음처럼 표현할 수 있습니다.<br />
<code>base case ||| recursive case</code></p>
<p>우선 입력을 <code>Either</code> 타입으로 바꿔주는 보조 함수를 만들고,</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>listcase [] <span class="ot">=</span> <span class="dt">Left</span> ()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>listcase (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Right</span> (x,xs)</span></code></pre></div>
<p>이제 <code>mapA</code>를 구현하면</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>mapA f <span class="ot">=</span> arr listcase <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>         arr (<span class="fu">const</span> []) <span class="op">|||</span> (f <span class="op">***</span> mapA f <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="op">:</span>)))</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co">--                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="co">--                      map의 f x : map f xs 와 비슷한 동작을 한다.</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co">--            uncurry는 인자 두 개를 받던 함수를 2튜플 하나 받는 걸로 바꾼다.</span></span></code></pre></div>
<p>컴비네이터 스타일의 우아함이 폭발하는데, 저는 금방 우아할 수가 없습니다. 어렵습니다.</p>
<h2 id="section-3">(+++)</h2>
<p><code>f ||| g</code>는 <code>f</code>와 <code>g</code>가 같은 타입의 출력이어야 하는데, <code>Either</code>를 쓰면 다른 타입도 가능합니다.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> <span class="dt">ArrowChoice</span> arr <span class="kw">where</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  (+++) ::</span> arr a b <span class="ot">-&gt;</span> arr c d <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a c) (<span class="dt">Either</span> b d)</span></code></pre></div>
<p><code>(+++)</code>과 <code>(|||)</code>의 관계는 <code>(***)</code>과 <code>(&amp;&amp;&amp;)</code>의 관계와 비슷합니다. <code>(|||)</code>를 직접 구현하는 것 보다는 <code>(+++)</code>를 먼저 구현하고, <code>(+++)</code>을 써서 <code>(|||)</code>를 구현하는 게 편합니다.</p>
<p><code>(+++)</code>는 <code>(***)</code>와 dual입니다. <code>Either</code> 타입을 2튜플로 바꾸고, <code>arr</code>의 인자 순서를 바꾸면 <code>(|||)</code>의 정의는</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">|||</span> g <span class="ot">=</span> f <span class="op">+++</span> g <span class="op">&gt;&gt;&gt;</span> arr join <span class="co">-- 라이브러리에선 join대신 untag란 이름을 쓴다.</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> join (<span class="dt">Left</span> b)  <span class="ot">=</span> b</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>        join (<span class="dt">Right</span> b) <span class="ot">=</span> b</span></code></pre></div>
<p><code>(***)</code>를 <code>first</code>로 표현하듯, <code>(+++)</code>는 <code>Either</code>의 <code>left</code>로 리프팅하는 단순한 컴비네이터로 정의할 수 있습니다.</p>
<p><code>(***)</code>는 두 개의 Arrow를 받아 2튜플로 묶는 작업을 했고,(두 Arrow 모두 실행)<br />
<code>(+++)</code>는 두 개의 Arrow를 받아 <code>Either</code>로 묶는 작업을 했습니다. (두 Arrow 중 하나만 실행하기 위한 사전 동작?)<br />
</p>
<h2 id="left">left</h2>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arrow</span> arr <span class="ot">=&gt;</span> <span class="dt">ArrowChoice</span> arr <span class="kw">where</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  left ::</span> arr a b <span class="ot">-&gt;</span> arr (<span class="dt">Either</span> a c) (<span class="dt">Either</span> b c)</span></code></pre></div>
<p><code>left f</code>는 <code>Left</code>라고 태깅된 입력은 <code>f</code>에 넣어주고, <code>Right</code>라고 태깅된 입력은 그냥 통과시킵니다.</p>
<h2 id="right">right</h2>
<p><code>first</code>로 <code>second</code>를 정의하듯 <code>left</code>로 <code>right</code>를 정의할 수 있습니다.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>right f <span class="ot">=</span> arr mirror <span class="op">&gt;&gt;&gt;</span> left f <span class="op">&gt;&gt;&gt;</span> arr mirror</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> mirror (<span class="dt">Left</span> a) <span class="ot">=</span> <span class="dt">Right</span> a <span class="co">-- swap을 정의하 듯</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>        mirror (<span class="dt">Right</span> a) <span class="ot">=</span> <span class="dt">Left</span> a</span></code></pre></div>
<p>…작성 중</p>
<h2 id="다시-정의-1">(+++) 다시 정의</h2>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">+++</span> g <span class="ot">=</span> left f <span class="op">&gt;&gt;&gt;</span> right g</span></code></pre></div>
<h2 id="사용-예시">사용 예시</h2>
<p><a href="../posts/2023-09-22-using_arrow.html">Arrow 쓰는 방법</a></p>
<h2 id="arrow-확장">Arrow 확장</h2>
<p><a href="../extensions/2023-09-14-arrow-extension.html">확장 Arrows</a></p>
<p>마치 함수를 일반 수처럼 여러 연산자들로 식을 만드는 것 같이 보입니다. Arrow 대수라고 불러도 되지 않을까 싶은데요. 따로 대수라고 부르는데는 못 봤습니다. 컴비네이터 패턴이란게 다 대수와 같은 것들 아닌가 싶습니다.</p>
<p>참고<br />
시간과 머리가 허락한다면, <a href="https://wiki.haskell.org/Arrow#Parser">wiki.haskell.org - Arrow</a> 사이트에 있는 링크를 쫓아다니며 공부하면 Arrow 마스터!가 될 수도 있겠습니다만, 분량이 너무 많습니다.<br />
</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
