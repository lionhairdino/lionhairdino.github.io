<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - Modeling Variables with Pure functions (En)</title>

        <meta name="description" content="In Haskell, where only pure functions are allowed and there is no access to unspecified inputs or side effects, we explored how to model information from higher scopes, such as global variables, using pure functions." />
        <meta property="og:description" content="In Haskell, where only pure functions are allowed and there is no access to unspecified inputs or side effects, we explored how to model information from higher scopes, such as global variables, using pure functions." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Modeling Variables with Pure functions (En)" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2024-11-16-pureFunction_en.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/pureFunction.png" />

      <meta name="keywords" content="haskell, pure, impure, State, Lambda, Combinator, Higher order, Currying, Type, Arrow, Pure function, Monad, Partial application, Effect, Realworld">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
<meta name="fediverse:creator" content="@lionhairdino@mastodon.social">
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:20px;border:none" src="../images/bluesky.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://discordapp.com/users/lionhairdino#7687"><img style="width:20px;border:none" src="../images/discord.svg"></a></div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>Modeling Variables with Pure functions (En)</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on November 16, 2024
    
</div>

<p><a href="../posts/2024-11-16-pureFunction.html">Korean</a> | English<br />
Target readers: I initially aimed to create a guide suitable for complete beginners, but there are sections that require some prior knowledge. It seems more appropriate for those who have started studying Haskell and still feel uneasy after exploring topics like Monad and Arrow.</p>
<p>I work (or aim to work) professionally with functional programming (hereafter referred to as FP), so you could call me a profesional. However, studying the foundations of FP is more like a hobby (closer to being an amateur). While having a deep understanding of the foundational knowledge isn’t strictly necessary to work with FP, my personal curiosity drives me to explore, imagine, and organize these ideas as I dig into various sources.</p>
<p>Since I have few peers to discuss these topics with, I lack reliable means to verify whether my understanding is correct. Please note that the knowledge presented here is based on my imaginings and not formally validated, so take it with caution.</p>
<p>This post begins with pure functions and explores the terms and concepts necessary for getting started with functional programming.</p>
<p style="font-size:1.5em; text-align: center; font-weight: bold;">
The starting point of challenges when studying functional programming is pure functions.
</p>
<figure>
<img src="../images/pureFunction.png" alt="only from input?" />
<figcaption aria-hidden="true">only from input?</figcaption>
</figure>
<h2 id="pure-function-referential-transparency-effect-action">Pure function, Referential Transparency, Effect, Action</h2>
<p>In FP, a function always produces the same output for the same input. Whether you rut it today, tomorrow, or multiple times, the result will not change. It does not rely on global variables or external states, depending solely on its input. As long as the input is known, the output can be determined. This property is known as referential transparency.</p>
<p>※ Although not a complete academic definition, any element that influences the behavior of a function but is not explicitly defined in its input or output is often referred to as an <a href="https://lionhairdino.github.io/posts/2022-09-03-effect.html"><strong>Effect</strong></a>.</p>
<p>Such restrictions may feel overly strict, making one wonder if programming within these constraints is even feasible. How can practical programs be created without relying on Effects? Real-world applications often involve IO operations that are indispensable. To build useful programs, Effects are necessary. (Of course, some libraries designed for use as part of a program may lack Effects, but if the program’s results need to be observed, a completed program without Effects is ultimately impossible.)</p>
<p>Many textbooks and promotional materials claim that functional programming does not include Effects. But since practical programs inherently depend on Effects (especially for IO), what does this really mean? Rather than aiming for a design entirely without Effects, the goal is to effectively separate them.</p>
<p>This means handling as much logic as possible in a “pure” way, even if it’s not entirely free of Effects, and delegating the well-isolated impure parts to the runtime system. Programmers focus on the pure logic without needing to directly deal with the impure sections. Thus, from their perspective, functional programming can still be described as “pure.”</p>
<p>This separation approach aligns with concepts like monads in Haskell, where impure computations are encapsulated and managed explicitly, enabling programmers to reason about their code as though it were purely functional.</p>
<p>Why follow referential transparency? What good comes from establishing such a strict foundation from the start?</p>
<p>※ In FP, a function without Effects is called a <strong>pure function</strong>, while a function with Effects is often referred to as an <strong>action</strong> or, sometimes, a <strong>procedure</strong> instead of a function. This distinction highlights the difference between functions that only rely on their inputs to produce outputs and those that interact with external systems (such as performing IO operations or modifying state).</p>
<p>I will show a simple procedural pseudocode.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>funcPlus v </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> v <span class="op">+</span> v <span class="op">*</span> global</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>funcMinus v</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> v <span class="op">-</span> v <span class="op">*</span> global </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>main</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  global <span class="ot">=</span> <span class="fl">1.1</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">init</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  res <span class="ot">=</span> funcPlus <span class="fu">init</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  res <span class="ot">=</span> funcMinus res</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> res </span></code></pre></div>
<p>In <code>funcPlus</code> and <code>funcMinus</code>, the necessary information is not passed as parameters, but instead is stored in and accessed via a <code>global</code> variable. These functions depend on the <code>global</code> state, which is not provided as input. This means that they are not referentially transparent, not pure functions, they have effects, and they are considered actions.</p>
<h2 id="variable-state">Variable, State</h2>
<p>In FP, global variables are not allowed. All necessary information must be passed as parameters to functions.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>funcPlus gparam v</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> v <span class="op">+</span> v <span class="op">*</span> gparam</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>funcMinus gparam v</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> v <span class="op">-</span> v <span class="op">*</span> gparam</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>main</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  global <span class="ot">=</span> <span class="fl">1.1</span> </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">init</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  res <span class="ot">=</span> funcPlus global <span class="fu">init</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  res <span class="ot">=</span> funcMinus global res</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> res </span></code></pre></div>
<p>In FP, there is no concept of variables that can store values through assignment. Unlike imperative programming, where you can assign a value to a variable like res, functional programming avoids mutating state. Instead, values are passed through functions as parameters and returned as results. Therefore, you cannot “remember” a value by assigning it to a variable; each computation is based solely on its inputs and produces outputs without altering any external state.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>main</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (funcMinus <span class="fl">1.1</span> (funcPlus <span class="fl">1.1</span> <span class="dv">0</span>))</span></code></pre></div>
<p>As in the example above, when one function finishes, its result must be immediately passed to the next function.</p>
<p>Performing an operation on data, 
passing the modified data to the next function for further processing,<br />
and so on may seem like a series of sequential steps.</p>
<p>However, if you consider the scenario before any initial value is provided - when the value does not yet exist - it reveals…</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>\<span class="fu">init</span> global <span class="ot">-&gt;</span> <span class="fu">print</span> (funcMinus global (funcPlus global <span class="fu">init</span>))</span></code></pre></div>
<p>If we write it in a way that clearly shows the empty state of the information, it looks like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>\_ _ <span class="ot">-&gt;</span> <span class="fu">print</span> (funcMinus _ (funcPlus _ _))</span></code></pre></div>
The functions are first grouped together to create a pathway. What might seem like a minor change - converting a program that relied on global variables - has been transformed into a grand effort to
<p style="font-size:1.5em; text-align: center; font-weight: bold;">
model it using only pure functions.
</p>
<p>In a Turing machine, there is a concept of state, but in the lambda calculus, there’s no place to hold a state. Sho how can the lambda calculus do everything a Turing machine can? It seems extremely cumbersome, but as shown in the example above, everything can be passed as parameters. However, it’s obvious that programming by passing global every single time is quite tedious. As the amount of dependent information increases, while theoritically possible, it becomes almost impractical in reality.</p>
<h2 id="lambda-functions-closures-higher-order-functions">Lambda Functions, Closures, Higher-Order Functions</h2>
<p>Not “<a href="https://lionhairdino.github.io/posts/2021-04-08-lambdaCalculus.html">lambda calculus</a>”, but in programming, there are sometimes documents that refer to lambda functions simply as “anonymous functions” without further explanation. Since they don’t have a name, it’s easy to assume that they can’t be called elsewhere in the program. However, looking at their usage, there are important characteristics that need to be highlighted.</p>
<p>You can make it so that when <code>x</code> is received, it returns a function instead of a value, like this.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>\x <span class="ot">-&gt;</span> (\y <span class="ot">-&gt;</span> doSomething x y)</span></code></pre></div>
<p>When you provide <code>x</code>, the function <code>\y-&gt;...</code>, which returns a function, clearly references <code>x</code>, even though <code>x</code> wasn’t directly passed as an input. This might seem like it’s not a pure function, because it looks like the function is accessing information not supplied as input. However the function <code>\y-&gt;...</code> is pure in a certain sense. Once <code>x</code> is passed in, the <code>x</code> within the function is a <strong>captured constant</strong>. it seems like it’s accessing external information, but the <code>x</code> inside the function is actually a value that has already been fixed and bound to the context. This is done without modifying the function’s body; the value of <code>x</code> is captured in the context, and when needed, it’s retrieved from there. This combination of a context and a function that references it is called <strong>closure</strong>. Inside the <code>\y-&gt;...</code>, <code>x</code> is considered a free variable because it it not bound within the lambda’s head.<br />
While this behavior may seem impure, it’s a hint for solving impure real-world tasks while still keeping the core functionalty pure!</p>
<h2 id="combinator">Combinator</h2>
<p>In lamb calculus, a lambda function without free variable is called a <strong>combinator</strong>. When reading Haskell textbooks, it’s more convenient to think of a combinator as a function that allows you to <strong>combine</strong> functions or values of a certain type. This make sense because, when a function has no free variables, it it independent of any context and can bd seen as a “combinable” element. In this sense, it essentially carries the same meaning.<br />
※ Please refer to Combinatory logic</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>\v gparam <span class="ot">-&gt;</span> v <span class="op">+</span> v <span class="op">*</span> gparam <span class="co">-- (A)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>\v gparam <span class="ot">-&gt;</span> v <span class="op">-</span> v <span class="op">*</span> gparam <span class="co">-- (B)</span></span></code></pre></div>
<p>We will define the two functions and then define a combinator to combine them as follows.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>\f g <span class="ot">-&gt;</span> \v <span class="ot">-&gt;</span> g (f v) <span class="co">-- it's the familiar concept of function composition.</span></span></code></pre></div>
<p>※ If we can combine <code>f</code> and <code>g</code> using a combinator like the one above, then <code>f</code> and <code>g</code> are also called combinators.</p>
<p>If we define it like this, there’s no way to pass <code>gparam</code>, so we need to make sure that both <code>g</code> and <code>f</code> receive <code>gparam</code> as an argment.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>\f g <span class="ot">-&gt;</span> \v <span class="ot">-&gt;</span> g gparam (f gparam v)</span></code></pre></div>
<p>Now, if we place the free variable <code>gparam</code> in the lambda head,</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>\gparam <span class="ot">-&gt;</span> \f g <span class="ot">-&gt;</span> \v <span class="ot">-&gt;</span> g gparam (f gparam v)</span></code></pre></div>
<p>Doen’t <code>\gparam</code> seem similar to the role of a <strong>global variable</strong>? The functions <code>f</code> and <code>g</code> below <code>\gparam-&gt;</code> have access to <code>gparam</code>. Once we provide a value for <code>gparam</code>, it allows us to combine the two function, and it returns a <code>\f g-&gt;...</code> function that is ready to apply <code>gparam</code> to each of the functions. By passing <code>(A)</code> and <code>(B)</code> into this function, we can achieve the desired behavior. By defining a new combinator that can combine functions with <code>gparam</code>, we can now combine(compose) these functions.</p>
<p>Although we’ve managed to achieve the desired behavior while maintaining referential transparency without using global variables, it’s easy to predict that as global informations continues to grow, it will become increasingly difficult to maintain this approach.</p>
<p>Now, even though we still need to pass <code>gparam</code>, let’s try to make it so that we don’t have to worry about it anymore.</p>
<h2 id="currying-and-partial-application">Currying and Partial application</h2>
<p>They may seem similar, but they are actually different. Passing some arguments to a function while keeping others fixed is called <strong>Partial application</strong>, while <strong>Currying</strong> refers to a higher order function that takes <strong>one argument at a time</strong> and returns a function that accepts the remaining arguments.</p>
<pre><code>\x y -&gt; x + y</code></pre>
<p>if we apply currying to the above,</p>
<pre><code>\x -&gt; (y -&gt; x + y)</code></pre>
<p>To obtain the function <code>\y -&gt; x + y</code>, you need to provide a value for <code>x</code> by passing through <code>\x</code>. If you have this function in your hands, it means the function “knows” the value of <code>x</code>. This implies that the value of <code>x</code> is present in the <strong>context</strong>.</p>
<h2 id="a-function-that-hasnt-yet-become-a-value">A function that hasn’t yet become a value</h2>
<p>By shifting the perspective, let’s change <code>funcPlus</code> and <code>funcMinus</code> so that instead of <strong>returning a value</strong>, they <strong>become functions</strong> that take <code>gparam</code> as an argument and return value. In other words, they will perform all possible operations before receiving <code>gparam</code>, and only when <code>gparam</code> is provided will they return the final value. This will ensure that the returned entity is a <strong>function that becomes a value</strong> once <code>gparam</code> is received.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>\v <span class="ot">-&gt;</span> \gparam <span class="ot">-&gt;</span> v <span class="op">+</span> v <span class="op">*</span> gparam <span class="co">-- (C)</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>\v <span class="ot">-&gt;</span> \gparam <span class="ot">-&gt;</span> v <span class="op">-</span> v <span class="op">*</span> gparam <span class="co">-- (D)</span></span></code></pre></div>
<p>Even if we insert <code>v</code>, it won’t immediately produce a value by reducing and returning it. instead, it will return a function that becomes a value only once <code>gparam</code> is provided.<br />
Now, let’s define a combinator to combine(compose) these two.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>\f g <span class="ot">-&gt;</span> (\initV <span class="ot">-&gt;</span> (\gparam <span class="ot">-&gt;</span> g ((f initV) gparam) gparam))</span></code></pre></div>
<p>It may seem a bit complicated, but we are applying <code>gparam</code> to the result of <code>f</code>, passing it to <code>g</code>, and then applying <code>gparam</code> again to the function created in this way. This is alomost the same as the combinator we defined earlier, but with the following differences.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- \gparam -&gt; (\f g -&gt; (\initV -&gt;    g gparam (f gparam initV)))</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>   \f g <span class="ot">-&gt;</span> (\initV <span class="ot">-&gt;</span> (\gparam <span class="ot">-&gt;</span>    g (f initV gparam) gparam)) <span class="co">-- (E)</span></span></code></pre></div>
<p>It’s essentially just a rearrangement of the order in which the arguments are received, and the result is the same. if we have <code>f</code>, <code>g</code>, and <code>initV</code>, we still need to receive <code>gparam</code> at the end in order to produce the final value.</p>
<h2 id="types">Types</h2>
<p>Types serve as a “language” for communicating with the compiler. To delev into type-level programming, you need to understand some quite complex properties. Of course, we’re not aiming for a extensive (formal) explanation of types here. Instead, we’ll focus on one paricular property that is often not discussed.</p>
<p>Types can be seen as one way of marking tasks that will be done later(I haven’t seen any documents that discuss this in the same way; it’s just my own imagination). They indicate that some work needs to be done, but for now, you just give it a name and move on. When the time comes, the task can be executed.</p>
<ul>
<li>As seen above, when you provide <code>initV</code>, the functions <code>(C)</code> and <code>(D)</code> will become functions that return a value only after receiving <code>gparam</code>.</li>
<li>if you combine them using the <code>(E)</code> combinator,</li>
<li>The resulting function also does not return a value when given initV; instead, it returns a function that requires <code>gparam</code> to produce a value.</li>
</ul>
<p>In haskell, it can be expressed as follows:</p>
<pre><code>data RequireG a = { runner :: gparam -&gt; a }</code></pre>
<p>For now, let’s assume we’ve named the type that requires <code>gparam</code> to produce a value as <code>RequireG</code>. if we ever need the value, we can simply run a runner that provides <code>gparam</code>.</p>
<pre><code>f :: RequireG a
g :: RequireG a
(마) :: RequireG a -&gt; RequireG a -&gt; RequireG a</code></pre>
<p>Combination! Even if there are tens or hundreds of <code>RequireG</code> functions, you can compose all of them using <code>(E)</code>. Beneath the surface, there might be an enormous number of processes, but from above the surface, it all appears as just a single function of type <code>RequireG</code>. You can use this combination of <code>RequireG</code> typed functions as a single value, and when the final value is needed, simply provide the global-like value to the <code>runner</code>.</p>
<p style="font-size:1.5em; text-align: center; font-weight: bold;">
The assembled whole is pure,<br />
but from the perspective of certain pieces, it may appear impure.
</p>
<p>Now, it seems we’re ready to dive into the final topic. so far, we’ve briefly introduced the terminology needed to discuss this part. Next, we’ll explore how to handle the results of individual functions as if they were state while composing these functions.</p>
<h2 id="state">State</h2>
<p>In FP, where there is no state, <strong>a mechanism to replace state</strong> is essential. Many of the topics in Haskell that are notorisously difficult for beginners are often tied to this concepts. What we need is a way to “effectively model” impure tasks using pure functions.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>funcPlus gparam v</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> v <span class="op">+</span> v <span class="op">*</span> gparam</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>funcMinus gparam v</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> v <span class="op">-</span> v <span class="op">*</span> gparam</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>main</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  global <span class="ot">=</span> <span class="fl">1.1</span> </span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">init</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  res1 <span class="ot">=</span> funcPlus global <span class="fu">init</span> <span class="co">-- f1</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>  res2 <span class="ot">=</span> funcMinus global res1 <span class="co">-- f2</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>  res3 <span class="ot">=</span> res1 <span class="op">+</span> res2 <span class="co">-- Each function's result is accessed separately. </span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> res3 </span></code></pre></div>
<p>Let’s look at cases where the individual results of the previously composed functions, like in the <code>res3</code> part, are needed. if this isn’t resolved, building practical programs becomes very challenging.
### How to use closures in lambda functions
In FP, it’s often said that there are no variables, but if we take a slightly different perspective, that’s not entirely true. There is one way to handle it: simply bind them in the <strong>lambda head</strong>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>\<span class="fu">init</span> global <span class="ot">-&gt;</span> <span class="fu">print</span> (funcMinus global (funcPlus global <span class="fu">init</span>))</span></code></pre></div>
<p>Let’s take the pattern where values were immediately passed to the next function and instead bind the results of each function in the lambda head.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>\<span class="fu">init</span> <span class="ot">-&gt;</span> (\res1 <span class="ot">-&gt;</span> (\res2 <span class="ot">-&gt;</span> (<span class="fu">print</span> res1 <span class="op">+</span> res2)) (funcMinus global res1)) (funcPlus global <span class="fu">init</span>))</span></code></pre></div>
<p>Let’s simplify the example by renaming the functions to <code>f1</code> and <code>f2</code> and capture their results in the lambda head.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">--       ___________________________________________</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>\<span class="fu">init</span> <span class="ot">-&gt;</span> (\res1 <span class="ot">-&gt;</span> (\res2 <span class="ot">-&gt;</span> res1 <span class="op">+</span> res2) (f2 res1)) (f1 <span class="fu">init</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">--                 ^^^^^^^^^^^^^^^^^^^^^^           </span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co">--                 Please note that you can access res1 here.</span></span></code></pre></div>
<p>To make it clearer, we can define a combinator that applies a function to a value, makeing the code more readable and simplifying the function composition.</p>
<pre><code>(&gt;&gt;&gt;&gt;&gt;) v f = f v</code></pre>
<p>You can use an <strong>infix operator</strong> to place an operation between two arguments. it can be written a <code>v &gt;&gt;&gt;&gt;&gt; f</code>.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>\<span class="fu">init</span> <span class="ot">-&gt;</span> (f1 <span class="fu">init</span>) <span class="op">&gt;&gt;&gt;&gt;&gt;</span> (\res1 <span class="ot">-&gt;</span> (f2 res1) <span class="op">&gt;&gt;&gt;&gt;&gt;</span> (\res2 <span class="ot">-&gt;</span> res1 <span class="op">+</span> res2))</span></code></pre></div>
<p>If the <strong>precedence</strong> of the <code>(&gt;&gt;&gt;&gt;&gt;)</code> operation is set to right-associative, you can omit the parentheses as shown below.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>\<span class="fu">init</span> <span class="ot">-&gt;</span> (f1 <span class="fu">init</span>) <span class="op">&gt;&gt;&gt;&gt;&gt;</span> \res1 <span class="ot">-&gt;</span> (f2 res1) <span class="op">&gt;&gt;&gt;&gt;&gt;</span> (\res2 <span class="ot">-&gt;</span> res1 <span class="op">+</span> res2)</span></code></pre></div>
<p>If <strong>function application</strong> has a higher precedence than <code>&gt;&gt;&gt;&gt;&gt;</code>, (the end of the lambda function definition corresponds to the end of the expression.)</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>\<span class="fu">init</span> <span class="ot">-&gt;</span> f1 <span class="fu">init</span> <span class="op">&gt;&gt;&gt;&gt;&gt;</span> \res1 <span class="ot">-&gt;</span> f2 res1 <span class="op">&gt;&gt;&gt;&gt;&gt;</span> \res2 <span class="ot">-&gt;</span> res1 <span class="op">+</span> res2</span></code></pre></div>
<p>Haskell defines <code>do</code> as syntactic sugar. Similary, we can define a syntactic sugar for <code>&gt;&gt;&gt;&gt;&gt;</code> and <code>\res -&gt;</code>, called <code>dolike</code>, to make the code look like the exmple below.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>job <span class="fu">init</span> <span class="ot">=</span> dolike</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  res1 <span class="ot">&lt;-</span> f1 <span class="fu">init</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  res2 <span class="ot">&lt;-</span> f2 res1</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> res1 <span class="op">+</span> res2</span></code></pre></div>
<p>We’ve now created a <strong>combination</strong> that allows us to access the results of each funtion separately, which is both conveninet and readable.<br />
This approach is similar to the way <strong>monad binds</strong> work, where each action’s individual results are stored. It’s important to clarify that we’re discussing how the monad’s bind operation stores these results, not the purpose of the monad itself, which is to handle effects. Here, we’re only focusing on one aspect of handling effects.
The Haskell <code>do</code> notation, including the use of monads, was introduced by <a href="https://en.wikipedia.org/wiki/Philip_Wadler">Philip Wadler</a>. It’s impressive how he was able to design such a system that feels so familiar and natural. The way it all fits together is truly remarkable.
(※ The person who first introduced the concept of monads in programming theory was <a href="https://en.wikipedia.org/wiki/Eugenio_Moggi">Eugenio Moggi</a>.)</p>
<p><span class="citation" data-cites="todo">@todo</span> I am trying to demonstrate how to combine actions that take <code>gparam</code>(with effects) by applying all the concepts we’ve discussed above, but I haven’t fully organized my thoughts yet. (November 2024)</p>
<h3 id="the-method-of-using-data-types">The method of using data types</h3>
<p>You can design a more explicit combinator that carries data around, rather than relying on closures.</p>
<p>Let’s consider a case where we don’t know how many functions we need to combine, so we also don’t know how many result values need to be remembered. What’s good way to represent this <strong>uncertain quantity of date</strong>?<br />
The first thing that comes to mind is the recursive data type, <strong>list</strong></p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Null</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span></code></pre></div>
<p>While a recursive data type like a list seems like the most straightforward solution (and it can work), there’s an even simpler type available.</p>
<p>Let’s look at 2-tuples. While a tuple itself is not a recursive data type, you can create a nested structure by placing tuples inside each othter. (Of course, it doen’t have to be tuples; any structure that allows nesting will work. However, among the existing structures, tuples and one of simplest.)</p>
<p>If you want to maintain the results of both <code>f a</code> and the subsequent <code>g a</code> when given <code>a</code> as input,
1. you can represent this with a 2-tuple <code>(a, a)</code>.
1. First, apply <code>f</code> to the first element: <code>(f a, a)</code>
1. Then, apply <code>g</code> to the second element: <code>(f a, g a)</code>
1. If <code>h</code> follows, you can extend it like this: <code>(f a, (g a, h a))</code>.</p>
<p>This approach is similar to the one used by Arrows.<br />
<a href="https://lionhairdino.github.io/posts/2023-09-14-arrow.html">Function combination with Arrow</a></p>
<h2 id="as-i-conclude-this-post">As I conclude this post…</h2>
<p>The goal here is not to academically understand the solutions found by many brilliant minds, but to develop the ability to recognize and appreciate them by reading practical Haskell code.</p>
<p>In this section, we did not aim to explore Monads or Arrows in their entirety, but instead looked at how they address the problems arising from pure functions. This perspective helped me understand why combinators are designed the way they are. When encountering complex combinators that are hard to grasp, it might be helpful to look for parts of the code that behave similarly to the examples dicussed above, and approach them this way.</p>
<p>Although I have not yet reached my final destination, I am opening this up early. There isn’t an article that specifically organizes this kind of content, so I hope to spark conversations with those who are interested to see where I might be wrong. I firmly believe that there is a smoother path for engineers who have only dealt with imperative programming, and I am navigation it on my own for now.</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
