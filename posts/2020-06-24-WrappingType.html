<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>lionhairdino - 갈래 길 - Int 와 Maybe Int 의 차이</title>
        <meta name="description" content="Haskell,하스켈,해스클">
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <meta property="og:type" content="website">
        <meta property="og:title" content="lionhairdino">
        <meta property="og:description" content="Haskell,하스켈,해스클">
        <meta property="og:url" content="https://lionhairdino.github.io">
    </head>
    <body>
        <div id="header">
            <div id="logo"> </div>
            <div id="navigation">
                <a href="../">lionhairdino</a> 
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
        </div>

        <div id="content">
            <h1>갈래 길 - Int 와 Maybe Int 의 차이</h1>

            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on June 24, 2020
    
</div>

<h3 id="패턴-매칭">패턴 매칭</h3>
<p>1,2,3 … 이 노는 동네와, Just 1, Just 2, Just 3 … 동네는 다르다?<br />
1에서 Just 1로 가려면 Just 생성자 함수를 쓰면 됩니다. 생성자 함수를 써서 ‘무언가’ 정보 하나를 추가해 격리된 동네로 보냅니다. 단순 꼬리표처럼 보이는 Just가 붙어 있는 값들은 Maybe 동네에서만 있을 때는 ‘무언가’ 정보가 드러나지 않지만, 격리된 동네를 벗어나서 다른 값들과 어울리려면 그 때 ‘무언가’ 정보가 드러나게 됩니다. 갈 때 생성자 함수를 썼듯이, 올 때도 그냥 드러나는게 아니라, 반드시 어떤 작업을 통해서 드러나게 됩니다. 달리 표현하면, Maybe는 ‘무언가’ 정보가 드러나려면 어떤 작업이 필요한 타입이란 뜻입니다. 모든 래핑 타입은 ‘무언가’ 정보를 추가하기 위한 타입입니다. ’무언가’를 꺼내는 방법은, 반드시</p>
<p>“Just값, Nothing <em>갈래 길 중 어디로 갈지 선택</em>(분기)하는 작업”</p>
<p>을 통해서만 꺼낼 수 있습니다. 다른 방법은 없습니다. Maybe 값을 꺼내 오려면(다른 말로 Maybe 특징이 발현되려면) 코드 어딘가에는 반드시 분기문이 존재합니다. 어떤 경우에는 직접 길을 고르고, 어떤 경우에는 미리 만들어 놓은 함수(fmap)를 쓰기도 합니다. if 를 쓰든, case 를 쓰든 분기 작업을 해야합니다. 하스켈에서 가장 많이 쓰이는 분기문은 if 도 아니고, case 도 아니고, 바로 <em>패턴 매칭</em>입니다. fmap 함수도 패턴 매칭으로 갈 길을 선택합니다. 함수 정의부에서 패턴 매칭 할 수도 있고, case 구문에서 할 수도 있고, let 구문이나 &lt;- 구문으로 패턴 매칭할 수도 있습니다. 어디가 됐든, 반드시 “갈래 길 중 선택”하는 구문은 반드시 나타납니다.</p>
<p>하스켈로 연습 문제를 푸는 수준을 넘어가면 수 많은 래핑 타입들로 로직을 설계합니다. 한 번만 싸인게 아니라, 생성자들로 여러번 싸여 있는 값들을 만나게 됩니다. 그 생성자를 풀 때마다 특정 작업을 하도록 되어 있다고 보면 됩니다.</p>
<h3 id="타입-클래스">타입 클래스</h3>
<p>타입을 래핑하는 또 다른 목적은, 같이 쓰일 함수를 고르는 작업을 위해서입니다. <em>타입 클래스와 인스턴스</em>를 쓰면, 타입에 따른 함수를 고를 수(분기) 있습니다. 함수를 실행할 때, 또 한 번 분기가 일어난다고 볼 수 있습니다. [1]</p>
<p>이 포스트의 결론은, a와 래핑 a의 다른 점은 “래핑은 갈래 길(코드의 분기)을 내포하고 있다”입니다.</p>
<hr />
<p>[1] 타입에 따라 인스턴스를 고르니, 타입과 함수를 연관 짓는 함수로 볼 수 있습니다. 어떤 것과 어떤 것을 연관 지어 놓는 걸 함수라고 하는데, 어떤 것을 연관 짓냐에 따라 이름을 달리 붙여 놨습니다.</p>
<p>타입과 타입을 매핑 = 함수<br />
타입과 함수를 매핑 = 타입 클래스<br />
함수와 함수를 매핑 = 펑크터<br />
펑크터와 펑크터를 매핑 = Natural Transform</p>

<div id="disqus_thread" style="padding-top:40px"></div>
<script>

var disqus_config = function () {
this.page.url = 'https://lionhairdino.github.io/posts/2020-06-24-WrappingType.html';
this.page.identifier = 'posts/2020-06-24-WrappingType.markdown';
};
(function() {
var d = document, s = d.createElement('script');
s.src = 'https://lionhairdino.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
        </div>
        <div id="footer">
            © 2020 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
