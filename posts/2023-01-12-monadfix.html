<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - MonadFix</title>

        <meta name="description" content="mfix (monadfix) 동작을 쉽게 이해하는 방법을 찾고 있습니다." />
        <meta property="og:description" content="mfix (monadfix) 동작을 쉽게 이해하는 방법을 찾고 있습니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="MonadFix" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-01-12-monadfix.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/fibonacci.jpg" />

      <meta name="keywords" content="monadfix, monad, fix, 고정점, 재귀, fix point, RecursiveDo, mdo, mfix, monadic fix, cyclic definition, 순환 정의, 하스켈, haskell, 함수형, Functional">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
<meta name="fediverse:creator" content="@lionhairdino@mastodon.social">
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px"></div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:20px;border:none" src="../images/bluesky.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://discordapp.com/users/lionhairdino#7687"><img style="width:20px;border:none" src="../images/discord.svg"></a></div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>MonadFix</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on January 12, 2023
    
</div>

<p><a href="https://wiki.haskell.org/MonadFix">하스켈 위키 - MonadFix</a><br />
<a href="https://elvishjerricco.github.io/2017/08/22/monadfix-is-time-travel.html">MonadFix is Time Travel - Will Fancher</a><br />
<a href="https://leventerkok.github.io/papers/recdo.pdf">A Recursive do for Haskell</a><br />
</p>
<p><strong>“자기가 반환하는 값을 인자로 받아서 실행”</strong></p>
<blockquote>
<p><strong>생각 스트레칭</strong><br />
“미래값을 바꾸는 미래값을 요구하는 역설paradox”<br />
무한이라든지, 아직은 없는 미래값이라든지 하는 말들을 보면, 머릿속에서 시뮬레이션하기 까다로워서 불편합니다. 불편한 이유는 우리가 너무 부지런해서 입니다. 값이 아직 다 필요하지도 않은데, 무한히 준비할 생각부터 하고, 미래값이 아직 필요하지도 않은데, 무슨 값일지 걱정해서 그렇습니다. 사실 이들 개념들은 적절히 <strong>파트너</strong>로 동작하는 함수들이 있거나, 아니면 알고 보니 알 <strong>필요 없는 값</strong>이다라는 식으로 동작합니다. 무한 리스트값들은 <code>take</code> 같은 함수들이 파트너로 반드시 있어야 실용적인 의미가 생기는 것처럼 말입니다. <code>f undefined</code>를 적절한 파트너와 함께 써서 오류없이 결과값을 얻을 수 있다면(해당 인자를 평가하는 순간 undefined 오류가 나는데, 특정 조건하에선 평가할 일이 없다면), <code>fix</code>에 넣어 줄 수 있습니다.</p>
</blockquote>
<p>현실적으로 내가 아직 만들지도 않은 결과를 내가 참조할 수는 없습니다. 그런 일은 일어나지 않습니다. 패러독스 해결은 제3자가 개입하거나, 단계를 나누는 방법이 있을 수 있습니다.</p>
<p>시간이 개입하면 어찌되나 보겠습니다. 모두 <strong>동작은 같은 <code>f</code>지만, 다른 시점에 동작한 <code>f</code>는 다르다</strong>는 뜻으로 번호를 붙여 보겠습니다. - <span class="citation" data-cites="todo">@todo</span> 편하게 생각할 방법을 고민 중입니다.<br />
<code>fix f = f1 (f2 (f3 ...</code><br />
<code>f1</code>은 <code>f2</code>의 결과를 받아 계산합니다. ※ <code>f2</code>가 <code>f1</code>과 다른 것이라 생각하면 좀 낫지 않나요?<br />
하나 주의해서 볼 게, <code>f1 (f2 (f3 (...)))</code>는 함수 상태가 아닙니다. 어찌 됐든, 무한이긴 하지만, 미래의 값이긴 하지만, 인자를 준 상태입니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>[1..] = fix (\xs -&gt; 1 : fmap (+1) xs)  </span></code></pre></div>
<p><code>xs</code>는 다른 시간(미래)의 <code>f</code>의 결과값입니다. 어떤 값을 가질지는, 늘 그렇듯 Lazy하게 필요할 때 보면 됩니다. 처음 결과는 <code>1 : ...</code>값입니다. 아는데 까지만 써주고, 모르는 건 모르는 채로 두면 됩니다. <code>1</code>만 필요하다면 여기서 끝이지만, <code>...</code> 부분을 알고 싶다면, <strong><em>또 다른 f</em></strong>를 실행하면 됩니다. 이제 <code>...</code>을 알기 위한 <code>현재 f</code>는 <code>미래 f</code>의 결과값 <code>1 : ...</code> 값을 가지고 실행하면 적어도 <code>1 : (1 + 1) : ...</code>까지는 알 수 있는 상태가 됩니다. 반복하면, (<code>fmap (+1)</code>을 적용한 걸 <code>+1</code>로 표기) <code>1 : 1+1 : 1+1+1 : 1+1+1+1 : ...</code>이 나옵니다. 파트너 <code>take</code>와 같이 쓰면,</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>ghci&gt; take 5 $ fix (\xs -&gt; 1: fmap (+1) xs)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>[1,2,3,4,5]</span></code></pre></div>
<p>전혀 알 수 없는 미래값에 대해선 위와 같이 할 수 없습니다. 미래값에 의존해서 실행한 함수 결과에는 적어도 <code>1:</code>이 들어가 있는 걸 알기 때문에 벌어지는 일입니다. 미래값이 뭔지 모르는데, 현재에서 미래값을 참조하는 일이 어떻게 의미를 가질까의 비밀은 여기 있는 건지도 모르겠습니다. 어떤 미래값으로 돌리든 예정되어 있는 일부 결과 모양을 알아야만 cyclic 정의가 의미가 있습니다.</p>
<p>또 다른 예시로, 피보나치 수를 fix로 구하는 걸 보겠습니다.</p>
<p><code>fix (\fib -&gt; 0 : 1 : zipWith (+) fib (tail fib))</code></p>
<p>매직이 일어나는 것처럼 보이지만, 사실은 미래 결과를 받아서 돌린다 한들 알 수 있는 건 <code>0</code>과 <code>1</code>만 있을 뿐입니다.</p>
<figure>
<img src="../images/fibonacci.jpg" alt="0과 1로 만드는 피보나치" />
<figcaption aria-hidden="true">0과 1로 만드는 피보나치</figcaption>
</figure>
<div class="sourceCode" id="cb3"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>0:1:&lt;thunk&gt; ----------- f -----------&gt; 0:1:&lt;thunk&gt;</span></code></pre></div>
<p><code>f</code>가 인자로 <strong>자신의 결과값</strong>을 받아서, 한 번 실행하면 <code>0:1:&lt;thunk&gt;</code>결과를 얻습니다. 미래의 자신이 돌리든, 과거의 자신이 돌리든, 결과에 <code>0:1</code>이 있는 것만은 알고 있다는 뜻입니다. <code>f</code>가 받는 인자도 <code>0:1:&lt;thunk&gt;</code>고, 결과값도 <code>0:1:&lt;thunk&gt;</code>입니다. <code>f a = a</code>로 말하면 <code>f</code>에 입력으로 준 것도 <code>a</code>이고, 결과도 <code>a</code>입니다. 이 때 <code>a</code>를 고정점이라 부릅니다. <code>fix f</code>로 <code>0:1:&lt;thunk&gt;</code>를 얻었는데, 이 걸 <code>f</code>의 입력값으로 <code>f (fix f)</code> - <code>f(0:1:&lt;thunk&gt;)</code> 다시 넣어줘도 인자와 결과값 둘이 같다는 뜻입니다. <code>f</code> 함수의 고정점은 <code>fix f</code>입니다.</p>
<p><code>&lt;thunk&gt;</code>를 평가할 일이 생기면, 또 다시 <code>f</code>를 실행해서 얻은 결과를 <code>zipWith (+) [0,1,&lt;thunk&gt;] [1,&lt;thunk&gt;]</code> 하는 절차가 한 번씩 돌고 있습니다.</p>
<p><strong>f</strong><code>(f(f(...)))</code> = <code>(f(f(...)))</code> 이란 뜻입니다. <strong>f를 적용하나 안하나 같은 값</strong>을 찾는다면, 명쾌하기도 하고, 허탈하기도 한 <code>f</code>가 무한히 적용되어 있는 값을 고르면 된다는 뜻입니다. 단, <code>fix f</code>가 유일한 고정점이라 말하는 건 아닙니다.</p>
<p>여기까지가 <code>fix</code>의 동작 요약입니다. 이제 <code>mfix</code>로 넘어가 보겠습니다.</p>
<h2 id="mfix">mfix</h2>
<p>값 재귀를 위해 <code>mfix</code> 메소드를 정의합니다. 직접 <code>mfix</code>를 쓰는 경우도 있고, <code>RecursiveDo</code> 확장을 통해 사용되기도 합니다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadFix</span> m <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  mfix ::</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>먼저 타입으로만 추측하여 읽어 보면,</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fix  ::</span> (a <span class="ot">-&gt;</span>   a) <span class="ot">-&gt;</span>   a</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">mfix ::</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</span></code></pre></div>
<blockquote>
<p>MonadFix is just a monadic version of fix</p>
</blockquote>
<p><a href="../posts/2020-07-07-fix.html">fix f</a>의 결과는 <code>f(f(f(f...</code> 이런 모양이 되니, <code>mfix f</code>도 아마 <code>f(f(f(f...</code> 이런 모양일텐데, 한 겹 넘어갈 때마다 effect <code>m</code>을 어찌하고 있는지만 찾으면 될 것만 같습니다. (뒤에 잘못된 접근인 걸 보입니다.) <code>fix</code>는 일반 함수지만, <code>mfix</code>는 <code>MonadFix</code>클래스의 메소드로 타입마다 다른 인스턴스를 가지고 있습니다. 그런데, 특정 모나드에서는 아래 코드로 해결할 수도 있습니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>mfix f <span class="ot">=</span> fix (<span class="op">&gt;&gt;=</span> f)</span></code></pre></div>
<p>단, <code>fix</code>함수는 인자가 strict인 함수를 받지 못하기 때문에, <code>(&gt;&gt;=)</code>가 strict한 인스턴스에선, 이 <code>mfix</code>를 쓸 수 없습니다. <code>fix</code>함수는 <code>(a -&gt; a) -&gt; a</code>타입이니, <code>(&gt;&gt;=):m a -&gt; (a -&gt; m b) -&gt; m b</code>에 두번 째 인자로 <code>f:a -&gt; m a</code>를 줘서 <code>(&gt;&gt;= f):m a -&gt; m a</code>로 만드니, <code>fix</code>에 넣어 줄 수 있습니다.</p>
<p><code>Maybe</code>의 경우 아래같이 돌리면 무한으로 가버립니다.<br />
(무한으로 가지 않는 <code>mfix</code> 인스턴스가 이미 정의되어 있어, 여기서는 <code>mfix'</code>으로 이름지었습니다. )</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>mfix' f <span class="ot">=</span> fix (<span class="op">&gt;&gt;=</span> f)</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>ghci&gt; mfix' $ \_ &gt; Just 1 -- 원래 mfix는 Just 1이 나온다.</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>&lt;무한 실행&gt;</span></code></pre></div>
<p><code>mfix</code>는 <code>(((...) &gt;&gt;= f) &gt;&gt;= f) &gt;&gt;= f</code> 이런 모양이 나옵니다. 차근 차근 쫓아가 보겠습니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>mfix' (\_<span class="ot">-&gt;</span><span class="dt">Just</span> <span class="dv">1</span>) <span class="ot">=</span> fix (<span class="op">&gt;&gt;=</span> (\_<span class="ot">-&gt;</span><span class="dt">Just</span> <span class="dv">1</span>))</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                   <span class="ot">=</span> (<span class="op">&gt;&gt;=</span> (\_<span class="ot">-&gt;</span><span class="dt">Just</span> <span class="dv">1</span>)) (fix (<span class="op">&gt;&gt;=</span> (\_<span class="ot">-&gt;</span><span class="dt">Just</span> <span class="dv">1</span>))) <span class="co">-- 편의상 표기</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                   <span class="ot">=</span> (fix (<span class="op">&gt;&gt;=</span> (\_<span class="ot">-&gt;</span><span class="dt">Just</span> <span class="dv">1</span>))) <span class="op">&gt;&gt;=</span> (\_<span class="ot">-&gt;</span><span class="dt">Just</span> <span class="dv">1</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                   <span class="ot">=</span> ((<span class="op">...</span>) <span class="op">&gt;&gt;=</span> (\_<span class="ot">-&gt;</span><span class="dt">Just</span> <span class="dv">1</span>)) <span class="op">&gt;&gt;=</span> (\_<span class="ot">-&gt;</span><span class="dt">Just</span> <span class="dv">1</span>)</span></code></pre></div>
<p>눈에는 <code>(\_-&gt;Just 1)</code>이란 게 보이니, 뭐가 됐든 <code>Just 1</code>이 나올테니, Lazy하게 볼 수 있다면 굳이 미래를 모두 평가할 필요가 없는 게 보입니다. Fancher의 글에선 <code>(...)</code>부분을 미래라 말하고 있습니다. 가장 먼 미래에서 시작해서 무한히 <code>&gt;&gt;= (\_-&gt;Just 1)</code>을 반복하는 것으로 해석할 수 있습니다. <code>mfix'</code>은 <code>...</code>부분에 <code>Nothing</code>이 있는지 계속 찾아야만 합니다. 그래서 무한 실행에 빠지고, 마찬가지로 <code>IO</code>도 무한 실행하지만 스택이 꽉 차버립니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>ghci&gt; mfix' (\_ -&gt; print 1)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>*** Exception: stack overflow</span></code></pre></div>
<p>인스턴스 정의 목록을 보면, <code>IO</code>, <code>Maybe</code>, <code>[],</code> <code>ST</code>, <code>Either</code> 등 많은 수가 별도의 인스턴스를 정의하고 있습니다. 바인드들에게 <code>undefined</code>를 주며 테스트 해 볼 수 있는데, 조금 사례를 찾아보니 <code>Reader</code> 모나드 바인드 정도는 <code>mfix'</code>으로 가능했습니다. 결론에서 추가로 설명하겠습니다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ghci&gt; flip runReader 0 $ undefined &gt;&gt;= \_ -&gt; reader (\_ -&gt; 1)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>ghci&gt; flip runReader () $ mfix' $ \_ -&gt; reader(\_ -&gt; 1)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>ghci&gt; runWriter $ undefined &gt;&gt;= \_ -&gt; writer (2,&quot;b&quot;)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>(2,&quot;*** Exception: Prelude.undefined</span></code></pre></div>
<p>처음엔, <code>fix</code>와 유사한 동작을 할 것이다란 생각으로 위와 같이 접근했는데, <code>mfix</code>의 목적이 <code>a -&gt; m a</code>의 고정점을 찾는 게 아닙니다.</p>
<h2 id="왜-필요하지">왜 필요하지?</h2>
<p><code>mfix</code>는 <code>fix</code>의 모나딕 버전이니, 이펙트가 있는 작업 즉, 액션을 반복시킬 때 쓰겠거니 생각할 수 있는데, 액션 반복은 <code>fix</code>로도 됩니다. 아래 코드는 <a href="https://ro-che.info/articles/2015-09-02-monadfix">Roman Cheplyaka - MonadFix example</a>에서 발췌했습니다.<br />
※ <code>fix f</code>에서 <code>f</code>가 받는 함수가 <code>m a -&gt; m a</code>일 뿐(<code>a -&gt; a</code>에서 <code>a</code>자리에 <code>m a</code>)입니다. 아래 <code>\repeat</code>가 받는 값은 <code>m a</code>입니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>guessNumber m <span class="ot">=</span> fix <span class="op">$</span> \<span class="fu">repeat</span> <span class="ot">-&gt;</span> <span class="kw">do</span> <span class="co">-- 액션도 fix로 반복할 수 있습니다.</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Enter a guess&quot;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> readMaybe <span class="op">&lt;$&gt;</span> <span class="fu">getLine</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n <span class="op">==</span> <span class="dt">Just</span> m</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="fu">putStrLn</span> <span class="st">&quot;You guessed it!&quot;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>      <span class="fu">putStrLn</span> <span class="st">&quot;You guessed wrong; try again&quot;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>      <span class="fu">repeat</span></span></code></pre></div>
<p><code>\repeat</code>이 받는 함수가 <code>a -&gt; m b</code>로 오해할 수 있는데, 아래와 같은 상황입니다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>ghci&gt; let f = \repeat -&gt; do repeat </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>ghci&gt; f $ print 1 -- IO ()를 받고 있다.</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>1</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>ghci&gt; :t f</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>f :: p -&gt; p</span></code></pre></div>
<p><code>fix</code>만으로 무리 없이 돌아갑니다. 그럼 아래같이 피보나치수를 구하는 경우는 어떨까요?<br />
※ 비교 <code>fib = 0 : 1 : zipWith (+) fib (tail fib)</code></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>fibIO1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Enter the start number&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  start <span class="ot">&lt;-</span> <span class="fu">read</span> <span class="op">&lt;$&gt;</span> <span class="fu">getLine</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> start <span class="op">:</span> <span class="dv">1</span> <span class="op">:</span> <span class="fu">zipWith</span> (<span class="op">+</span>) fibIO1 (<span class="fu">tail</span> fibIO1)</span></code></pre></div>
<p>타입 체커를 통과하지 못합니다. <code>fibIO1</code>은 리스트가 아니라, 리스트를 만들어 내는 액션입니다.</p>
<p>이제 <code>mfix :: MonadFix m =&gt; (a -&gt; m a) -&gt; m a</code>를 써보겠습니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>fibIO3 <span class="ot">=</span> mfix <span class="op">$</span> \fib <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Enter the start number&quot;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  start <span class="ot">&lt;-</span> <span class="fu">read</span> <span class="op">&lt;$&gt;</span> <span class="fu">getLine</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> start <span class="op">:</span> <span class="dv">1</span> <span class="op">:</span> <span class="fu">zipWith</span> (<span class="op">+</span>) fib (<span class="fu">tail</span> fib)</span></code></pre></div>
<p>위에 <code>fix</code> 예시에서 그랬던 것처럼 <code>fix (&gt;&gt;=f)</code>에서 <code>(&gt;&gt;=f)</code>는 계속 실행되어, 실행될 때마다 <code>"Enter the start number"...getLine</code>이 돌아 계속 입력을 받게 될까요?</p>
<p>※ 순환cyclic정의를 할 때 <a href="https://wiki.haskell.org/Tying_the_Knot">Tying the Knot</a>이란 동작이 있습니다. Lazy하게 동작하니, 필요한 곳까지만 가면 됩니다. 이 필요한 곳을 매듭knot이라 부릅니다.</p>
<p>위 <code>fibIO</code> 예시 자체가 살짝 억지스럽긴 합니다만, 동작을 보는데 문제는 없습니다. 원하는 동작은 이펙트를 만들어내는 액션 동작은 딱 한 번만 실행되고(effectful하게 외부에서 start값을 입력받습니다.), 그 후에는 액션이 아닌 값만 가지고 반복해야 합니다. 마치 <code>\fib -&gt; ...</code> 에서 <code>...</code> 부분이 통채로 반복될 것만 같은 겉모양인데, <code>\fib</code>에는 미래 함수의 결과값 <code>start : 1 : zipWith (+) fib (tail fib)</code>가 들어가긴 할텐데, 그 미래 함수가 실행될 때 <code>getLine</code>이 또 실행되어야 하는 것 아닐까 혼란스럽습니다. 그렇게 동작하는 건 바로 <code>fix</code>함수가 <code>m a -&gt; m a</code>를 받았을 때의 동작입니다.</p>
<p><code>mfix</code>는 <code>a -&gt; m a</code>를 위해서 만들었습니다. 그런데, <code>fix</code>가 <code>a -&gt; a</code>를 받아 고정점을 찾듯, <code>a -&gt; m a</code>의 고정점을 찾는게 아니라, 인포멀하게 얘기하면 <code>m</code>을 한 번만 동작하게 하고, <code>m</code>을 제외한 <code>a -&gt; a</code>의 고정점을 찾는 게 목적입니다.</p>
<p>위 <code>fibIO3</code>에서 보면, <code>mfix</code>가 <code>(a -&gt; m a)</code>를 받아야 하니 <code>\fib</code>로 들어 오는 건 <code>m a</code>가 아니라 <code>a</code>입니다. <code>"Enter the start number"</code> 같은 이펙트풀한 동작이 없을 거라 예상할 수 있습니다. 실제 동작을 보기 위해, 실제 라이브러러리에 있는 <code>IO</code> 인스턴스 구현을 보겠습니다.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Control.Monad.Fix</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadFix</span> <span class="dt">IO</span> <span class="kw">where</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    mfix <span class="ot">=</span> fixIO</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="ot">fixIO ::</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>fixIO k <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    m <span class="ot">&lt;-</span> newEmptyMVar <span class="co">-- mutable 변수를 만들고,</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    ans <span class="ot">&lt;-</span> unsafeDupableInterleaveIO <span class="co">-- 미래 값을 예측하고</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>             (readMVar m <span class="ot">`catch`</span> \<span class="dt">BlockedIndefinitelyOnMVar</span> <span class="ot">-&gt;</span> <span class="co">-- 블록 에러 패턴매칭</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>                                    throwIO <span class="dt">FixIOException</span>)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    result <span class="ot">&lt;-</span> k ans <span class="co">-- 미래값 ans에 k를 적용한 후, result에 effect없는 값을 넣고 있다.</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- 이 값은 완성된 결과값이 아니라, 일부만 알고 있는 결과로,</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    putMVar m result <span class="co">-- 미완성 값을 넣어 놓는다. MVar 안에는 액션이 아닌 값result이 들어 있다. </span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> result</span></code></pre></div>
<p><strong>unsafeDupableInterleaveIO :: IO a -&gt; IO a</strong><br />
<code>IO</code> 컴퓨테이션을 Lazy하게 할 수 있습니다. <code>IO a</code> 타입을 받고, <code>a</code>를 요구demand하는 곳이 있을 때 계산을 합니다. <code>readMVar</code>의 반환값은 <code>IO a</code>로 이 <code>a</code>가 필요한 순간이 되어야만 <code>readMVar</code>를 실행합니다. <code>ans</code>는 <code>thunk</code>를 받은 상태입니다.</p>
<p>어디선가 <code>ans</code>가 평가될 때 <code>readMVar</code>가 실행될 겁니다.</p>
<p><code>fibIO3</code>은 <code>return (start : 1 : zipWith (+) fib (tail fib))</code>를 반환합니다. 어디선가 <code>zipWith~</code> 부분에 대한 요구demand가 생겨 평가하게 되면, <code>fib</code>는 <code>MVar</code>에 저장해 두었던 미래 함수의 결과<code>ans</code>를 가져 옵니다. 그 미래 함수의 결과는 또 더 미래 함수의 결과를 참조하고 있습니다. (하지만, 미래의 완전히 알 수 없는 어떤 값이 아니라, 미래에 생길 값에 대해 일부는 알고 있습니다.)</p>
<p><code>k</code>에 <code>\fib -&gt; do ... return $ ... zipWith (+) fib (tail fib)</code>를 넣어주면, <code>\fib</code>에는 나중에 결정될 미래값 <code>ans</code>가 들어갑니다. 이 후 일들은 <code>return</code> 안 쪽에서 일어나는 일들입니다. (<code>start</code>로 <code>0</code>을 넣었다 치면) <code>return $ 0:1:&lt;thunk&gt;</code>을 했습니다. 어디선가 패턴매칭이 일어나서 <code>&lt;thunk&gt;</code>를 평가하려 들면, <code>zipWith (+) [0,1,&lt;thunk&gt;] [1,&lt;thunk&gt;]</code>을 평가합니다. 그럼 다음 원소 <code>1</code>을 돌려 주고, 또 <code>&lt;thunk&gt;</code>로 다음을 대기합니다. 더 달라고 하면 또 <code>[0,1,&lt;thunk&gt;]</code>에 있는 <code>&lt;thunk&gt;</code>와 <code>[1,&lt;thunk&gt;]</code>에 있는 <code>&lt;thunk&gt;</code>를 평가하게 될 겁니다. 위에 피보나치 그림 참고. <code>MVar</code>는 순서대로 평가되는 <code>IO</code>에서 아직 없는 값을 표현하기 위한 수단입니다.</p>
<p>아직은 간단히 설명을 못하고 있는데, 아래 예시와 같은 상황입니다. <code>repeat</code>는 <strong>이펙트 없이</strong> 무한 반복할 거라 해놨습니다. 하지만, 미리 동작하진 않고 나중에 <code>take</code>가 달라면, 달라는 만큼만 동작하고, 여전히 무한히 동작할 상태(<code>&lt;thunk&gt;</code>)에 머무릅니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>ghci&gt; result &lt;- return $ repeat 1</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>ghci&gt; take 10 result </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>[1,1,1,1,1,1,1,1,1,1]</span></code></pre></div>
<p>인포멀하게 얘기하면, <code>fixIO</code> 전체가 아니라, 오직 <code>k ans</code> 부분만 반복한다는 말입니다.</p>
<h2 id="mdo">mdo</h2>
<p><a href="https://wiki.haskell.org/MonadFix"><strong>Imperative cyclic linked lists</strong></a> 하스켈 위키에 있는 예시를 보겠습니다.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Node</span> <span class="ot">=</span> <span class="dt">Node</span> <span class="dt">Int</span> (<span class="dt">IORef</span> <span class="dt">Node</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>mknode <span class="ot">=</span> mfix (\p <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    p' <span class="ot">&lt;-</span> newIORef (<span class="dt">Node</span> <span class="dv">0</span> p)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;node created&quot;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> p')</span></code></pre></div>
<p>첫 번째 노드까지만 알면 되면 <code>(Node 0 &lt;thunk&gt;)</code>에서 평가를 멈출테고,<br />
다음을 요구한다면, 안에 있는 <code>&lt;thunk&gt;</code>를 평가해서 <code>(Node 0 (Node 0 &lt;thunk))</code>이 됩니다. 마치 이미 만들어진 값이 아니라, 제너레이터를 품고 있는 느낌입니다.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> mknode</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Node</span> x q <span class="ot">&lt;-</span> readIORef p <span class="co">-- Node 0 &lt;thunk&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> x <span class="co">-- 0 출력</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Node</span> y _ <span class="ot">&lt;-</span> readIORef q <span class="co">-- 위 &lt;thunk&gt;를 평가한 결과는 Node 0 &lt;thunk&gt;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> y <span class="co">-- 0 출력</span></span></code></pre></div>
<p>이제 다음 예시가 실용에서 많이 만날 동작입니다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>mk2nodes <span class="ot">=</span> mfix (\ <span class="op">~</span>(p,r) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    p' <span class="ot">&lt;-</span> newIORef (<span class="dt">Node</span> <span class="dv">0</span> r)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    r' <span class="ot">&lt;-</span> newIORef (<span class="dt">Node</span> <span class="dv">1</span> p')</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;nodes created&quot;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (p',r'))</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;&gt;=</span> \(p,r) <span class="ot">-&gt;</span> <span class="fu">return</span> p</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- 보기 좋게 한 줄로 축약해서 보면 mfix (...) &gt;&gt;= \(p,r) -&gt; return p 모양입니다.</span></span></code></pre></div>
<p>※ 인자에 붙은 틸드<code>~</code>는 Lazy하게 평가하겠다는 뜻입니다.<br />
미래값 <code>r</code>을 다음으로 하는 노드 <code>p'</code>을 만들고,<br />
<code>p'</code>을 다음으로 하는 노드 <code>r'</code>을 만들고,<br />
미래값 <code>p</code>에는 <code>p'</code>을, <code>r</code>에는 <code>r'</code>을 넣어 줍니다.<br />
</p>
<p>cyclic이 잘 보이게 미래값을 받은 상태로 읽는다면,<br />
<code>r</code>을 다음으로 하는 <code>p</code>를 만들고<br />
<code>p</code>를 다음으로 하는 <code>r</code>을 만들었습니다.</p>
<p><strong>순환cyclic 정의를 하고 있습니다.</strong></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> mk2nodes</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Node</span> x q <span class="ot">&lt;-</span> readIORef p</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> x</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Node</span> y r <span class="ot">&lt;-</span> readIORef q</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> y</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Node</span> z _ <span class="ot">&lt;-</span> readIORef r</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> z</span></code></pre></div>
<p>앞으로 <code>mfix</code>를 쓰려면 습관적으로 미래값에 대응될 값들을 <code>p'</code>, <code>r'</code> 식으로 쓰면 좋을 것 처럼 보입니다.<br />
바로 이를 위한 Syntactic sugar <code>mdo</code>가 있습니다. <code>do</code>를 쓸 자리에 <code>mdo</code>를 쓰면 <code>mfix</code>를 돌려 cyclic 정의를 하겠다는 뜻입니다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>mknode <span class="ot">=</span> mdo</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> newIORef (<span class="dt">Node</span> <span class="dv">0</span> p)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;node created&quot;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> p</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>mk2nodes <span class="ot">=</span> mdo</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  p <span class="ot">&lt;-</span> newIORef (<span class="dt">Node</span> <span class="dv">0</span> r)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  r <span class="ot">&lt;-</span> newIORef (<span class="dt">Node</span> <span class="dv">1</span> p)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;nodes created&quot;</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> p</span></code></pre></div>
<p>이제 <strong><em>정의 순서와 상관없이 do 안에서 바인딩을 cyclic하게 쓸 수 있게 됐습니다.</em></strong></p>
<p><code>do</code> 안에서도 순환 정의를 하겠다고, 이렇게 독하게 체계를 만들어 낸 사람들이 존경스럽습니다.</p>
<h2 id="결론">결론</h2>
<p><del>“mfix는 액션 전체가 아니라, 결과값만 재귀시켜도 될 때만 의미가 있습니다.”</del><br />
<strong>“mfix는 액션 전체가 아니라, 컨텍스트 안에 있는 결과값만 재귀시키기 위해 만들었습니다.”</strong></p>
<p><code>mfix</code>로 <code>a -&gt; m a</code>함수를 감싸면, <code>m</code>은 한 번만 영향을 미치고, <code>m</code>이 없는 <code>a -&gt; a</code>를 재귀 돌려 <code>m (재귀 결과)</code>값을 반환합니다.</p>
<p>처음 개념을 봤을 때는,</p>
<blockquote>
<p><strong>※ 잘못된 접근</strong> - 아래는 틀린 내용입니다.<br />
애초에 액션 <code>a -&gt; m a</code>는 고정점이 있을 수가 없습니다. <code>a</code>를 입력 받고, 출력으로 <code>m a</code>를 내뱉으니 있을 수가 없습니다. 그런데 모나드에서 처럼 <code>m a -&gt; m (m a)</code>로 보고, <code>join</code>이 존재한다면 고정점(고정점이라 우길 수 있는 것)을 찾을 수 있을 겁니다. (모나드에서 <code>a -&gt; m b</code> 액션에 <code>m a</code>를 넣어줘서 <code>m (m b)</code>가 나오면 <code>join</code>을 해서 <code>m</code>으로 맞춰 줬습니다.) <code>join</code>을 <code>μ</code>로 표기하면</p>
<p><code>f(μf(μf(...)))</code> = <strong><em>f(μ</em></strong><code>f(μf(μf(...)))</code><strong><em>)</em></strong></p>
<p>이런식으로 반복하게 될겁니다. 근데 이 때 <code>μ</code>가 계속 스택을 잡아 먹거나, 혹은 계속 인과관계가 있다면, 정보를 무한히 갖고 있어야 하니 의미 있는 일을 할 수 없을 겁니다. <code>μ</code>가 trivial한 일을 하는 거라 (<code>Reader</code>같은 것들) 마지막에 한 번만 해줘도 되는 것들이라면, 즉 <code>m a -&gt; m (m a)</code> 에서 <code>a -&gt; a</code>로만 무한 반복 시키고 <code>m</code>(<code>return</code>)을 나중에 한 번만 붙여도 의미가 달라지지 않는 것들만 <code>mfix</code>가 가능하다고 보고 있습니다.</p>
</blockquote>
<p>라고 <strong><em>오해 했습니다.</em></strong></p>
<p>이론상은 <code>fix (&gt;&gt;= f)</code>가 <code>mfix</code> 구현이고, 이 걸로 그냥 돌리면 무한히 실행되어 의미가 없을 때, 무한히 돌지 않아도 의미 있는 결과를 내는 <code>mfix</code>를 별도로 만든 게 아니라, <code>mfix</code>는 컨텍스트 안에 있는 값을 재귀 시키기 위한 것입니다.</p>
<p>“Value Recursion <strong><em>in</em></strong> Monadic Computations”</p>
<p>이펙트가 여러번 발현되든, 한 번 발현되든 의미가 다르지 않은 일부 모나드에선 이 동작을 <code>fix (&gt;&gt;= f)</code>로 써도 같은 동작을 한다는 뜻이지, 모든 모나드의 <code>mfix</code>가 <code>fix (&gt;&gt;= f)</code>와 같은 동작을 한다는 얘기가 아닙니다. (검증 필요)</p>
<p>MonadFix의 아래 성질이 오해한 부분을 명확히 보여 주는 것 같습니다.<br />
<strong>purity 법칙</strong>: <code>mfix (return . h) = return (fix h)</code></p>
<p>일부 문서에서 <code>fix (&gt;&gt;= f)</code>를 먼저 보여주며, MonadFix is just a monadic version of fix라 해서, 오히려 혼란스럽게 접근한 건 아닌가 합니다.</p>
<p>※ <code>Maybe</code> 인스턴스의 경우, <code>Nothing</code>인지 계속 살펴봐야 하지만, 무조건 <code>Just</code>라 놓고 실행하다 <code>Nothing</code>을 만나면 폭파!시켜버리는 편법?을 쓰고 있습니다.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Control.Monad.Fix</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadFix</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    mfix f <span class="ot">=</span> <span class="kw">let</span> a <span class="ot">=</span> f (unJust a) <span class="kw">in</span> a</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>             <span class="kw">where</span> unJust (<span class="dt">Just</span> x) <span class="ot">=</span> x</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>                   unJust <span class="dt">Nothing</span>  <span class="ot">=</span> errorWithoutStackTrace <span class="st">&quot;mfix Maybe: Nothing&quot;</span></span></code></pre></div>
<p>무한한 미래를 참고하는데, “미래에도 절대 <code>Nothing</code>”이 없어야 <code>Just</code>라고 해야 할 것 같은데, 당장 필요한 것만 봐서 <code>Just</code>라고 하니, 이래도 되나 싶은 생각이 들긴 합니다만, 어쨌든 저렇게 구현되어 있습니다.</p>
<p>무한에 재귀에 이펙트에… 머리를 복잡하게 하는 것들이 다 섞여 있는 주제인데, 이 게 읽기 편해지면 하스켈로 프로그래밍하는데 조금이라도 도움이 되긴 하겠지요?</p>
<blockquote>
<p>생각 스트레칭</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">.</span>) f g   <span class="ot">=</span> \x <span class="ot">-&gt;</span> f (g x)</span></code></pre></div>
<p><code>(.)</code>은 모나드 <code>(&gt;=&gt;)</code>의 특별 버전으로 볼 수 있습니다.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;=&gt;</span>) f g <span class="ot">=</span> \x <span class="ot">-&gt;</span> f x <span class="op">&gt;&gt;=</span> g</span></code></pre></div>
</blockquote>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
