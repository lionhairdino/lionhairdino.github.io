<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">

<head>
  <script>
    (function () {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark') {
        document.documentElement.classList.add('dark-mode');
      }
    })();

    function loadUtterances() {
      const savedTheme = localStorage.getItem('theme');
      const themeValue = savedTheme === 'dark' ? 'github-dark' : 'github-light';

      console.log("theme");
      console.log(themeValue);
      const script = document.createElement('script');
      script.src = 'https://utteranc.es/client.js';
      script.setAttribute('repo', 'lionhairdino/lionhairdino.github.io');
      script.setAttribute('issue-term', 'url');
      script.setAttribute('theme', themeValue);
      script.setAttribute('crossorigin', 'anonymous');
      script.async = true;
      document.body.appendChild(script);
    };

    function updateUtterancesTheme() {
      const savedTheme = localStorage.getItem('theme');
      const themeValue = savedTheme === 'dark' ? 'github-dark' : 'github-light';

      // Utterances iframe에 메시지 전송
      const utterances = document.querySelector('.utterances iframe');
      if (utterances) {
        utterances.contentWindow.postMessage(
          {type: 'set-theme', theme: themeValue},
          'https://utteranc.es'
        );
      }
    }

  </script>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>lionhairdino - Parsec - 파서를 위해 태어난 모나드</title>
  
  <meta name="description" content="파서는 모나드 패턴으로 구현하기 딱 좋은 대상입니다. 모나드가 어떤 일을 하는지 엿보기에 좋은 예입니다." />
  <meta property="og:description" content="파서는 모나드 패턴으로 구현하기 딱 좋은 대상입니다. 모나드가 어떤 일을 하는지 엿보기에 좋은 예입니다." />
  
  <link rel="stylesheet" type="text/css" href="../css/default.css" />
  <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
  <link rel="shortcut icon" href="../favicon.ico" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
  <link rel="manifest" href="../site.webmanifest" />
  <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
  <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
  <meta name="msapplication-TileColor" content="#ff7500" />
  <meta name="theme-color" content="#ffffff" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Parsec - 파서를 위해 태어난 모나드" />
  <meta property="og:site_name" content="Lionhairdino" />
  <meta property="og:url" content="https://lionhairdino.github.io/posts/2021-05-21-parsec.html" />
  
  <meta property="og:image" content="https://lionhairdino.github.io/images/pandoc.png" />
  
  
  <meta name="keywords" content="parser, parsec, monad, 파섹, 파서, 모나드, 상호 재귀, Mutual recursion, 왼쪽 재귀, Left Recursion, Compiler, Happy, Alex, Combinator, LL, haskell, 하스켈, 함수형, Functional">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-E9WZ6VXGHP');
  </script>
  <script src="../script/copycode.js"></script>

  <script src="../script/darkmode.js"></script>
  <script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
  <meta name="fediverse:creator" content="@lionhairdino@mastodon.social" />
  <link rel="alternate" type="application/rss+xml" title="상상 하스켈 - Lionhairdino" href="rss.xml" />
</head>

<body>
  <div id="header">
    <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
      <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
    </div>
    <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
      <a href="../">lionhairdino</a>
      <a href="../about.html">about</a>
      <!--<a href="/archive.html">archive</a>-->
    </div>
    <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
      <div style="display:inline-block;vertical-align: top;padding-top: 5px"></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:18px;border:none" src="../images/bluesky.svg"></a>
      </div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://discordapp.com/users/lionhairdino#7687"><img style="width:20px;border:none" src="../images/discord.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://x.com/lionhairdino"><img style="width:15px;border:none" src="../images/X.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://linkedin.com/in/lionhairdino-l-baaa54244"><img style="width:20px;border:none" src="../images/linkedin.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://github.com/lionhairdino"><img style="width:20px;border:none" src="../images/github.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://www.threads.net/@linohairdino"><img style="width:20px;border:none" src="../images/threads.svg"></a></div>
    </div>
    <div>
      <div style="display:inline-block;width:180px;">
        <div class="gcse-searchbox-only"></div>
        <div><button id="theme-toggle">
            <script>
              const savedTheme = localStorage.getItem('theme');
              if (savedTheme === 'dark')
                document.write("☉");
              else
                document.write("☾");
            </script>
          </button></div>
      </div>
    </div>
    <div>
      여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다. 여기 글을 처음 읽는 분은, 먼저 <a href="../warning.html">주의문</a>을 꼭 읽어보세요.
    </div>
  </div>
  <div class="js-toc-content">
    <h1>Parsec - 파서를 위해 태어난 모나드</h1>
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on May 21, 2021
    
</div>

<p>참고 문서<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>들을 보고 의문이 생기는 부분들을 정리한 포스트이니, 참고 문서들을 먼저 보세요.</p>
<p>여기 쓰인 코드는 parsec의 기본 아이디어를 볼 수 있도록 간단하게 만든 nanoparsec의 코드로 아래 사이트에서 발췌했습니다. <a href="http://dev.stephendiehl.com/fun/002_parsers.html"><del>Stephen Diehl-Parser</del></a>(2023-11-30 사이트는 열리는데, 해당 주소는 열리지 않습니다.)
※ 위 사이트 코드는 <a href="https://www.cs.rit.edu/~swm/cs561/monadic-parsing-jfp.pdf">그래함 허튼, 에릭 마이어의 Monadic parsing in haskell</a> 문서의 Gofer코드를 하스켈로 수정한 코드입니다.</p>
<h3 id="목차">목차</h3>
<ol type="1">
<li><a href="#파서엔-모나드가-딱이다">파서엔 모나드가 딱이다</a></li>
<li><a href="#parser-타입-정의">Parser 타입 정의</a></li>
<li><a href="#그런데-왜-결과-타입이-튜플-리스트일까">그런데 왜 결과 타입이 튜플 리스트일까?</a></li>
<li><a href="#왜-파서와-파서를-붙이지-않고-파서와-파서를-고르는-함수를-붙일까">왜 파서와 파서를 붙이지 않고, 파서와 파서를 고르는 함수를 붙일까?</a></li>
<li><a href="#monadplus-alternative">MonadPlus, Alternative</a></li>
<li><a href="#char-a-파서">char ‘A’ 파서</a></li>
<li><a href="#왼쪽-재귀left-recursion이-무한히-도는-걸-막는-방법">왼쪽 재귀Left Recursion이 무한히 도는 걸 막는 방법</a></li>
<li><a href="#어휘lexical-분석을-위한-기본-파서-scanning을-위한-파서">어휘lexical 분석을 위한 기본 파서 (Scanning을 위한 파서)</a></li>
<li><a href="#some-many">Some, Many</a></li>
<li><a href="#역시-매직의-핵심-비밀은-바인드">역시 매직의 핵심 비밀은 바인드</a></li>
<li><a href="#happy--alex">Happy &amp; Alex</a></li>
</ol>
<h2 id="파서엔-모나드가-딱이다">파서엔 모나드가 딱이다</h2>
<figure>
<img src="../images/parsec.png" alt="누가 봐도 이건 모나드로 만들걸!" />
<figcaption aria-hidden="true">누가 봐도 이건 모나드로 만들걸!</figcaption>
</figure>
<p>왜 모나드 구조가 어울리는지부터 고민해보고 가겠습니다. 문자열stream을 받아서, 파서가 지정한 단어가 있으면, 문자열을 단어 길이만큼 consume하고 찾은 단어를 기억하고, 아니면 하나도 consume하지 않고 에러를 리턴합니다. 그 다음 이어지는 파서가 또 다시 원하는 단어가 있는지 봐서, 있으면 consume하고, 찾은 단어들을 누적하고 없으면 에러를 리턴할 겁니다.</p>
<ol type="1">
<li>첫 째, <em>같은 구조의 작업이 계속 반복</em>되면서 파싱 결과(effect)가 누적 되는게 보입니다.</li>
<li>둘 째, 작업이 끝나고 다음 파서로 넘어갈 때, 결과를 누적하고 분기(갈래길 선택)하는 게 보입니다. 파서와 파서<em>사이 고정적으로 반복해야 하는 작업</em>, 다시 말하면 컨텍스트가 보입니다.</li>
<li>셋 째, 체인 실행 도중에 파싱 <em>실패하면 바로 체인을 끝내면</em> 될 것 같습니다.</li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 2021/05/19 이렇게 생긴 날짜를 파싱한다면 이런 모양을 예상할 수 있습니다.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>parser 숫자4개 <span class="op">&gt;&gt;=</span> parser <span class="ch">'/'</span> 또는 <span class="ch">'-'</span> <span class="op">&gt;&gt;=</span> parser 숫자2개 <span class="op">&gt;&gt;=</span> parser <span class="ch">'/'</span> 또는 <span class="ch">'-'</span> <span class="op">&gt;&gt;=</span> parser 숫자2개</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  parser 숫자4개</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  parser <span class="ch">'/'</span> 또는 <span class="ch">'-'</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  parser 숫자2개</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  parser <span class="ch">'/'</span> 또는 <span class="ch">'-'</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  parser 숫자2개</span></code></pre></div>
<p>결과 누적에 특화된 모나드가 <code>state</code> 모나드가 있고, 분기하는 모나드로 가장 유명한게 <code>Maybe</code> 모나드입니다. 둘과 비슷한 모양의 바인드가 나오지 않을까 예상하며 다음으로 넘어가겠습니다.</p>
<h2 id="parser-타입-정의">Parser 타입 정의</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="ot">=</span> <span class="dt">Parser</span> {<span class="ot"> parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(a,<span class="dt">String</span>)] }</span></code></pre></div>
<p>유지하고 있어야 할 정보가 두 가지입니다. 리스트로 가지고 있든, 특별히 만든 타입으로 가지고 있든, 두 가지 정보만 가지고 있으면 됩니다. 두가지 정보를 효율적으로 묶어 놓기 좋은 방법이 바로 튜플입니다. 파싱된 결과가 하나가 아닐 경우를 위해 리스트로 만들었습니다.<br />
Parser는 문자열을 받아서 어떤 작업을 한 후 튜플 리스트를 돌려주는 함수 타입을 말합니다.
파서를 “스트림을 받아서 튜플 리스트를 주는 함수” 타입이라 읽겠습니다. 아마도 파서를 연결 연결한 모양으로 스트림을 파싱하게 될 겁니다. <code>Parser</code>는 입력은 문자열인데, 출력이 튜플이라 컴포지션이 안됩니다. 나중에 들어올 값이 첫 번째 <code>Parser</code>를 통과하고, ‘남은 스트림’과 ’파싱된 결과’ 이 두 개의 정보를 가지고, 두 번째 <code>Parser</code>도 통과할 <em>준비</em>를 해놔야 합니다. 이게 바로 바로 값을 통과시키며 따라가는게 아니라, 값은 언젠가 들어 오겠거니 하고 함수를 미리 조립해 놓는 것입니다.</p>
<h2 id="그런데-왜-결과-타입이-튜플-리스트일까">그런데 왜 결과 타입이 튜플 리스트일까?</h2>
<p><code>String -&gt; (a, String)</code>쯤이면 될 것 같은데, 결과값이 왜 튜플 리스트일까요? 파서가 실패하게 되면 Maybe 타입을 써서 Nothing을 리턴하고, 성공하면 Just (a, String)을 리턴하게 할 수도 있을텐데, 그러지 않고 리스트를 이용했습니다. 성공하면 싱글턴 리스트 [(a, String)], 실패하면 빈 리스트 []를 리턴하도록 만들었습니다. 이렇게 리스트로 만들면, 딱 하나의 결과만 나오는 파서가 아닌 여러 갈래의 길로 나갈 수도 있는 파서를 만들 수 있습니다. (<span class="citation" data-cites="todo:여러">@todo:여러</span> 갈래길이 나오는 예시 추가)</p>
<h2 id="왜-파서와-파서를-붙이지-않고-파서와-파서를-고르는-함수를-붙일까">왜 파서와 파서를 붙이지 않고, 파서와 파서를 고르는 함수를 붙일까?</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bind ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> b</span></code></pre></div>
<p><code>Parser a</code>와 <code>a -&gt; Parser b</code>를 연결하는 <code>bind</code>입니다. 왜 <code>Parser a -&gt; Parser b</code>가 아닐까요?</p>
<p>보통 모나드에서 <code>bind</code>를 정의할 때는 <code>m a</code> 자체가 함수가 아니어서, <code>m a -&gt; (a -&gt; m b) -&gt; m b</code> 의미를 알겠는데, <code>Parser</code>는 <code>Parser</code> 자체가 함수라 <code>Parser a</code>와 <code>Parser b</code>를 연결하는 <code>bind</code>를 만들면 될 것 같은데, 왜 <code>a -&gt; Parser b</code> 가 나왔을까요?</p>
<p>익숙한 <code>Maybe</code>부터 다시 살펴 보겠습니다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Just</span> a <span class="op">|</span> <span class="dt">Nothing</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">bind ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span></code></pre></div>
<p><code>Maybe</code> 바인드는 첫 번째 <code>Maybe</code>와 두 번째 <code>Maybe</code>를 연결하는게 아닙니다. 첫 번째 <code>Maybe</code>와 <code>Maybe</code>를 만들어내는 함수를 연결합니다. 어떤 뜻일까요? 첫 번째 <code>Maybe</code>에서 <code>Maybe</code>를 벗겨내고 <code>a</code>를 꺼내면서 <code>Maybe</code>의 펑크터 컨텍스트가 발현됩니다. <code>Nothing</code>인지 보는 겁니다. <code>Nothing</code>이 아니라면 내부에서 어떤 작업을 한 후 다시 <code>Maybe</code>로 감쌉니다. 컨텍스트를 발현시키려면 반드시 <em>벗겨 내는 절차</em>가 나와야 합니다.</p>
<p>그럼 똑같이 <code>Parser</code>에 적용해 보겠습니다. <code>Parser</code>를 벗겨내고 <code>a</code>를 꺼내면서 <code>Parser</code> 컨텍스트가 발현되고 결과를 다시 <code>Parser</code>로 감쌉니다. 일단, 추측할 수 있는게, 파서를 돌리고, 그 <em>다음 파서를 돌리기 전에 어떤 사전 작업</em>을 할 거라 예측을 할 수 있습니다. 단순히 파싱 결과로 나온 정보를 다음 파서가 그대로 가져가지 않고 뭔가 상황을 보고 다음 파서로 간다는 말입니다. 이제 궁금한 대상이 조금은 더 좁혀졌습니다. <code>Parser</code>의 컨텍스트가 뭔지 알아야 합니다.</p>
<p>바인드의 정의를 살펴 보면</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>bind p f <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="fu">concatMap</span> (\(a, s') <span class="ot">-&gt;</span> parse (f a) s') <span class="op">$</span> parse p s</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- 결과값을 누적시키는 바인드 참고 - state 모나드의 바인드 </span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>(<span class="dt">State</span> x) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span> (v,s') <span class="ot">=</span> x s <span class="kw">in</span> runState (f v) s'</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- state모나드 액션은 s -&gt; (a, s)</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- 상태s를 받아 (결과, 새로운 상태) 튜플을 리턴하는 액션입니다.</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- 다음 액션을 만드는 f에 결과값 v를 넣어 액션을 만든 다음 새로운 상태 s'을 넣어줍니다.</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- 값에 따라 체인을 끊을 수 있는 바인드 - 참고 Maybe 모나드의 바인드</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span>  <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Nothing</span> <span class="co">-- Nothing일 경우 아예 다음 액션인 f를 실행하지 않습니다.</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Just</span> x) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f x</span></code></pre></div>
<p>concatMap은 concat과 Map을 합친 함수입니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="fu">concat</span> [[<span class="dv">1</span>],[<span class="dv">2</span>]]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="op">:</span>t <span class="fu">concatMap</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="fu">concatMap</span><span class="ot"> ::</span> <span class="dt">Foldable</span> t <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> [b]</span></code></pre></div>
<ol type="1">
<li><code>bind p f</code> 는</li>
<li>파서<code>p</code>를 나중에 들어올(인자로 받을) 스트림에 적용해서 나온 튜플 <code>a, s'</code> 중</li>
<li>결과 <code>a</code>에 <code>f</code>함수를 적용하고 나온 파서를 <code>s'</code>에 적용한 후</li>
<li><code>concat</code>할 <em>준비</em>를 합니다.</li>
</ol>
<p>bind p f의 결과도 하나의 파서입니다. 무슨 일이 벌어지는 건지 더 자세히 읽어 보겠습니다.</p>
<ol type="1">
<li><code>f</code> 함수는 <code>a -&gt; Parser b</code> 타입의 함수로, 첫 번째 파서 <code>p</code>의 결과에서 튜플<code>(a,s')</code> 하나를 뽑아 그 중 a를 넣어주면</li>
<li>어떤 작업을 한 후 <code>Parser b</code>를 결정합니다. 이 <code>Parser b</code>를 나머지 스트림<code>s'</code>에 다시 적용합니다. 결과로 튜플 리스트가 나옵니다.</li>
<li>첫 번째 파서<code>p</code>의 결과에서 또 하나의 튜플을 뽑아 <code>Parser b</code>를 적용하고 결과로 튜플 리스트가 나옵니다.</li>
<li><code>([(O,O),(O,O)...], [(O,O),(O,O)...],...)</code> 이런 형태가 되고, <code>concat</code>을 먹이면</li>
<li><code>[(O,O),(O,O),(O,O)...]</code>이 됩니다.</li>
<li>첫 번째 파서의 결과에 따라 다음 바인딩할 파서를 골라서 남은 스트림에 적용, 가지쳐 나간 결과를 하나로 묶는 게 Parser의 컨텍스트입니다.</li>
</ol>
<p>이렇게 바인딩, 바인딩되어 큰 하나의 파서가 된 걸</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runParser ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>runParser m s <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> parse m s <span class="kw">of</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        [(res, [])] <span class="ot">-&gt;</span> res</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        [(_, rs)] <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Parser did not consume entire stream.&quot;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Parser error.&quot;</span></span></code></pre></div>
<p><code>runParser</code>에 넣으면, 스트림을 모두 consume했으면 결과를 돌려주고 아니면 에러가 납니다.</p>
<p>2021.5.22 추가<br />
※ 아래 코드는 <a href="http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf">그래함 허튼의 문서</a>에서 발췌했습니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">seq</span><span class="ot">      ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a,b)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>p ‘seq‘ q <span class="ot">=</span> \inp <span class="ot">-&gt;</span> [((v,w),inp’’) <span class="op">|</span> (v,inp’)  <span class="ot">&lt;-</span> p inp, (w,inp’’) <span class="ot">&lt;-</span> q inp’]</span></code></pre></div>
<p>고퍼 언어 코드인데, 여기선 하스켈하고 크게 다른 부분이 없습니다. 눈여겨 볼 부분이 <code>p</code>파서 결과와 <code>q</code>파서 결과를 <code>( (v,w), ...)</code> 로 유지하고 있습니다. 이렇게 합쳐진 파서와 또 다른 파서를 합치면 아마도 <code>(((v,w), x), ...)</code> 이렇게 될 겁니다. 나중에 파싱 결과를 이용하기 위해서 어딘가에는 저장해 둬야 합니다. 리스트같은 데이터 타입을 만들어 주욱 저장해 놓고 다음 파서로 넘기게 해서 끌고 다니는 것도 한 가지 방법이 될 수 있습니다. 어떻게든 정보를 모두 저장해서 나중에 한 번에 처리하는 함수에 모두 넘겨야 합니다. 함수형은 매개 변수 이외에는 정보를 받을 수 없는, 외부 변수값에 절대 접근 할 수 없는 특징 때문에 생긴 고민입니다. 하지만 이렇게 함수들을 엮는(연결하는, 합성하는, combine하는, bind하는) 모양엔 중요한 특징이 있습니다.</p>
<p>바로 <em>람다 변수에 결과를 저장</em>할 수 있습니다. 다른 말로 클로저를 활용하는 겁니다. 참고 - <a href="https://lionhairdino.github.io/posts/2020-06-24-Monad.html#%EC%9E%90%EC%8B%A0%EC%9D%84-%ED%92%88%EA%B3%A0-%EC%9E%88%EB%8A%94-%ED%95%A8%EC%88%98%EC%83%81%EC%9C%84-%ED%95%A8%EC%88%98%EC%9D%98-%EB%A7%A4%EA%B0%9C-%EB%B3%80%EC%88%98-%EA%B0%92%EC%9D%80-%EC%A0%91%EA%B7%BC-%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8B%A4-closure">모나드 문턱에서 포스트</a></p>
<ol type="1">
<li>파서들의 결과를 모두 모아서 마지막에 함수 하나가 모두 받아 처리하든지,<br />
</li>
<li>바로 전 파서의 결과를 다음 파서가 받아 처리하든지,</li>
</ol>
<p>두 가지 경우 모두 클로저를 활용하는 방법으로 해결할 수 있습니다. <em>비수학적으로 모나드를 바라 볼 때, 아주 중요한 특징</em>입니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>파서1 <span class="op">&gt;&gt;=</span> \r1 <span class="ot">-&gt;</span> 파서2 <span class="op">&gt;&gt;=</span> \r2 <span class="ot">-&gt;</span> 파서3 <span class="op">&gt;&gt;=</span> \r3 <span class="ot">-&gt;</span> 최종 작업</span></code></pre></div>
<p>이 체인의 끝에 있는 최종 작업은 <code>r1</code>, <code>r2</code>, <code>r3</code>를 모두 사용할 수 있습니다. 액션과 액션을 바로 붙이지 않고, 접착제로 쓰이는 바인드<code>&gt;&gt;=</code>함수가 람다 변수에 결과값을 저장하도록 만드는 게, 모나드 패턴을 쓸 때 아주 유용합니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bind      ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> b</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>p ‘bind‘ f <span class="ot">=</span> \inp <span class="ot">-&gt;</span> <span class="fu">concat</span> [f v inp’ <span class="op">|</span> (v,inp’) <span class="ot">&lt;-</span> p inp]</span></code></pre></div>
<p>두 번째 인자로 받은 <code>f :: a -&gt; Parser b</code> 함수를 첫 번째 파서<code>p</code>의 결과값<code>v</code>에 적용, 결과적으로 <code>p</code>의 리턴값을 람다 변수에 두면서 바인딩하게 됩니다. 이렇게 람다 변수에 둔 값은 현재 액션에서 써먹을 수도 있고, 이 체인에 연결되어 있는 다른 액션(보통은 가장 마지막 액션)에서 써 먹을 수도 있습니다. 다른 함수들의 결과를 매개 변수로 명시적으로 받지 않아도 써먹을 수 있는 중요한 특징입니다.</p>
<p>클로저를 어떻게 보냐에 따라, “매개 변수 이외에는 절대 정보를 받을 수 없다”는 맞는 말일수도, 틀린 말일 수도 있습니다.</p>
<h2 id="monadplus-alternative">MonadPlus, Alternative</h2>
<p>다음은 파서를 조립할 때 쓸 컴비네이터들입니다.</p>
<p>※ Combinator - 람다 대수에선 free variable이 없는 함수를 말하지만, 여기선 Parser함수와 Parser함수를 연결해서 또 다른 Parser함수를 만드는 접착제 갈은 역할을 하는 브로커 함수들을 말합니다. 모나드의 바인드같은 함수들을 컴비네이터라 부릅니다. 의미에 맞게 번역한다면 접착 함수쯤일텐데 입에 딱 감기진 않습니다. - <a href="https://wiki.haskell.org/Combinator" class="uri">https://wiki.haskell.org/Combinator</a></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">combine ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>combine p q <span class="ot">=</span> <span class="dt">Parser</span> (\s <span class="ot">-&gt;</span> parse p s <span class="op">++</span> parse q s)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- 이렇게 파싱 결과를 합치려면 결과가 [(,)] 인게 말이 됩니다.</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ot">failure ::</span> <span class="dt">Parser</span> a</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>failure <span class="ot">=</span> <span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> [])</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="ot">option ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>option  p q <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> \s <span class="ot">-&gt;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> parse p s <span class="kw">of</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    []     <span class="ot">-&gt;</span> parse q s</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    res    <span class="ot">-&gt;</span> res</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadPlus</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>  mzero <span class="ot">=</span> failure</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  mplus <span class="ot">=</span> combine</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  empty <span class="ot">=</span> mzero</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&lt;|&gt;</span>) <span class="ot">=</span> option</span></code></pre></div>
<p>상호 재귀<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>로 매직같은 일을 하는 Alternative 클래스의 메소드 <a href="#some-many">some, many</a>는 다른 기본 함수들을 훑어 본 후 자세히 보도록 하겠습니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 하나 이상</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">some ::</span> f a <span class="ot">-&gt;</span> f [a]</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>some v <span class="ot">=</span> some_v</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    many_v <span class="ot">=</span> some_v <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> []</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    some_v <span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> many_v</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- 0 이상</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="ot">many ::</span> f a <span class="ot">-&gt;</span> f [a]</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>many v <span class="ot">=</span> many_v</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    many_v <span class="ot">=</span> some_v <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> []</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    some_v <span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> many_v</span></code></pre></div>
<p>이 함수들을 이용해 현재 글자가 <code>predicate</code>함수(ex. <code>isDigit</code>, <code>isLetter</code>,..)를 만족하는지 확인하는 함수를 만들 수 있습니다.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit ::</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>unit a <span class="ot">=</span> <span class="dt">Parser</span> (\s <span class="ot">-&gt;</span> [(a,s)])</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">item ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>item <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> \s <span class="ot">-&gt;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> s <span class="kw">of</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        [] <span class="ot">-&gt;</span> []</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        [c<span class="op">:</span>cs] <span class="ot">-&gt;</span> [(c,cs)]</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="ot">satisfy ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>satisfy p <span class="ot">=</span> item <span class="ot">`bind`</span> \c <span class="ot">-&gt;</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> p c</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">then</span> unit c <span class="co">-- Just와 닮았습니다.</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> (<span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> [])) <span class="co">-- Nothing과 닮았습니다.</span></span></code></pre></div>
<p>여기까지가 기본 재료들이 되는 코드입니다. 이 코드들을 재료로 고차원적인 파서들을 만들어 가게 됩니다.</p>
<h2 id="char-a-파서">char ‘A’ 파서</h2>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>char c <span class="ot">=</span> satisfy (c <span class="op">==</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>satisfy (<span class="ch">'A'</span> <span class="op">==</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> item <span class="ot">`bind`</span> \c <span class="ot">-&gt;</span> <span class="kw">if</span> (<span class="ch">'A'</span> <span class="op">==</span> c)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">then</span> unit c</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">else</span> (<span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> []))</span></code></pre></div>
<p><code>char 'A' &gt;&gt;= (\_ -&gt; char 'A')</code> 파서 뭉치를 <code>"AA"</code> 문자열에 적용하는 걸 풀어 보겠습니다. (여러 파서를 바인딩 해 놓은 걸 표현할 적당한 용어가 떠오르지 않습니다. 일단 투박하지만 뭉치라 표현하겠습니다.)</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runParser ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>runParser m s <span class="ot">=</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> parse m s <span class="kw">of</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        [(res, [])] <span class="ot">-&gt;</span> res</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        [(_, rs)] <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Parser did not consume entire stream.&quot;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;Parser error.&quot;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> runParser (char <span class="ch">'A'</span>) <span class="st">&quot;AA&quot;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span>    \s<span class="ot">-&gt;</span> [(<span class="ch">'A'</span>,<span class="st">&quot;A&quot;</span>)]     <span class="ot">`bind`</span>      \c <span class="ot">-&gt;</span> <span class="kw">if</span> (<span class="ch">'A'</span> <span class="op">==</span> c) </span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">then</span> unit c</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">else</span> (<span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> []))</span></code></pre></div>
<p>일단 <code>char 'A'</code>부터 풀면,</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- item `bind` (\c -&gt;...) 를 풀면  </span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">concatMap</span> (\(a, s') <span class="ot">-&gt;</span> (f파서 a) s') <span class="op">$</span> \s <span class="ot">-&gt;</span> item파서 <span class="st">&quot;AA&quot;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="fu">concatMap</span> (\(a, s') <span class="ot">-&gt;</span> (f파서 a) s') <span class="op">$</span> [(<span class="ch">'A'</span>,<span class="st">&quot;A&quot;</span>)] </span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- a는 'A', s'은 &quot;A&quot;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>( parse ( 결과 <span class="ch">'A'</span>를 보고 unit 파서 선택 ) <span class="st">&quot;A&quot;</span> ) </span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>( parse ( unit <span class="ch">'A'</span> ) <span class="st">&quot;A&quot;</span> ) </span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>(\s <span class="ot">-&gt;</span> [(<span class="ch">'A'</span>,s)] ) <span class="st">&quot;A&quot;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>[(<span class="ch">'A'</span>,<span class="st">&quot;A&quot;</span>)]</span></code></pre></div>
<p>첫 번째 파서 <code>char 'A'</code>가 실패하지 않았기 때문에 다음 바인딩 되어 있는 <code>char 'A'</code>에 <code>"A"</code>가 넘어갑니다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">concatMap</span> (\(a, s') <span class="ot">-&gt;</span> (f파서 a) s') <span class="op">$</span> \s <span class="ot">-&gt;</span> item파서 <span class="st">&quot;A&quot;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="fu">concatMap</span> (\(a, s') <span class="ot">-&gt;</span> (f파서 a) s') <span class="op">$</span> [(<span class="ch">'A'</span>,<span class="st">&quot;&quot;</span>)] </span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- a는 'A', s'은 &quot;A&quot;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>( parse ( 결과 <span class="ch">'A'</span>를 보고 unit 파서 선택 ) <span class="st">&quot;&quot;</span> ) </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>( parse ( unit <span class="ch">'A'</span> ) <span class="st">&quot;&quot;</span> ) </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>(\s <span class="ot">-&gt;</span> [(<span class="ch">'A'</span>,s)] ) <span class="st">&quot;&quot;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>[(<span class="ch">'A'</span>,<span class="st">&quot;&quot;</span>)]</span></code></pre></div>
<p>만일 파서 뭉치를 <code>"BA"</code> 문자열에 적용하면</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>( parse ( (\c <span class="ot">-&gt;</span> <span class="op">...</span>) <span class="ch">'B'</span>) <span class="st">&quot;A&quot;</span> ) </span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>( parse ( <span class="dt">Parser</span> (\cs <span class="ot">-&gt;</span> [])) <span class="st">&quot;A&quot;</span> ) </span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>[]</span></code></pre></div>
<p>위 코드를 말로 표현하면, <code>char 'A'</code> 파서는</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>한 글자를 봐서 <span class="dt">A</span>이면 [(<span class="ch">'A'</span>,나머지 문자열)] 아니면 []   </span></code></pre></div>
<p>작업을 하는 파서입니다.</p>
<h2 id="왼쪽-재귀left-recursion이-무한히-도는-걸-막는-방법">왼쪽 재귀Left Recursion이 무한히 도는 걸 막는 방법</h2>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chainl ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span></code></pre></div>
<p><code>chainl</code>은 LL파서에서 흔히 만나는 왼쪽 무한 재귀left-recursive grammar를 피하기 위해 쓴다고 합니다.</p>
<p>왜 사람들이 궁금해 하지 않을까요? 인터넷에서 꽤 많은 파서 관련 글들을 찾아 보았는데, 다들 이렇게 저렇게하면 무한 재귀가 사라진다하고 넘어갑니다. 아니면 생성 규칙 가장 왼쪽에 같은 비단말이 있어서 그렇다는 동어 반복 같은 설명만 있습니다.</p>
<p>드래곤책(Compilers Principles, Techniques, and Tools - Alfred V.Aho 외)에 있는 설명을 보면</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">A</span>α <span class="op">|</span> β</span></code></pre></div>
<p>이 문법이 만들어 낼 수 있는 토큰열 : <code>βα</code>, <code>βαα</code>, <code>βααα</code> …<br />
이 문법은 무한 재귀가 돌고</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">A</span>  <span class="ot">-&gt;</span> β<span class="dt">A'</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="dt">A'</span> <span class="ot">-&gt;</span> α<span class="dt">A'</span> <span class="op">|</span> ε</span></code></pre></div>
<p>이 문법이 만들어 낼 수 있는 토큰열 : <code>βα</code>, <code>βαα</code>, <code>βααα</code> …(위와 같습니다.)<br />
이렇게 문법을 쪼개면 무한 재귀가 사라집니다.</p>
<p>같은 문자열을 생성하는 규칙인데, 어째서 차이가 날까요? 두 번째 문법은</p>
<ol type="1">
<li><p><code>α</code>반복과 <code>β</code>를 분리해서 각각의 규칙을 만들었습니다.</p></li>
<li><p><code>Aα</code>는 <code>α</code> 하나를 매칭하기 전 비단말 <code>A</code>를 풀어야 하고, <code>αA'</code>는 <code>α</code> 하나를 매칭하고, 그 다음 비단말 <code>A'</code>를 풉니다.</p></li>
<li><p>두 단계로 규칙을 나누면 비단말 두 개를 풀기 위해 생성 규칙이 두 번 적용됩니다. 그런데 첫 번째 규칙을 적용하는 순간 매칭이 이루어지면 <em>lookahead(입력 토큰열의 현재 토큰을 가리키는 포인터)가 다음 토큰</em>으로 넘어갑니다. 이게 주요 아이디어 같습니다.</p></li>
</ol>
<p>아이디어를 알아야, 나중에 왼쪽 재귀를 넣어야 될 상황이 오면 대처할 수 있을텐데 아이디어를 콕 집어서 설명해주는 자료를 못 찾았습니다.</p>
<p>제가 정리한 아이디어는 다음과 같습니다.</p>
<div class="line-block">최대한 재귀를 다른 것과 분리해서 단독으로 두어야 합니다. 단독으로 놓고 보면,<br />
매칭하고 비단말 푸는 것과,<br />
비단말 풀고 매칭하는게<br />
결과적으로 차이가 없어집니다.<br />
일단 매칭하면 lookahead가 다음 토큰으로 이동하니, 그 다음 단말을 풀 때 동일한 환경에서 반복하는게 아닙니다.</div>
<p>이 정리도 딱 마음에 드는 건 아닌데, 재귀가 가장 왼쪽에 있어서 그렇다는 설명보다는 조금 더 낫지 않을까 합니다.</p>
<p>그럼 이 아이디어를 기억해 두고, chainl을 풀어 보겠습니다.<br />
왜 <code>Parser (a -&gt; a -&gt; a)</code> 타입의 파서 연산자가 왔을까요? <code>p</code>는 <code>term</code>이나 <code>expr</code>등이 들어옵니다. <code>expr</code>과 <code>term</code>이 그냥 붙어 있진 않습니다. <code>+</code> 나 <code>*</code> 같은 연산자를 통해 여러번 붙어 있는 걸 파싱하는게 목표입니다. 그래서 두 번째 인자는 파서 두 개를 받아 합친 파서를 만들어 주는 연산자가 들어옵니다. 다시 정확히 얘기하면</p>
<p>( 연산자는 여러가지가 올 수 있는데, 눈에 잘띄도록 연산자는 +로 표기 하겠습니다. )
<code>p</code>에 <code>파서</code>를 넣으면, 반복된 <code>+ p</code>를 <code>p</code>뒤에 붙여야 합니다.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chainl ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>chainl p op a <span class="ot">=</span> (p <span class="ot">`chainl1`</span> op) <span class="op">&lt;|&gt;</span> <span class="fu">return</span> a</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- p가 한번 이상 매치되는 걸 파싱합니다.</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="ot">chainl1 ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>p <span class="ot">`chainl1`</span> op <span class="ot">=</span> <span class="kw">do</span> r <span class="ot">&lt;-</span> p <span class="co">-- r은 나중에 토큰열을 받으면 a 타입 값이 될 함수</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>                    rest r </span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">where</span> rest r1 <span class="ot">=</span> (<span class="kw">do</span> oper <span class="ot">&lt;-</span> op </span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>                                    r2 <span class="ot">&lt;-</span> p <span class="co">-- 파서는 같은 파서입니다.</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>                                    rest (oper r1 r2)) <span class="op">&lt;|&gt;</span> <span class="fu">return</span> a</span></code></pre></div>
<p><code>rest</code> 함수는 <code>op</code>에서 파서 연산자를 꺼내고 (ex. <code>+</code>)<br />
<code>p</code> 에서 파서를 꺼내<br />
처음 <code>lookahead</code>가 가리키는 토큰을 파싱하는 파서와<br />
다음으로 이동한 <code>lookahead</code>가 가리키는 토큰을 파싱하는 파서를<br />
연산자로 붙입니다. 그리고, 다시 자기 자신을 부릅니다.(재귀)
언제까지? 파싱이 실패해서 <code>&lt;|&gt; return a</code>가 돌 때까지 계속합니다.</p>
<p>정리하면, 몇 번이고 +p를 적용할 <em>준비</em>가 되어 있는 파서 뭉치를 만들어냅니다.</p>
<p><code>rest</code> 함수가 하는 일은, 3번 아이디어의 <code>lookahead</code>를 다음으로 이동하는 역할을 합니다. <code>r1</code> 에서 <code>&lt;-</code>가 동작해서 <code>lookahead</code>를 옮기고, <code>r2</code> 에서 <code>&lt;-</code>가 동작해서 <code>lookahead</code>를 옮깁니다.</p>
<p><code>expr = expr + term</code>을 파싱해 보겠습니다.</p>
<p>expr과 매칭할 파서는 다음 모양 중 하나일 겁니다.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span>                          term 이거나, </span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span>                   expr <span class="op">+</span> term 이거나,    </span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span>          (expr <span class="op">+</span> term) <span class="op">+</span> term 이거나,    </span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> ((expr <span class="op">+</span> term) <span class="op">+</span> term) <span class="op">+</span> term 이거나,   </span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="op">...</span>   </span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- expr 비단말은 언젠가는 term 비단말로 풀릴테니</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>                         term 이거나,</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>                  term <span class="op">+</span> term 이거나,    </span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>         (term <span class="op">+</span> term) <span class="op">+</span> term 이거나,    </span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>((term <span class="op">+</span> term) <span class="op">+</span> term) <span class="op">+</span> term 이거나,   </span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p><code>α</code>가 <code>+ term</code>, <code>β</code>가 <code>term</code>입니다. 비단말 <code>expr</code>은 <code>term</code> 하나가 아니라, <code>term</code>을 한 번 실행하고 <code>+ term</code>을 반복시키는 역할을 할 뿐입니다.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> term <span class="ot">`chainl1`</span> addop </span></code></pre></div>
<p>표기를 간단히 하기 위해 addop를 + 하나로 생각하고, chainl이 준비하는 파서 모양을 보면</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- r1 : term</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- r2 : term</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- oper : +</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- rest 함수 재귀를 돌려보면,</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="op">...</span><span class="fu">return</span> a<span class="op">...</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="op">...</span>rest (term <span class="op">+</span> term)<span class="op">...</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="op">...</span>rest ((term <span class="op">+</span> term) <span class="op">+</span> term)<span class="op">...</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="op">...</span>rest (((term <span class="op">+</span> term) <span class="op">+</span> term) <span class="op">+</span> term)<span class="op">...</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>위의 expr 파서 모양과 동일함을 알 수 있습니다.</p>
<blockquote>
<p>Q. 어차피 파싱 함수가 한 번 매칭을 하면 <code>lookahead</code>가 다음으로 넘어가는데, 단순히 재귀를 돌리는 것과 무슨 차이가 있을까요?<br />
A. 매칭을 호출했다고 <code>lookahead</code>를 다음으로 보내지 않습니다. 매칭 작업을 완료하면 넘어가지만, 매칭을 완료하기 전에 재귀 호출을 하면 <code>lookahead</code>는 다음으로 넘어가지 않습니다.</p>
</blockquote>
<blockquote>
<p>Q. <code>Some term</code>을 부르는 것과 무슨 차이일까요?<br />
A. <code>Some term</code>에는 연산자가 빠져 있습니다. <code>runParser (some expr) "123(345)"</code> 이런 경우 매칭은 되나, 중간에 연산자가 있는 토큰열은 매칭되지 않습니다.</p>
</blockquote>
<blockquote>
<p>Q. 그럼 <code>term</code> 과 <code>many (+ term)</code>을 붙이는 건 어떨까요?<br />
A. 가능합니다. 이해한게 맞는지 확인하기 위해 에러에 에러, 에러산을 넘어 만들긴 했는데, 코드가 더 줄어들거나 보기 좋진 않네요.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chainl1 ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>chainl1 p op <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    r <span class="ot">&lt;-</span> p</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    rest r</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> </span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    rest r1 <span class="ot">=</span> ( <span class="kw">do</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    r2 <span class="ot">&lt;-</span> ( many (op <span class="op">&gt;&gt;=</span> \f <span class="ot">-&gt;</span> p <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> f b) ) <span class="co">-- ex. Parser [ ( (+int):(+int):[] , &quot;&quot; ) ]</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> ( (<span class="fu">foldl</span> (<span class="fu">flip</span> (<span class="op">$</span>)) r1 r2) ) <span class="co">-- int + int + int</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">&lt;|&gt;</span> <span class="fu">return</span> r1</span></code></pre></div>
</blockquote>
<p>※ GHC는 <code>newtype</code>으로 싸놓은 <code>Parser</code>를 필요할 때까지 뭔지 보지 않습니다. 안에 함수가 들어 있는지, 무슨 구조로 되어 있는지 관심이 없습니다. 그저 a를 래핑한 타입으로 봅니다. 패턴 매칭으로 벗겨져야만 함수가 드러납니다.</p>
<p>※ 설마 이런 오해를 할까 싶은 오해도 합니다.
<code>Parser (a -&gt; a -&gt; a)</code> 에서 <code>Parser</code>를 벗겨내면 <code>(a -&gt; a -&gt; a)</code>가 나올까요?
선언에 쓰여있는 <code>Parser (a -&gt; a -&gt; a)</code>는 값이 아니라 <em>타입 생성자</em>입니다. 이 타입의 값에서 <em>값 생성자</em> <code>Parser</code>를 벗겨내면</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">String</span> <span class="ot">-&gt;</span> [ (  (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)  , <span class="dt">String</span>) ] </span></code></pre></div>
<p>타입의 값이 나옵니다. 굳이 <code>(a -&gt; a -&gt; a)</code>를 이 구조안에 우겨 넣을까요? <code>Parser</code> 컨텍스트를 유지하기 위해서입니다.</p>
<p>타입 생성자가 아닌 값 생성자 <code>Parser</code>로 값을 만들려면 <code>String -&gt; [(a, String)]</code> 타입의 함수를 인자로 줘야 합니다.</p>
<h2 id="어휘lexical-분석을-위한-기본-파서-scanning을-위한-파서">어휘lexical 분석을 위한 기본 파서 (Scanning을 위한 파서)</h2>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- char 'A', char 'b', char '=' ...</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>char c <span class="ot">=</span> satisfy (c <span class="op">==</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- 하나 이상의 숫자를 가진 숫자열</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="ot">natural ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>natural <span class="ot">=</span> <span class="fu">read</span> <span class="op">&lt;$&gt;</span> some (satisfy <span class="fu">isDigit</span>)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- string &quot;hello&quot;</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>string [] <span class="ot">=</span> <span class="fu">return</span> []</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>string (c<span class="op">:</span>cs) <span class="ot">=</span> <span class="kw">do</span> { char c; string cs; <span class="fu">return</span> (c<span class="op">:</span>cs)}</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- 공백으로 분리된 낱말</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- token (string &quot;WORD&quot;)는 &quot;WORD &quot;를 파싱</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a><span class="ot">token ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>token p <span class="ot">=</span> <span class="kw">do</span> { a <span class="ot">&lt;-</span> p; spaces ; <span class="fu">return</span> a}</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- string과 token을 합쳐 놓은 건데, 여기서 매칭된 건 파싱 결과에 포함되지 않습니다. </span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- 예약어란 의미에서 reserved입니다. </span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- (SOME) 을 parens SOME으로 파싱하면 결과는 ()를 뺀 SOME입니다. </span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a><span class="ot">reserved ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>reserved s <span class="ot">=</span> token (string s)</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- 공백 문자</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a><span class="ot">spaces ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>spaces <span class="ot">=</span> many <span class="op">$</span> oneOf <span class="st">&quot; \n\r&quot;</span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a><span class="co">-- 숫자 하나</span></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a><span class="ot">digit ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>digit <span class="ot">=</span> satisfy <span class="fu">isDigit</span></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a><span class="co">-- 부호 포함 숫자열</span></span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a><span class="ot">number ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>number <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>  s <span class="ot">&lt;-</span> string <span class="st">&quot;-&quot;</span> <span class="op">&lt;|&gt;</span> <span class="fu">return</span> []</span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a>  cs <span class="ot">&lt;-</span> some digit</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">read</span> (s <span class="op">++</span> cs)</span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a><span class="co">-- parens (some digit) 하면</span></span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a><span class="co">-- (11) ( 11) 은 인식하는데, (11 )은 못합니다.</span></span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a><span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>parens m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>  reserved <span class="st">&quot;(&quot;</span></span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> m</span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>  reserved <span class="st">&quot;)&quot;</span></span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> n</span></code></pre></div>
<h2 id="some-many">Some, Many</h2>
<p>상호 재귀를 기차게 쓰는 예시입니다.
<code>Applicative</code> 클래스의 메소드 <code>some</code>, <code>many</code>를 살펴보겠습니다.<br />
<a href="https://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Applicative.html#%3C%2A" class="uri">https://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Applicative.html#%3C%2A</a></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">some ::</span> f a <span class="ot">-&gt;</span> f [a]</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>some v <span class="ot">=</span> some_v</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    many_v <span class="ot">=</span> some_v <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> []</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    some_v <span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> many_v</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="ot">many ::</span> f a <span class="ot">-&gt;</span> f [a]</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>many v <span class="ot">=</span> many_v</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    many_v <span class="ot">=</span> some_v <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> []</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    some_v <span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> many_v</span></code></pre></div>
<p><code>some</code>에서 출발해 보겠습니다.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>some v </span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> some_v</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> many_v  <span class="co">-- (1단계)</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> (some_v                                               <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> [])  <span class="co">-- (2단계)</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> (((<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> many_v)                               <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> [])  <span class="co">-- (3단계)</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> (((<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> (some_v <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> []))                 <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> [])</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> (((<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> (((<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> many_v) <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> [])) <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> [])</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>reduce과정이야 무식하게 따라가면 읽을 수 있긴 한데, 이 상호 재귀의 종료 조건(엣지 조건)은 뭘까요?
<code>v</code>를 반복해서 붙여 놓습니다. 붙일 때마다 언제든 다음 단계로 진행하지 않을 조건 바로 <code>&lt;|&gt; pure []</code>도 계속 같이 붙여 놓습니다. 이 함수들은 꼭 파서를 위한 함수들만은 아닌데, 파서를 만들면서 같이 나온 건 아닐까 싶습니다. 파서와 정말 찰떡인 함수들입니다. 몇 번이고 반복하다가 파서가 실패하면 <code>&lt;|&gt; pure []</code> 로 넘겨서 더 이상 진행하지 않고 결과값을 리턴합니다. <code>many_v</code> 는 <code>&lt;|&gt; pure []</code>를 붙이는 역할, <code>some_v</code>는 <code>v</code>를 리스트에 넣어두는 역할을 반복하고 있습니다. 하스켈을 공부하려면 충분히 Lazy해져야 합니다.</p>
<figure>
<img src="../images/mutualRecursion.png" alt="화살 주고 과녁 확인하고, 과녁 확인하고 화살 주고" />
<figcaption aria-hidden="true">화살 주고 과녁 확인하고, 과녁 확인하고 화살 주고</figcaption>
</figure>
<p>이 파서 뭉치는 상호 재귀가 끊임 없이 되어 있어 쓸 수 있는 함수는 무한대로 준비 되어 있습니다. 하지만 함수를 꺼내 쓰다 한 번이라도 fail하면 더 이상 이 뭉치에서 함수를 꺼내지 않습니다. <em>끊임 없이 준비를 해야 하는데, 필요하면 그 때 준비를 하지, 미리 준비해 놓지 않습니다.</em> 하나를 적용한 후 fail하지 않으면, 다음 재귀를 돌려 또 함수 하나를 꺼내고, 또 꺼내고,… 그러다 fail이 나면 더 이상 진행하지 않고 결과를 리턴하는 함수 뭉치입니다.</p>
<p>머릿속에서 시뮬레이션할 때, 딱 필요한 시점에 재귀를 한 단계만 돌리세요.</p>
<p>어플리커티브<code>&lt;*&gt;</code>를 쓰는 이유는, <code>fmap</code>(중위 표현 <code>&lt;$&gt;</code>)을 쓰면 펑크터 안에서 커링된 상태가 되기 때문입니다. 참고 - <a href="../posts/2020-07-02-Context.html">컨텍스트, Applicative Functor, Traversable</a></p>
<p>실제 파서와 같이 쓰이는 걸 해석해 보기 위해 <code>some digit</code>를 풀어 보겠습니다.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Parser</span> cs) <span class="ot">=</span> <span class="dt">Parser</span> (\s <span class="ot">-&gt;</span> [(f a, b) <span class="op">|</span> (a, b) <span class="ot">&lt;-</span> cs s])</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Parser</span> cs1) <span class="op">&lt;*&gt;</span> (<span class="dt">Parser</span> cs2) <span class="ot">=</span> <span class="dt">Parser</span> (\s <span class="ot">-&gt;</span> [(f a, s2) <span class="op">|</span> (f, s1) <span class="ot">&lt;-</span> cs1 s, (a, s2) <span class="ot">&lt;-</span> cs2 s1])</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Parser</span> <span class="kw">where</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&lt;|&gt;) ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>  p <span class="op">&lt;|&gt;</span> q <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> \s <span class="ot">-&gt;</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> parse p s <span class="kw">of</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>      []     <span class="ot">-&gt;</span> parse q s</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>      res    <span class="ot">-&gt;</span> res</span></code></pre></div>
<p>저는 위 정의를 유심히 보지 않고, <code>Maybe</code>의 정의와 비슷하겠거니 하고 그냥 읽다가 헤맸습니다. 위 정의를 먼저 잘 봐야합니다.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>some digit</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> (    (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> digit <span class="op">&lt;*&gt;</span> many_v    ) <span class="st">&quot;12345&quot;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> (    (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> (\s <span class="ot">-&gt;</span> [(a,s)] 또는 \s <span class="ot">-&gt;</span> []) <span class="op">&lt;*&gt;</span> many_v ) <span class="st">&quot;12345&quot;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- 일단 &lt;*&gt; many_v 앞에 것부터</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>(<span class="op">:</span>) <span class="op">&lt;$&gt;</span> <span class="dt">Parser</span> (\s <span class="ot">-&gt;</span> 숫자파서) <span class="co">---------------------------------- (1번)</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Parser</span> (\s <span class="ot">-&gt;</span> [ ( (<span class="op">:</span>) a, b) <span class="op">|</span> (a, b) <span class="ot">&lt;-</span> 숫자파서 s])</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- &lt;*&gt; many_v를 붙이면</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="dt">Parser</span> (\s0 <span class="ot">-&gt;</span> [ ( (<span class="op">:</span>) a, b) <span class="op">|</span> (a, b) <span class="ot">&lt;-</span> 숫자파서 s0]) <span class="op">&lt;*&gt;</span> many_v</span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Parser</span> (\s <span class="ot">-&gt;</span> [(f a, s2) <span class="op">|</span> (f, s1) <span class="ot">&lt;-</span> (\s0 <span class="ot">-&gt;</span> [ ( (<span class="op">:</span>) a, b) <span class="op">|</span> (a, b) <span class="ot">&lt;-</span> 숫자파서 s0]) s       </span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>                            , (a, s2) <span class="ot">&lt;-</span> many_v s1] )</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- s에 문자열 &quot;12345&quot;가 들어가면</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> [(f a, s2) <span class="op">|</span> (f, s1) <span class="ot">&lt;-</span> (\s0 <span class="ot">-&gt;</span> [ ( (<span class="op">:</span>) a, b) <span class="op">|</span> (a, b) <span class="ot">&lt;-</span> 숫자파서 s0]) <span class="st">&quot;12345&quot;</span>       </span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>                            , (a, s2) <span class="ot">&lt;-</span> many_v s1] )</span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- s0에 문자열 &quot;12345&quot;가 들어가면</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> [(f a, s2) <span class="op">|</span> (f, s1) <span class="ot">&lt;-</span> ([ ( (<span class="op">:</span>) a, b) <span class="op">|</span> (a, b) <span class="ot">&lt;-</span> 숫자파서 <span class="st">&quot;12345&quot;</span>])        </span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>                            , (a, s2) <span class="ot">&lt;-</span> many_v s1] )</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> [(f a, s2) <span class="op">|</span> (f, s1) <span class="ot">&lt;-</span> ([ ( (<span class="op">:</span>) <span class="ch">'1'</span>, <span class="st">&quot;2345&quot;</span>) ])        </span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>                            , (a, s2) <span class="ot">&lt;-</span> many_v s1] )</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> [(f a, s2) <span class="op">|</span> (f 는 (<span class="op">:</span>) <span class="ch">'1'</span>, s1은 <span class="st">&quot;2345&quot;</span>) , (a, s2) <span class="ot">&lt;-</span> many_v <span class="st">&quot;2345&quot;</span>] </span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- 하스켈은 Lazy하니 여기까지 와서야 many_v를 (1번) &lt;*&gt; many_v 으로 reduce 합니다.</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> [   (f a, s2) <span class="op">|</span> (f 는 (<span class="op">:</span>) <span class="ch">'1'</span>, s1은 <span class="st">&quot;2345&quot;</span>) , (a, s2) <span class="ot">&lt;-</span> </span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>      [(f a, s2) <span class="op">|</span> (f 는 (<span class="op">:</span>) <span class="ch">'2'</span>, s1은 <span class="st">&quot;345&quot;</span>) , (a, s2) <span class="ot">&lt;-</span> many_v <span class="st">&quot;345&quot;</span>]</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>  ] </span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a><span class="co">-- many_v가 실패해서 &lt;|&gt; pure []를 만날 때까지 계속 적용하면</span></span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> [(f a, s2) <span class="op">|</span> (f 는 (<span class="op">:</span>) <span class="ch">'1'</span>, s1은 <span class="st">&quot;2345&quot;</span>) , (a, s2) <span class="ot">&lt;-</span> </span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>    [(f a, s2) <span class="op">|</span> (f 는 (<span class="op">:</span>) <span class="ch">'2'</span>, s1은 <span class="st">&quot;345&quot;</span>) , (a, s2) <span class="ot">&lt;-</span> </span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a>      [(f a, s2) <span class="op">|</span> (f 는 (<span class="op">:</span>) <span class="ch">'3'</span>, s1은 <span class="st">&quot;45&quot;</span>) , (a, s2) <span class="ot">&lt;-</span> </span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a>        [(f a, s2) <span class="op">|</span> (f 는 (<span class="op">:</span>) <span class="ch">'4'</span>, s1은 <span class="st">&quot;5&quot;</span>) , (a, s2) <span class="ot">&lt;-</span> </span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>          [(f a, s2) <span class="op">|</span> (f 는 (<span class="op">:</span>) <span class="ch">'5'</span>, s1은 <span class="st">&quot;&quot;</span>) , (a, s2) <span class="ot">&lt;-</span> many_v <span class="st">&quot;&quot;</span>] </span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a>      ]</span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a>  ] </span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a><span class="co">-- 가장 안 쪽 many_v = some_v &lt;|&gt; pure [] 는 &quot;&quot;를 받으니, a= '', s2 = &quot;&quot;</span></span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a><span class="co">-- (:) 프리픽스를 인픽스 형태로 쓰고, 안쪽부터 바깥으로 풀면서 나오면</span></span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a><span class="ch">'5'</span> <span class="op">:</span> <span class="st">&quot;&quot;</span> , <span class="st">&quot;&quot;</span></span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a><span class="ch">'4'</span> <span class="op">:</span> <span class="ch">'5'</span> <span class="op">:</span> <span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span></span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a><span class="ch">'3'</span> <span class="op">:</span> <span class="ch">'4'</span> <span class="op">:</span> <span class="ch">'5'</span> <span class="op">:</span> <span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span></span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a><span class="ch">'2'</span> <span class="op">:</span> <span class="ch">'3'</span> <span class="op">:</span> <span class="ch">'4'</span> <span class="op">:</span> <span class="ch">'5'</span> <span class="op">:</span> <span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span></span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a><span class="ch">'1'</span> <span class="op">:</span> <span class="ch">'2'</span> <span class="op">:</span> <span class="ch">'3'</span> <span class="op">:</span> <span class="ch">'4'</span> <span class="op">:</span> <span class="ch">'5'</span> <span class="op">:</span> <span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span></span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a><span class="co">-- 최종 결과는</span></span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a>[(<span class="st">&quot;12345&quot;</span>,<span class="st">&quot;&quot;</span>)]</span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a><span class="co">-- runParser는 튜플의 두 번째가 []이면 &quot;12345&quot;를 리턴하니</span></span>
<span id="cb36-48"><a href="#cb36-48" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;12345&quot;</span></span></code></pre></div>
<p>늘 그렇지만 막막한 정의를 따라 가다보면 숨도 차고, 살짝 한 숨도 나옵니다. 과연 이렇게 흘러갈 걸 다 알고, <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code>, <code>&lt;|&gt;</code> … 들을 정의 했을까요? 따라가기가 쉽지 않은데, 몇 가지 핵심은 다음과 같습니다.</p>
<ol type="1">
<li><code>&lt;*&gt;</code> 해석을 <code>Maybe</code> 인스턴스처럼 단순하게 <code>Parser</code> 안에 걸 꺼내는 것으로 하면 안됩니다. <code>Parser</code>의 <code>Applicative</code> 인스턴스에 있는 <code>&lt;*&gt;</code>를 먼저 잘 봐 두어야 합니다.</li>
<li>우리도 GHC만큼 충분히 Lazy해져야 합니다. <em>many_v는 그대로 두었다가 필요할 때 reduce하면 됩니다.</em></li>
<li>처음 가진 생각은 “<code>Parser [digit : digit :....]</code> 이렇게 <code>Parser</code>가 숫자 파서들로 이루어진 <code>리스트</code>인데, 여기에 어떻게 문자열 <code>"12345"</code>를 넣어주지?” 였습니다. 이 질문의 답은<br />
<code>(:)</code> 함수 때문에 오해해서 그렇습니다. <code>Parser</code>를 <code>&lt;*&gt;</code>로 묶으면 결과는 <code>Parser</code>입니다. <code>Parser</code> 타입이니 문자열을 받을 수 있습니다. 그럼 <code>(:)</code>는 언제 작동할까요? 파서를 반복하면서 얻은 결과들을 합쳐서 하나의 결과로 만들 때 씁니다. 파서를 리스트로 묶는게 아니라, 파서의 <em>파싱 결과를 리스트로 묶는</em> 겁니다. <code>Parser</code>에서 뿐만 아니라 어디에서든 <code>some</code>, <code>many</code>가 쓰이면 무언가를 반복하기 때문에 항상 결과를 리스트로 묶어야 합니다. 위에 고퍼 코드 중 <code>seq</code> 정의를 보면 파싱 결과를 튜플로 묶고 있는데,</li>
</ol>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>p ‘seq‘ q <span class="ot">=</span> \inp <span class="ot">-&gt;</span> [((v,w),inp’’) <span class="op">|</span> (v,inp’)  <span class="ot">&lt;-</span> p inp, (w,inp’’) <span class="ot">&lt;-</span> q inp’]</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>                      <span class="op">^^^^^</span></span></code></pre></div>
<p>이 것과 비슷하게 <code>&lt;*&gt;</code>는 묶을 때 쓸 함수를 <code>Parser</code> 타입에서 빼내와 넣을 수 있도록 <code>f</code>로 자리를 만들어 두었습니다. <code>some</code>에서 이 자리에 <code>(:)</code>을 넣어 결과를 묶고 있습니다.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Parser</span> cs1) <span class="op">&lt;*&gt;</span> (<span class="dt">Parser</span> cs2) <span class="ot">=</span> <span class="dt">Parser</span> (\s <span class="ot">-&gt;</span> [(f a, s2) <span class="op">|</span> (f, s1) <span class="ot">&lt;-</span> cs1 s, (a, s2) <span class="ot">&lt;-</span> cs2 s1])</span></code></pre></div>
<ol start="4" type="1">
<li>무한 재귀가 바깥으로 뻗어나오다 멈추면 따라가는게 조금 더 수월한데, 여기선 안쪽으로 계속 파고 들어가고 있습니다. 안 쪽에서 언젠가 멈춰야 최종 결과가 나옵니다. 그 때까지, 파고들어가며 미뤄 두다 reduce해야 합니다. 섣불리 미리 reduce하면 그 때부터 꼬이기 시작합니다. 미뤄둔 코드 덩어리들은 꼭 필요한 정보들이 결정 될 때까지 머릿속에서 조금도 reduce하지 마세요.</li>
</ol>
<p>한 번 더 <code>Parser</code> 타입의 인스턴스들을 정리하면, <code>Parser</code>를 묶는(접착, 연결, …) 브로커 함수들은 <em>대부분 첫째 파서의 결과를 두 번째 파서에 넣으면서 결과값들을 어떻게 정리하는지가 조금씩 다를 뿐</em>입니다. 파서들을 묶었으니, 뒷 파서들은 항상 앞 파서들의 결과를 받아야 합니다.</p>
<p>이제 <code>some</code>의 동작을 알았으니, 나머진 믿고 써야지요. 매 번 이렇게 함수들을 풀어서 이해하며 쓸 수는 없는 노릇입니다. 희미하게나마 함수들의 동작이 눈에 들어오면 믿고 넘어가야 합니다.</p>
<h2 id="역시-매직의-핵심-비밀은-바인드">역시 매직의 핵심 비밀은 바인드</h2>
<p><code>char</code> 파서 안에서 한 글자를 떼어내는 <em>item 파서</em>와 <em>unit 파서를 만들어 내는 함수</em>와 바인드 했습니다. 파서와 파서끼리 바인딩하지 않는 이유는, 파서의 결과를 그대로 가지고 다음 파서로 가는 게 아니라서 그렇고, 파싱 결과를 람다 변수에 저장하기 위해서이기도 합니다. <a href="../posts/2021-05-18-stateless.html">참고 - 상태 개념 포스트</a> 파서의 결과에 따라 다음 파서를 결정할 수도 있고, 아예 파싱 포기할수도 있고, 여러가지 상황에 따른 분기가 일어납니다. 그리고 또 한가지, <code>Maybe</code>모나드와 마찬가지로, 파서가 fail하면 더 이상 다음 함수를 아예 부르지 않고, 체인을 끝내도록 되어 있습니다.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>bind p f <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="fu">concatMap</span> (\(a, s') <span class="ot">-&gt;</span> parse (f a) s') <span class="op">$</span> parse p s</span></code></pre></div>
<p>파서들이 바인딩 되어 있을 때, 어느 한 파서라도 <code>[]</code>를 리턴하면 그냥 결과는 <code>[]</code>이 됩니다. 왜 그런지 정의에 넣어 보면, <code>concatMap</code>으로 함수를 <code>[]</code>에 적용하면 더 이상 다음 파서 연결 없이 체인은 끝납니다. 정말 모나드로 구현하기 딱 좋은 문제 같은데, 처음부터 이렇게 찰떡인 걸 알고 설계하기 시작했을까요?</p>
<p>파서로 다른 파서를 만드는 모양인데, 이런게 대수학algebra 아닐까요? 아직 파서 대수학이라 표기한 곳은 못 보긴 했는데, 문제 풀이를 이렇게 대수학 느낌으로 가는게 함수형 스타일입니다. 파서 구현이 모나드를 이용해서 정말 깔끔하고 짧게 구현됩니다. 그래서 그런지 하스켈로 만든 애플리케이션 중 파서를 충분히 활용하는 <a href="https://pandoc.org/">Pandoc</a>은 꽤 알려져 있습니다.</p>
<figure>
<img src="../images/pandoc.png" alt="하스켈이 낳은 아이돌 Pandoc" />
<figcaption aria-hidden="true">하스켈이 낳은 아이돌 Pandoc</figcaption>
</figure>
<h2 id="happy-alex">Happy &amp; Alex</h2>
<p>Happy는 c언어 파서를 뽑아내는 yacc처럼 하스켈 파서를 뽑아내는 파서 생성기입니다. 위에 봤던 콤비네이터들을 조합해서 만든 파서보다 빠르다고 합니다. Alex는 lex처럼 어휘lexeme 분석기를 뽑아내는 생성기입니다. GHC도 Happy와 Alex로 파서를 만들어서 쓸 정도로 충분히 파워풀하다고 합니다. 잊고 살았던 컴파일러 책을 다시 뒤적이다 그냥 덮었습니다. 지금은 XML, JSON, YML등의 범용 마크업 언어들이 자리잡아, 실전에서 규모 있는 파서를 만들 일이 거의 없어져서 조금 여유를 두고 보기로 했습니다.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>참고 
<a href="http://www.cs.nott.ac.uk/~pszgmh/monparsing.pdf">Monadic Parser Combinator - Graham Hutton, Erik Meijer</a><br />
<a href="https://www.cs.rit.edu/~swm/cs561/monadic-parsing-jfp.pdf">Functional Perl - Graham Hutton, Erik Meijer</a><br />
<a href="https://medium.com/@jooyunghan/javascript-모나딕-파서-c17fe5033f26">한주영님의 자바스크립트로 구현한 모나드 파서</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>상호 재귀Mutual recursion (상호 교차 재귀라고 썼었는데, 상호 재귀란 용어로 수정합니다. 상호 재귀가 일반적인 용어라 합니다.)
아래 코드는 “Programming in Haskell - Graham Hutton”에서 발췌했습니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">even</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">even</span> <span class="dv">0</span>       <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">even</span> n <span class="ot">=</span> <span class="fu">odd</span> (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="fu">odd</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="fu">odd</span> <span class="dv">0</span>       <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="fu">odd</span> n <span class="ot">=</span> <span class="fu">even</span> (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>재귀 하나만 나와도 머리가 복잡한데, 두 개가 교차로 부르고 있습니다. 어떻게 해석할까요?</p>
<p>하스켈은 Lazy합니다. 필요할 때 해석하고, 아직 필요하지 않을 때는 이름만 유지합니다.
<code>even을 부르면 odd를 부를거야.</code><br />
<code>odd를 부르면 even을 부를거야.</code>
만일 프로그램을 머릿속에서 시뮬레이션 하는데, 이렇게 서로를 불러대서 껄끄럽다면, 아칙 충분히 Lazy하지 않아서입니다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">even</span> <span class="dv">100</span> <span class="ot">=</span> <span class="fu">odd</span> <span class="dv">99</span></span></code></pre></div>
<p>아직 reduce 할게 남아 있으면 또 진행하면 됩니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">odd</span> <span class="dv">99</span> <span class="ot">=</span> <span class="fu">even</span> <span class="dv">98</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>어느 함수에서 <code>0</code>에 도달하냐에 따라 결과값은 <code>true | false</code> 로 달라집니다.
이게 읽는 건 충분히 Lazy하게 하다 보면 따라갈 수 있긴 있는데, 이런 구조가 떠오르긴 쉽지 않네요.
어쨌건 핵심은 Lazy입니다. 조금은 <em>무책임하게</em> 접근할 줄도 알아야 이런 아이디어가 떠오를 것 같습니다.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

<div class="comment">
  <script>
    document.addEventListener('DOMContentLoaded', loadUtterances, { once: true });
  </script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>

  </div>
  <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
  <div id="footer">
    © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
  </div>
  <script>
    tocbot.init({
      tocSelector: '.js-toc',
      contentSelector: '.js-toc-content',
      headingSelector: 'h2, h3',
      hasInnerContainers: true,
    });
  </script>
</body>

</html>
