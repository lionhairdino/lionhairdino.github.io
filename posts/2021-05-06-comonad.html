<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">

<head>
  <script>
    (function () {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark') {
        document.documentElement.classList.add('dark-mode');
      }
    })();

    function loadUtterances() {
      const savedTheme = localStorage.getItem('theme');
      const themeValue = savedTheme === 'dark' ? 'github-dark' : 'github-light';

      console.log("theme");
      console.log(themeValue);
      const script = document.createElement('script');
      script.src = 'https://utteranc.es/client.js';
      script.setAttribute('repo', 'lionhairdino/lionhairdino.github.io');
      script.setAttribute('issue-term', 'url');
      script.setAttribute('theme', themeValue);
      script.setAttribute('crossorigin', 'anonymous');
      script.async = true;
      document.body.appendChild(script);
    };

    function updateUtterancesTheme() {
      const savedTheme = localStorage.getItem('theme');
      const themeValue = savedTheme === 'dark' ? 'github-dark' : 'github-light';

      // Utterances iframe에 메시지 전송
      const utterances = document.querySelector('.utterances iframe');
      if (utterances) {
        utterances.contentWindow.postMessage(
          {type: 'set-theme', theme: themeValue},
          'https://utteranc.es'
        );
      }
    }

  </script>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>lionhairdino - 코모나드 comonad</title>
  
  <meta name="description" content="코모나드를 향한 수학쪽에서의 입구가 아니라, 프로그래밍적인 입구입니다." />
  <meta property="og:description" content="코모나드를 향한 수학쪽에서의 입구가 아니라, 프로그래밍적인 입구입니다." />
  
  <link rel="stylesheet" type="text/css" href="../css/default.css" />
  <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
  <link rel="shortcut icon" href="../favicon.ico" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
  <link rel="manifest" href="../site.webmanifest" />
  <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
  <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
  <meta name="msapplication-TileColor" content="#ff7500" />
  <meta name="theme-color" content="#ffffff" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="코모나드 comonad" />
  <meta property="og:site_name" content="Lionhairdino" />
  <meta property="og:url" content="https://lionhairdino.github.io/posts/2021-05-06-comonad.html" />
  
  <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />
  
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-E9WZ6VXGHP');
  </script>
  <script src="../script/copycode.js"></script>

  <script src="../script/darkmode.js"></script>
  <script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
  <meta name="fediverse:creator" content="@lionhairdino@mastodon.social" />
  <link rel="alternate" type="application/rss+xml" title="상상 하스켈 - Lionhairdino" href="rss.xml" />
</head>

<body>
  <div id="header">
    <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
      <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
    </div>
    <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
      <a href="../">lionhairdino</a>
      <a href="../about.html">about</a>
      <!--<a href="/archive.html">archive</a>-->
    </div>
    <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
      <div style="display:inline-block;vertical-align: top;padding-top: 5px"></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:18px;border:none" src="../images/bluesky.svg"></a>
      </div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://discordapp.com/users/lionhairdino#7687"><img style="width:20px;border:none" src="../images/discord.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://x.com/lionhairdino"><img style="width:15px;border:none" src="../images/X.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://linkedin.com/in/lionhairdino-l-baaa54244"><img style="width:20px;border:none" src="../images/linkedin.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://github.com/lionhairdino"><img style="width:20px;border:none" src="../images/github.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://www.threads.net/@linohairdino"><img style="width:20px;border:none" src="../images/threads.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a rel="me" href="https://hackers.pub/@lionhairdino">Hackers'Pub</a></div>
    </div>
    <div>
      <div style="display:inline-block;width:180px;">
        <div class="gcse-searchbox-only"></div>
        <div><button id="theme-toggle">
            <script>
              const savedTheme = localStorage.getItem('theme');
              if (savedTheme === 'dark')
                document.write("☉");
              else
                document.write("☾");
            </script>
          </button></div>
      </div>
    </div>
    <div>
      여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다. 여기 글을 처음 읽는 분은, 먼저 <a href="../warning.html">주의문</a>을 꼭 읽어보세요.
    </div>
  </div>
  <div class="js-toc-content">
    <h1>코모나드 comonad</h1>
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on May  6, 2021
    
</div>

<p>2022.7.31 추가
effect와 context를 구별해서 써야 합니다. 모나드는 effect가 있는 계산을 위한 것이고, 코모나드는 context를 처리합니다. 구체적 내용을 따로 올리겠습니다.</p>
<p>모나드 트라우마로 움찔한 분들은 코모나드란 용어가 나오기 전까진 코모나드는 잠깐 잊어버리고 보는 게 더 나을 수 있습니다.</p>
<p>지금까지 알게 모르게 이미 아래 같은 패턴으로 코딩한 적이 있을 수도 있습니다. 아래서 참조한 가브리엘 글의 제목도 you could have invented comonads 입니다.</p>
<h2 id="몸풀기">몸풀기</h2>
<p>몸풀기를 잠깐 하고 넘어 가도록 하겠습니다.</p>
<p>고차 함수, 람다 함수를 활용한 방법</p>
<h3 id="가-인자-하나를-넣어-주면-속성을-지정해서-가지고-있는-것과-같다.">(가) – 인자 하나를 넣어 주면, 속성을 지정해서 가지고 있는 것과 같다.</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">haveProperty ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> ( (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> )</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>haveProperty x <span class="ot">=</span> \f <span class="ot">-&gt;</span> f x</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="kw">let</span> personA <span class="ot">=</span> haveProperty <span class="dv">10</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="kw">let</span> personB <span class="ot">=</span> haveProperty <span class="dv">100</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> personA (<span class="op">+</span><span class="dv">20</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dv">30</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> personB (<span class="op">+</span><span class="dv">20</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="dv">120</span></span></code></pre></div>
<h3 id="나-미리-함수를-넣어-놓기">(나) – 미리 함수를 넣어 놓기</h3>
<p>위 (가)와 같은데, 함수를 넘겨서 갖고 있게 할 수도 있습니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">haveFunc ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>haveFunc f <span class="ot">=</span> \x <span class="ot">-&gt;</span> f (x <span class="op">+</span> <span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="kw">let</span> toolA<span class="ot">=</span> haveFunc (<span class="op">+</span><span class="dv">2</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="kw">let</span> toolB <span class="ot">=</span> haveFunc (<span class="op">+</span><span class="dv">3</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> toolA <span class="dv">1</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> toolB <span class="dv">1</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span></span></code></pre></div>
<h3 id="다-함수명과-인자의-순서를-바꾸기-위한-헬퍼">(다) – 함수명과 인자의 순서를 바꾸기 위한 헬퍼</h3>
<p>그리고, 표현을 매끄럽게 하기 위해 (기존 OOP에서 쓰던 익숙한 흐름으로 바꾸기 위해) 함수명과 인자 순서를 거꾸로 써주기 위한 연산자를 정의합니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Data.Function에 있는 (&amp;)와 같은 함수입니다.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 굳이 정의하지 않아도 되는데, 원문에 따라 일단 보고 지나 가겠습니다.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">(#) ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">#</span> f <span class="ot">=</span> f x</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">0</span> <span class="op">#</span></span></code></pre></div>
<p>※ 아래는 Gabriel Gonzalez의 블로그 <a href="https://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html" class="uri">https://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html</a>의 코드 일부를 발췌했습니다.</p>
<h2 id="builder-패턴">Builder 패턴</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Option</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Builder</span> <span class="ot">=</span> [<span class="dt">Option</span>] <span class="ot">-&gt;</span> <span class="dt">Config</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Config</span> <span class="ot">=</span> <span class="dt">MakeConfig</span> [<span class="dt">Option</span>] <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="ot">defaultConfig ::</span> <span class="dt">Builder</span> </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>defaultConfig options <span class="ot">=</span> <span class="dt">MakeConfig</span> ([<span class="st">&quot;-default&quot;</span>] <span class="op">++</span> options)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="ot">opt1 ::</span> <span class="dt">Builder</span> <span class="ot">-&gt;</span> <span class="dt">Config</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>opt1 builder <span class="ot">=</span> builder [<span class="st">&quot;-opt1&quot;</span>, <span class="st">&quot;-opt1-1&quot;</span>]</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="ot">opt2 ::</span> <span class="dt">Builder</span> <span class="ot">-&gt;</span> <span class="dt">Config</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>opt2 builder <span class="ot">=</span> builder [<span class="st">&quot;-opt2&quot;</span>]</span></code></pre></div>
<p>위 도구에서 보았던 속성을 먼저 가지고 있는 스타일로 옵션 지정을 하는 코드입니다. 빌더 함수를 넣어서 안에 들어 있는 리스트에 적용합니다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> defaultConfig <span class="op">#</span> opt1</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="dt">MakeConfig</span> [<span class="st">&quot;-default&quot;</span>,<span class="st">&quot;-opt1&quot;</span>,<span class="st">&quot;-opt1-1&quot;</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> defaultConfig <span class="op">#</span> opt2</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dt">MakeConfig</span> [<span class="st">&quot;-default&quot;</span>,<span class="st">&quot;-opt2&quot;</span>]</span></code></pre></div>
<h2 id="아직-일이-끝나지-않았다---실행되지-않은-함수">아직 일이 끝나지 않았다 -&gt; 실행되지 않은 함수</h2>
<p>하지만 <code>opt1</code>과 <code>opt2</code>는 완성된 <code>Config</code>를 리턴합니다. 그럼 <code>opt1</code>과 <code>opt2</code> 두 개 모두 옵션 리스트에 넣으려면 어떻게 할까요? 최종 모양부터 상상하면, (다)를 이용해서 <code>defaultConfig # opt1 # opt2</code> 쯤 되는 모양으로 만들려고 합니다. 하스켈에선 뭔가 연이은 동작을 만들 땐 함수로 엮는 방법이 주로 쓰입니다. ※ 무언가 완성되지 않은 상태로 둔다는 말은 <em>“함수”로 만들어 둔다</em>와 같은 말입니다. 이 것도 함수형 스타일로 생각하는 하나의 팁입니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">opt1' ::</span> <span class="dt">Builder</span> <span class="ot">-&gt;</span> <span class="dt">Builder</span> </span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>opt1' builder <span class="ot">=</span> \options <span class="ot">-&gt;</span> builder ([<span class="st">&quot;-opt1&quot;</span>, <span class="st">&quot;-opt1-1&quot;</span>] <span class="op">++</span> options)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="ot">opt2' ::</span> <span class="dt">Builder</span> <span class="ot">-&gt;</span> <span class="dt">Builder</span> </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>opt2' builder <span class="ot">=</span> \options <span class="ot">-&gt;</span> builder ([<span class="st">&quot;-opt2&quot;</span>] <span class="op">++</span> options)</span></code></pre></div>
<p>이미 가지고 있던 속성에 인자로 받아 온 함수를 적용했는데, 이 걸 바로 실행하지 않고, 인자 하나를 더 받을때까지 실행을 미루기 위해 (나) 방식으로 만들어 놓습니다.</p>
<p><code>Builder -&gt; Config</code>였던 타입이 <code>Builder -&gt; Builder</code>가 되어, 옵션 체인을 만들 수 있도록 입출력 타입이 같게 되었습니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>            builder  [<span class="st">&quot;-opt1&quot;</span>, <span class="st">&quot;-opt1-1&quot;</span>] <span class="co">-- opt1 결과가 Config 타입</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>\options <span class="ot">-&gt;</span> builder ([<span class="st">&quot;-opt1&quot;</span>, <span class="st">&quot;-opt1-1&quot;</span>] <span class="op">++</span> options) <span class="co">-- opt' 결과가 Builder 타입 = [Options] -&gt; Config</span></span></code></pre></div>
<p>그리고, 더 이상 연결할 옵션이 없을 때 완성된 <code>Config</code>를 뽑아내기 위해 <code>extract</code>를 만듭니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">extract ::</span> <span class="dt">Builder</span> <span class="ot">-&gt;</span> <span class="dt">Config</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>extract builder <span class="ot">=</span> builder []</span></code></pre></div>
<p>그럼 아래와 같이 체인 형태로 쓸 수 있습니다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> defaultConfig <span class="op">#</span> opt1' <span class="op">#</span> opt2' <span class="op">#</span> extract</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="dt">MakeConfig</span> [<span class="st">&quot;-default&quot;</span>,<span class="st">&quot;-opt1&quot;</span>,<span class="st">&quot;-opt1-1&quot;</span>,<span class="st">&quot;-opt2&quot;</span>]</span></code></pre></div>
<p>이렇게 <code>opt</code>를 <code>opt'</code>으로 만들면 체인이 가능하게 됩니다. 그럼 만약 기존 코드가 이미 <code>opt</code> 스타일로 많이 만들어졌다면, 일일이 <code>Builder</code> 리턴 타입으로 바꾸는 것보다 변환 함수를 하나 만들어 쓰는게 좋습니다. 헛갈리지 않게 opt1과 opt2의 람다 변수 이름을 바꿔 놓겠습니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>opt1 <span class="ot">=</span> \bf <span class="ot">-&gt;</span> bf [<span class="st">&quot;-opt1&quot;</span>, <span class="st">&quot;-opt1-1&quot;</span>]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>opt2 <span class="ot">=</span> \bf <span class="ot">-&gt;</span> bf [<span class="st">&quot;-opt2&quot;</span>]</span></code></pre></div>
<p><code>opt1</code> 안에 들어 있는 옵션과 <code>opt2</code> 안에 들어 있는 옵션을 묶어 놓고, 바깥에서 들어온 <code>builder</code>를 적용하는 모양이 되어야 합니다. 처음엔 함수를 변형한다고 하니, 함수를 어떻게 해체해야 하는지 난감했습니다. <em>opt1 함수를 변형하는 방법 중 하나는 어떤 함수를 넣어 정보를 해체하는 겁니다.</em></p>
<h2 id="완성되어-있는-고차-함수-내부를-조작하려면">완성되어 있는 고차 함수 내부를 조작하려면?</h2>
<p>함수가 외부와 소통하는 방법은 매개 변수뿐이 없습니다. 값을 주고 받을 때 뿐만 아니라, 함수 동작을 조작할때도 이용할 수 있는 통로는 매개 변수뿐이 없습니다. 안 쪽에 들어가서 변형시켜 놓을 함수(가)를 매개 변수에 넣어주면 됩니다. 변형된 모양은</p>
<pre class="hasekll"><code>\o -&gt; \builder -&gt; ... builder ( ... )</code></pre>
<p>빌더 타입이어야 합니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>\builder <span class="ot">-&gt;</span> \o2 <span class="ot">-&gt;</span>     (\bf <span class="ot">-&gt;</span> bf [<span class="st">&quot;-opt1&quot;</span>,<span class="st">&quot;-opt1-1&quot;</span>])      (\o1 <span class="ot">-&gt;</span> builder (o1 <span class="op">++</span> o2))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>                       <span class="op">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>      <span class="op">^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>                                   original                 o1을 뽑아 o2와 합치는 함수 <span class="co">-- (가)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>\builder <span class="ot">-&gt;</span> \o2 <span class="ot">-&gt;</span>     builder ([<span class="st">&quot;-opt1&quot;</span>,<span class="st">&quot;-opt1-1&quot;</span>] <span class="op">++</span> o2) </span></code></pre></div>
<p><code>\o1</code>으로 <code>opt1</code>이 가진 옵션을 뽑아내 나중에 들어 올 <code>o2</code>와 합쳐 놓습니다. 위에서 본 <code>opt1'</code>과 같은 모양이 나왔습니다. 변형해 주는 함수를 <code>extend</code>라 이름 붙이면 다음과 같이 정리할 수 있습니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>extend original <span class="ot">=</span> \builder <span class="ot">-&gt;</span> \o2 <span class="ot">-&gt;</span> original (\o1 <span class="ot">-&gt;</span> builder (o1 <span class="op">++</span> o2)) </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>extend original builder <span class="ot">=</span> \o2 <span class="ot">-&gt;</span> original (\o1 <span class="ot">-&gt;</span> builder (o1 <span class="op">++</span> o2))</span></code></pre></div>
<p><code>extend</code>를 정의한 후에는 원래 함수에 <code>extend</code>를 적용해주면 위의 최종 결과와 같은 결과가 나옵니다.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> defaultConfig <span class="op">#</span> extend opt1 <span class="op">#</span> extend opt2 <span class="op">#</span> extract</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="dt">MakeConfig</span> [<span class="st">&quot;-default&quot;</span>,<span class="st">&quot;-opt1&quot;</span>,<span class="st">&quot;-opt1-1&quot;</span>,<span class="st">&quot;-opt2&quot;</span>]</span></code></pre></div>
<h2 id="코모나드">코모나드</h2>
<p>위에서 나온 extract, extend의 조합이 바로 코모나드입니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- extract :: Builder -&gt; Config </span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- type Builder a = [Option] -&gt; a 으로 볼 수 있습니다.</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="ot">extract ::</span> <span class="dt">Builder</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="ot">extend ::</span> (<span class="dt">Builder</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Builder</span> a <span class="ot">-&gt;</span> <span class="dt">Builder</span> b</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- 코모나드 메소드</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="ot">extract ::</span> w a <span class="ot">-&gt;</span> a</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="ot">extend ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span></code></pre></div>
<p>가브리엘 곤잘레즈 글의 첫 번째 섹션의 소스 코드를 옮겨서 풀어 봤는데, 읽고 나니 원 글이 훨씬 나아 보입니다. 여기 글은 <code>extend</code> 정의가 쉽게 이해가지 않을 때 보충해서 보면 좋을 것 같습니다.</p>
<p>수학적으로 모나드의 듀얼이라 하고 시작하는 순간부터, 또 한번의 모나드 전쟁이 생기진 않을까 두려워집니다. 이론적인 바탕보다 먼저 코드로 풀이한 후 접근하는 게 편한 분들도 있을 겁니다. 모나드만큼 여기 저기 쓰이는 패턴은 아닙니다. 원 글에 따르면 하스켈에서 모나드가 명령형 프로그래밍 비슷한 모양을 보여준다면, 코모나드는 OOP스런 모양을 보여주는 패턴이라 합니다.</p>
<p>나중에 코모나드와 연관된 글을 더 올리도록 하고, 여기서는 <code>w a -&gt; b</code> 함수 연결(엮는 것)을 어떻게 하는지 보는 정도로 만족하고 넘어가겠습니다. 모나드도 특정 형태의 함수를 엮는 방법이고, 코모나드도 특정 형태의 함수를 엮는 방법입니다.</p>
<p><code>w a</code>로 표기한 이유는 <code>w</code>가 모나드의 <code>m</code>을 거꾸로 놓았다는 뜻에서 <code>w</code>를 쓴다고 합니다.</p>
<p>동작은 알겠는데, 이게 왜 모나드의 듀얼, 코모나드란 이름을 가졌을까요? 사실, 이런 건 궁금해하지 않고 넘어가도 되는데, 이런데서 머뭇거리는게 좋은 건지 나쁜 건지 모르겠습니다. 모나드는 <code>a -&gt; m a</code> 액션을 엮는 패턴이었습니다. 여기서 화살표를 반대로 한 걸 듀얼<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>이라 한다는데, 이게 가지는 실용적인 의미가 뭘까요?</p>
<p>2022.6.3 추가 (하스켈 학교 디스코드 #코모나드 채널에 제가 올렸던 글을 정리했습니다.)</p>
<h2 id="모나드와-비교">모나드와 비교</h2>
<p>직관적으로 지니는 의미가 뭘지 살펴보겠습니다.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</span></code></pre></div>
<p>모나드에서는 <code>m</code>이 만들어내는 effect를 잃어버리지 않기 위해 <code>join</code>으로 effect algebra를 했는데, 코모나드는 <code>context</code>를 <code>duplicate</code>하고 있습니다.모나드가 effect 두 개를 합쳐서 하나로 표현할 수 있는 것들만 모나드 구조로 만들 수 있듯이, 코모나드는 <code>context</code> 하나를 복사<code>duplicate</code>해서 또 적용해도 의미가 있는 것들만 코모나드로 만들 수 있습니다.</p>
<p>모든 모나드들과 대응하는 코모나드가 있는 건 아닙니다. - 검증 필요</p>
<p><code>List</code> 모나드가</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>join 해서</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]</span></code></pre></div>
<p>으로 봐도 의미가 있었듯이</p>
<p><code>Stream</code> 코모나드는</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,…]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>duplicate하면 </span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>[ [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,…] , [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,…] , [<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,…],…]</span></code></pre></div>
<p>가 의미가 있는 구조입니다. 완벽하게 똑같이 복사한게 아니라, 첫번째 값이 계속 다르게 복사하고 있음을 주의해서 봐두세요.</p>
<p>또한 <code>extract</code>도 가능해야 합니다.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">extract ::</span> w a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p><code>Maybe Int</code> 모나드의 경우</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">1</span> —<span class="ot">-&gt;</span> <span class="dv">1</span>, </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">2</span> —<span class="ot">-&gt;</span> <span class="dv">2</span>, </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>… 등은 되지만, </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span> —<span class="ot">-&gt;</span> <span class="op">?</span></span></code></pre></div>
<p>이기 때문에 코모나드로 만들 수 없습니다.</p>
<p><code>Stream</code> 코모나드는 포커싱된 하나를 꺼내는 걸로 <code>extract</code>를 정하고 있습니다.</p>
<p>effect를 만들어 내는 함수들을 컴포지션할 때 생겨나는 모든 effect를 잃어버리지 않기 위해 모나드 패턴이 필요했는데,
<em>context를 버려도 의미있는 함수들을 커포지션 할 때 코모나드를 쓰고 있습니다</em></p>
<p>바인드의 듀얼인 <code>extend</code>를 보면</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">extend ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span></code></pre></div>
<blockquote>
<p>Q. <code>w a</code>에 그냥 <code>w a -&gt; b</code> 함수를 적용하면 안되나요?<br />
A. 마치 <code>w a</code>에 <code>(w a -&gt; b)</code>를 바로 적용해도 될 것처럼 보입니다. 그런데, 그렇게 적용해 버리면 <code>b</code>가 나오고, 코모나드는 이 걸 <code>w b</code>로 만들 방법을 제공하지 않습니다. 그래서 컨텍스트를 유지한채로 적용하기 위해 <code>fmap</code>을 정의하면 <code>duplicate :: w a -&gt; w (w a)</code>가 필요한 모양이 나옵니다. (꼭, <code>w</code>가 새로 생기거나 하는 게 아니라, shift 하는 느낌입니다.)</p>
</blockquote>
<blockquote>
<p>Q. <code>fmap</code>으로 적용해도 <code>w</code>가 없어지는 것 아닌가요?
A. <code>m a</code>에서 <code>m</code>을 떼어내고 <code>a</code>를 반환하는 순간 <code>m</code>은 다시 살려낼 수 없습니다. 그런데 <code>fmap</code>도 내부 동작을 보면 패턴 매칭으로 <code>m</code>을 벗겨내고 있습니다. 하지만, 그 <code>m</code>은 스코프에 남아 있는 상태로 처리하고, <code>a</code>에 함수 적용을 마치고 난 후 그 걸 다시 가져와 합친 다음 반환합니다. 그래서, 이 걸 컨텍스트를 유지한다고 말합니다.</p>
</blockquote>
<h2 id="왜-a---w-a는-안되는데-w-a---w-w-a는-가능한가">왜 a -&gt; w a는 안되는데 w a -&gt; w (w a)는 가능한가?</h2>
<p><a href="../posts/2022-03-25-beforeMonad.html">모나드</a>에서 <code>m a -&gt; a</code> 는 effect를 담아둘 곳이 없어 불가능하지만, <code>m (m a) -&gt; m a</code> 는 effect 두 개를 <code>join</code>해서 <code>m</code>에 담아 둘 수 있어 가능했습니다. 이와 비슷하게 코모나드는 <code>a -&gt; w a</code> 는 <code>w</code>를 만들어내질 못하니 불가능하지만, <code>w a -&gt; w (w a)</code>는 기존 가지고 있던 <code>w</code>를 <code>duplicate</code>하니 가능합니다.
다르게 표현하면,
<code>join</code>으로 합친 것이 effect를 잃어버리지 않는 경우만 모나드로 만들 수 있었던 것처럼,
<code>duplicate</code>로 복사한게 context로써의 의미가 있는 경우만 코모나드로 만들 수 있습니다.</p>
<h2 id="코모나드는-모든-가능한-경우의-context를-가지고-시작한다.">코모나드는 모든 가능한 경우의 context를 가지고 시작한다.</h2>
<p>모나드는 컨텍스트를 유지하며 computation하는 동안 effect를 언제든 만들어내지만, 코모나드는 처음 컨텍스트 computation을 시작할 때부터 필요한 모든 context를 가지고 시작해야 합니다. <code>duplicate</code>의 아이디어는 시작할 때부터 갖고 있는, 여러 context중 현재 가리키는 context를 달리하며 <code>w</code>로 감싸는 것입니다. <code>w a</code>와 <code>w(w a)</code>가 가리키는 context는 다를 수 있습니다. <code>Product</code> 코모나드는 이 context가 하나의 값인 특수한 경우입니다. 정리하면 <em>duplicate는 완전 똑같이 복사하는 게 아니라 current값, 또는 focus되는 정보는 다르게 복사</em>한다고 말합니다.</p>
<h2 id="context-복사duplicate">Context 복사duplicate</h2>
<p>CoKleisli arrow <code>w a -&gt; b</code>가 context를 지우는 것에 눈이가 어떻게 context를 없애면서 의미가 있을 수 있을까 고민했습니다. 바인드의 듀얼인 <code>extend</code>의 반환값은 <code>b</code>가 아니라 context가 살아 있는 <code>w b</code>입니다. context가 지워지는 것은 아니었습니다. <code>w</code>를 조금씩 다르게 복사, 유지하며 computation을 한다가 코모나드의 직관입니다.</p>
<h2 id="context가-하나로-고정일-때-reader-모나드-product-코모나드">context가 하나로 고정일 때 Reader 모나드, Product 코모나드</h2>
<p>새로 effect가 계속 추가되는 computation은 모나드가 어울리고, 필요한 context는 모두 있는 상황에서 조금씩 다른 걸 고르는 computation은 코모나드가 어울립니다. 그래서 변하지 않는 환경값을 참조하는 effect는 <code>Reader</code> 모나드로도 <code>Product</code> 코모나드로도 표현될 수 있었던 겁니다.</p>
<h2 id="store-코모나드">Store 코모나드</h2>
<p>대표적인 코모나드로 Store 코모나드가 있습니다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  extract ::</span> w a <span class="ot">-&gt;</span> a</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  extend ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> s a <span class="ot">=</span> <span class="dt">Store</span> (s <span class="ot">-&gt;</span> a) s</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Comonad</span> (<span class="dt">Store</span> s) <span class="kw">where</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  extract (<span class="dt">Store</span> f s) <span class="ot">=</span> f s</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  duplicate (<span class="dt">Store</span> f s) <span class="ot">=</span> <span class="dt">Store</span> (<span class="dt">Store</span> f) s</span></code></pre></div>
<h3 id="타입만으로-duplicate가-필요한-이유-찾아-보기">타입만으로 duplicate가 필요한 이유 찾아 보기</h3>
<p><code>(w a -&gt; b)</code> 를 <code>w a</code> 에 적용하면 <code>w</code>는 사라지고 <code>b</code>만 남습니다. <code>w</code>를 잃어버리지 않기 위해 <code>w a</code> 를 <code>w</code>를 한 번 더 씌워 <code>w (w a)</code>로 만들어 버리고,<code>fmap (w a -&gt; b) $ w (w a)</code> 를 하면 안 쪽에 있는 <code>w</code>는 사라지고 <code>b</code>만 남지만 바깥에 복사해 둔 <code>w</code>가 살아 있어, <code>w b</code>를 리턴할 수 있습니다.</p>
<h3 id="fmap">fmap</h3>
<p><code>join</code>이 <code>Just Nothing</code>을 <code>Nothing</code>으로 만들고, <code>((a, "log1"), "log2")</code>를 <code>(a, "log1 log2")</code>로 만들었듯이
<code>w a</code> 를 <code>w (w a)</code>로 <code>w</code>를 복사해 두면, 이를 벗기는 과정에 코모나드의 성격을 결정하는 작업이 들어갑니다.
<code>Store f s</code> 가 <code>Store (Store f) s</code> 가 됐다는 얘기는 <code>s</code>에 접근하려면 <code>Store</code>를 두 번 벗겨야 합니다.<br />
<code>Store</code> 하나를 벗길 때, 어떤 작업을 하는지는 <code>fmap</code>을 보면 됩니다.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Store</span> s) <span class="kw">where</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Store</span> g s) <span class="ot">=</span> <span class="dt">Store</span> (f <span class="op">.</span> g) s</span></code></pre></div>
<p>두 번 쌓여 있는 값에 <code>fmap</code>을 적용하면 다음 모양이 됩니다.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">Store</span> (<span class="dt">Store</span> f1) s) <span class="ot">=</span> <span class="dt">Store</span> (f <span class="op">.</span> (<span class="dt">Store</span> f1)) s</span></code></pre></div>
<p>플레인 <code>s</code>에 도달하려면 어떤 작업이 필요한지 보면 <code>Store</code>의 동작을 확실히 알 수 있을 것 같습니다.</p>
<p><code>Store</code>의 <code>duplicate</code>를 다음처럼 표현하기도 합니다. 매개 변수의 의미가 확실히 보이도록 바꾸겠습니다.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>duplicate (<span class="dt">Store</span> first warehouse)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Store</span> (<span class="dt">Store</span> first) warehouse <span class="co">-- extract 하면 Store first warehouse  </span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Store</span> (\nextwh <span class="ot">-&gt;</span> <span class="dt">Store</span> first nextwh) warehouse </span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- extract 하면 Store first warehouse </span></span></code></pre></div>
<p><code>w (w a)</code>에 <code>fmap f</code>를 적용하면</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">Store</span> (\nextwh <span class="ot">-&gt;</span> <span class="dt">Store</span> first nextwh) warehouse)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Store</span> (f <span class="op">.</span> (\nextwh <span class="ot">-&gt;</span> <span class="dt">Store</span> first nextwh)) warehouse</span></code></pre></div>
<p><code>f</code>는 <code>Store</code>를 받으면 플레인값을 돌려주는 함수입니다. 체이닝이 되어 있는 상태에서 <code>extract</code>를 실행하면</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>(f <span class="op">.</span> (\nextwh <span class="ot">-&gt;</span> <span class="dt">Store</span> first nextwh)) warehouse</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>f ( <span class="dt">Store</span> first warehouse )</span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Store</span> a warehouse <span class="co">--warehouse에서 처음걸 가리키는 상태</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="ot">movenext ::</span> <span class="dt">Store</span> (warehouse <span class="ot">-&gt;</span> a) warehouse <span class="ot">-&gt;</span> a</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>extract <span class="op">$</span> <span class="dt">Store</span> f warehouse <span class="op">=&gt;=</span> movenext <span class="op">=&gt;=</span> movenext</span></code></pre></div>
<p>이런 식의 체이닝으로 쓸 수 있게 됩니다.</p>
<h3 id="extend-vs-bind">extend vs bind</h3>
<p>모나드에서 <code>bind</code>는 <code>fmap</code>을 적용해서 <code>m (m a)</code>가 된 걸 <code>join</code>을 적용해 <code>m a</code>로 만들고,<br />
코모나드에서 <code>extend</code>는 <code>duplicate</code>를 적용해서 <code>w (w a)</code>가 된 것에 <code>fmap</code>을 적용해서 <code>w a</code>가 됩니다.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>bind는      join (fmapM f (<span class="fu">return</span>       a) )</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>extend는 extract (fmapW f (duplicate (w a)))</span></code></pre></div>
<p>첫 의문이 <code>duplicate</code>가 왜 <code>Store (Store f) s</code> 모양일까였는데, <code>extract</code>를 적용해서 <code>Store f s</code>가 나오게 하려면 어떤 모양이어야 하나 생각하면 수긍이 갑니다.</p>
<h3 id="costate">CoState</h3>
<p><code>Store</code> 코모나드는 <code>State</code>의 <code>Co</code>입니다. (<code>CoState</code> 코모나드라 부르기도 합니다.)</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">State</span> monad       s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="dt">CoState</span> comonad   (s <span class="ot">-&gt;</span> a, s)</span></code></pre></div>
<h2 id="언제-코모나드를-떠올리면-될까">언제 코모나드를 떠올리면 될까?</h2>
<p><code>State</code>는 창고가 변하고,<br />
<code>Store</code>는 창고는 그대로인데, 가리키는 함수만 변합니다.</p>
<p>가능한 모든 context를 모아 놓고 골라야 하는 상황일 때 코모나드를 떠올리면 됩니다.</p>
<p>참고<br />
<a href="https://functorial.com/the-future-is-comonadic/main.pdf">필 프리먼의 the future is comonadic</a><br />
<a href="https://fmapfixreturn.wordpress.com/2008/07/09/comonads-in-everyday-life/">웹사이트 UI로 설명</a><br />
<a href="https://bartoszmilewski.com/2017/01/02/comonads/">바르토즈 밀레위스키의 코모나드</a><br />
<a href="http://comonad.com/reader/2018/the-state-comonad/">Comonad.com</a></p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>역inverse이란 원래대로 되돌리는 작업이고, 쌍대성duality이란 어떤 현상이나 조건이 반전된 개별 대상.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

<div class="comment">
  <script>
    document.addEventListener('DOMContentLoaded', loadUtterances, { once: true });
  </script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>

  </div>
  <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
  <script>
    tocbot.init({
      tocSelector: '.js-toc',
      contentSelector: '.js-toc-content',
      headingSelector: 'h2, h3',
      hasInnerContainers: true,
    });
  </script>
  <div id="footer">
    © 2025 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
  </div>
</body>

</html>
