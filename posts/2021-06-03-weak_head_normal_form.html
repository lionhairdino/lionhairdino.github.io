<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - Weak Head Normal Form</title>

        <meta name="description" content="람다 대수학 용어인 Weak Head Normal Form이 하스켈에서 왜 가장 바깥 생성자로 나타나는지 살펴봤습니다." />
        <meta property="og:description" content="람다 대수학 용어인 Weak Head Normal Form이 하스켈에서 왜 가장 바깥 생성자로 나타나는지 살펴봤습니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Weak Head Normal Form" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2021-06-03-weak_head_normal_form.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

      <meta name="keywords" content="lazy, nf, normal form, hnf, weak head normal form">
<script src="../script/copycode.js"></script>

    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../">lionhairdino</a> 
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
        </div>

        <div id="content">
            <h1>Weak Head Normal Form</h1>

            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on June  3, 2021
    
</div>

<p>또 한 번 용어가 찜찜함을 남기네요. 그냥 바깥 생성자나 람다식을 WHNF로 보고 넘어가면 되는데, 왜 이런 용어를 붙였는지가 궁금해서 또 서핑의 늪에 빠져 버렸습니다.</p>
<p><em>이해한 생각을 정리한 게 아니라, 추측한 내용을 길게 적어 놓았습니다.</em></p>
<p>NFData의 seq 함수 동작을 보다 보니, 혼동이 왔습니다. 분명 lazy를 잘 못 아해하고 있습니다. lazy는 아무것도 안하고 지나가는게 아니라, 완벽하게 끝내진 않더라도 때에 따라 일정 단계까지는 해석하고 지나갑니다. lazy는 지나가면서 나중에 실행하겠다는 계획만 잡고, 지금은 실행을 하나도 하지 않는다는 뜻이 아닙니다. 이 일정 단계가 바로 WHNF입니다. 표현식은 여러번 reduce를 거쳐 최종 값에 도달하는데, 어느 단계까지 도달했냐에 따라 이름을 붙여놨습니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>add (add <span class="dv">1</span> <span class="dv">2</span>) (add <span class="dv">3</span> <span class="dv">4</span>) <span class="co">------(가)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> (add <span class="dv">1</span> <span class="dv">2</span>) <span class="op">+</span> (add <span class="dv">3</span> <span class="dv">4</span>) <span class="co">------(나) WHNF</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> (<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>) <span class="op">+</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>) <span class="co">----------(다) WHNF</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">3</span> <span class="op">+</span> <span class="dv">7</span> <span class="co">----------------------(라) WHNF</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dv">10</span> <span class="co">-------------------------(마) WHNF, NF</span></span></code></pre></div>
<p>(가)를 만나면, 어느 단계까지 평가하고 뒤로 미룰까요?</p>
<p>먼저 몇 개 용어를 살펴 보겠습니다.</p>
<ul>
<li><a href="#normal-form---nf">Normal Form - NF</a></li>
<li><a href="#head-normal-form---hnf">Head Normal Form - HNF</a></li>
<li><a href="#weak-head-normal-form---whnf">Weak Head Normal Form - WHNF</a></li>
<li><a href="#hnf와-whnf의-차이">HNF와 WHNF의 차이</a></li>
<li><a href="#정리">정리</a></li>
</ul>
<h3 id="normal-form---nf">Normal Form - NF</h3>
<p>적용할 수 있는 reduction은 모두 적용한 표현식. 즉시eager 평가를 통해 얻게 되는 결과입니다. (마)</p>
<h3 id="head-normal-form---hnf">Head Normal Form - HNF</h3>
<p><a href="https://en.wikipedia.org/wiki/Beta_normal_form" class="uri">https://en.wikipedia.org/wiki/Beta_normal_form</a><br />
head 위치에 beta redex가 남아 있지 않은 표현식. 위 사이트 예시를 보면</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>𝜆x2<span class="op">.</span>  (𝜆x1<span class="op">.</span><span class="dt">A</span>) <span class="dt">M1</span>   <span class="dt">M2</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">^^^^^^^^^^^^^</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>       <span class="co">--(ㄱ)</span></span></code></pre></div>
<p><code>𝜆x1</code>,<code>𝜆x2</code> 이런 부분이 head인데, 이 곳에 beta redex가 남아 있다니 무슨 말일까요? <code>M1</code>에 <code>(𝜆x1.A)</code>를 적용할 수 있으니 (ㄱ) <code>(𝜆x1.A) M1</code>이 redex인 건 알겠는데, 여기가 왜 <code>head</code>일까요? <code>𝜆x2.</code>의 <code>body</code> 아닌가요?</p>
<p><em>application이 abstraction보다 우선 순위가 높음을 적용</em>해서 괄호로 명확한 순서를 표시하면</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">...</span>𝜆x2<span class="op">.</span>  (((𝜆x1<span class="op">.</span><span class="dt">A</span>) <span class="dt">M1</span>) <span class="dt">M2</span>) <span class="op">...</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>          <span class="op">^^^^^^^^^^^^</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- (ㄴ)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- 위 식이 가질 수 있는 형태 중 단순한 걸 살펴보면</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>((((𝜆x1<span class="op">.</span><span class="dt">A</span>) <span class="dt">M1</span>) <span class="dt">M2</span>) <span class="dt">M3</span>) </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- 람다 대수에서는 값이란 개념이 없습니다. M1,M2,... 모두 람다 함수입니다.</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- A를 x, M1을 \x.M1 x, M2를 \x.M2 x 로 가정해 보면 </span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>((((𝜆x<span class="op">.</span>x) (𝜆x<span class="op">.</span><span class="dt">M1</span> x)) (𝜆x<span class="op">.</span><span class="dt">M2</span> x)) (𝜆x<span class="op">.</span><span class="dt">M3</span> x))</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>   <span class="op">^^^^^^^^^^^^^^^^</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- 여길 head라 부릅니다.</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- beta reduce하면</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>𝜆x<span class="op">.</span><span class="dt">M1</span> (𝜆x<span class="op">.</span><span class="dt">M2</span> (𝜆x<span class="op">.</span><span class="dt">M3</span>(x)))</span></code></pre></div>
<p>head 위치에 beta redex가 있는 표현식이 어떤 게 있을까요? HNF는 head에 넣어 줄 값이 redex가 아니라는 뜻일까요?</p>
<p><code>A</code>가 뭔지 모르지만 (ㄴ) <code>((𝜆x1.A) M1)</code>가 <code>M2</code>를 받는 걸로 봐서 (ㄴ)은 람다 abstraction으로, <code>M2</code>를 받을 변수가 head에 있어야 합니다. (ㄴ) 전체가 head는 아니지만, (ㄴ)을 reduce 하고나면, 헤드가 보일 겁니다. 그래도 (ㄴ) 전체를 head position이라 부르는 건 찜찜합니다. 아마도 람다식의 <code>.</code>의 앞부분 <code>𝜆x</code>를 말하는 head와 다른 걸 말하는 것 같습니다. 연이은 인자들 중 reduce가 일어나는 첫 번째 인자란 의미에서 head인 것 같습니다. 일단, 이렇게 <em>가정</em>하고 진행해 보겠습니다. 이 쪽이 하스켈쪽하고도 더 잘 맞아 보입니다. 하스켈에서는 가장 바깥 생성자the outermost constructor를 head라 부릅니다.<br />
<a href="https://math.stackexchange.com/questions/2768395/head-position-in-lambda-calculus" class="uri">https://math.stackexchange.com/questions/2768395/head-position-in-lambda-calculus</a></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Just 값 생성자인데, 레이어마다 번호를 붙여서 보겠습니다.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Just3</span> (<span class="dt">Just2</span> (<span class="dt">Just1</span> <span class="dv">1</span>))</span></code></pre></div>
<p>여기서 가장 바깥 Just3을 head라 부릅니다. 이 것과 람다 대수쪽 head가 같은 뜻인가 살펴 보겠습니다.<br />
람다식으로 풀어 써보면</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(\x <span class="ot">-&gt;</span> <span class="dt">Just3</span> x)       ((\x <span class="ot">-&gt;</span> <span class="dt">Just2</span> x)    ((\x <span class="ot">-&gt;</span> <span class="dt">Just1</span> x) <span class="dv">1</span>))</span></code></pre></div>
<p>람다 대수학쪽 설명과 비교해보면</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- beta reduce하면</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>𝜆x<span class="op">.</span><span class="dt">M1</span> (𝜆x<span class="op">.</span><span class="dt">M2</span> (𝜆x<span class="op">.</span><span class="dt">M3</span>(x)))</span></code></pre></div>
<p>서로 동일한 구조입니다.<br />
가장 바깥 쪽 redex를 reduce하면, Head Normal Form이 됩니다. head에 redex가 남지 않았다는 뜻입니다. 하스켈쪽에서 보면 가장 바깥 쪽 한번 만 evaluate했다는 얘기입니다. 용어의 근원을 살피는 건 복잡하지만, 동작 자체는 간단합니다.</p>
<p>하스켈에서 HNF는 쓰이지 않는다고 합니다. 이 말은 아직 이해하지 못했습니다.<br />
<a href="https://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form" class="uri">https://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form</a></p>
<p>일반 값의 경우 HNF와 WHNF는 같고, 함수의 경우만 다르다 합니다.</p>
<h3 id="weak-head-normal-form---whnf">Weak Head Normal Form - WHNF</h3>
<ol type="1">
<li><p>인자를 가지고만 있고 reduce하지 않은 함수<br />
가능한 reduction 작업을 모두 적용하지는 않은 상태. 지연lazy 평가를 통해 얻게 되는 결과입니다. 하스켈에서는 인자를 모두, 또는 일부를 아직 적용하지 않은 함수를 말합니다. <em>아직 적용하진 않았지만, 인자가 없는 상태는 아닙니다.</em></p>
<p><code>add x y = x + y</code> 일 때,<br />
<code>add</code> 만 있으면 NF (인자 없이 더 이상 reduce할 수 없다.)<br />
<code>add 1 2</code> 람다 대수의 application. 인자를 모두 주었어도 이대로 있으면 WHNF? HNF ? — (ㄷ)<br />
<code>1 + 2</code> 까지 도달한 상태가 WHNF<br />
<code>3</code> 이 되면 NF</p>
<p>(ㄷ) <code>add</code>를 <code>\x.(\y -&gt; x + y)</code> 람다 함수에 이름을 붙여 놓은 것으로 보면 <code>\x.(\y -&gt; x + y) 1 2</code> 라고 쓴 상태입니다. <code>(𝜆x1.A) M1 M2</code> 와 같은 구조입니다.</p></li>
<li><p>값 생성자<br />
값 생성자로 싸여 있다는 게 왜 reduction을 모두 적용하지 않은 상태일까요? WHNF는 reduction을 적용하면 Normal Form으로 바뀔 형태인데, 생성자에는 어떤 reduction 절차가 있을까요?<br />
생성자도 하나의 함수로 볼 수 있으니, 아직 필요한 인자를 받지 않은 Just 등이 단독으로 있으면 WHNF일 것 같은데, Just 1도 WHNF로 보고, True도 WHNF로 본다고 합니다. 왜 그럴까요? True가 어떤 reduction이 가능할까요?</p>
<p>생성자로 쌓여 있는 값은 reduce할 게 있는지 없는지 알 수 없는 상태입니다. 생성자를 벗겨봐야 안 쪽을 볼 수 있습니다. 관점을 값을 얻는 마지막 동작까지를 생각한다면 <code>Just a</code>에서 <code>Just</code>를 떼어내야 최종 값<code>a</code>에 도달할테니 <code>Just</code>가 붙어있는 표현식은 WHNF라 보는 걸까요?</p>
<p>추측해서 답을 내린다면, 힌트는 <em>생성자constructor</em>란 말에 있는 것 같습니다. 생성자 자체가 값은 아니라, 값을 만들어 내는 걸 생성자라 부릅니다. 생성자가 값을 만들어내는 절차를 reduction으로 보는 겁니다. 아무런 동작이 남아 있지 않은 상태를 NF, 아직 하나라도 남아 있다면 WHNF입니다.</p>
<p><code>Just (1 + 2)</code>가 있을 때, <code>(1 + 2)</code>가 계산reduce되는 시점은 <code>Just</code>를 벗겨 낼 때(패턴 매칭할 때)입니다. 그 전에는 계산되지 않은 WHNF상태로 머물게 됩니다. 가장 바깥쪽 생성자가 안쪽을 가리고 있다고 봐도 됩니다.</p></li>
<li><p>람다 함수<br />
인자를 아직 받지 않은 람다 함수</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>\x <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">1</span> <span class="co">-- (가)</span></span></code></pre></div>
<p>이 상태로만 보면 더 이상 reduce할 수 없습니다. 인자를 받아야만 가능합니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>(\x <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">1</span> ) <span class="dv">2</span> <span class="co">-- (나)</span></span></code></pre></div>
<p>이제 redex가 되었습니다. 인자 2가 있어 주면서 reduce할 수 있습니다. 람다 함수지만 (가)는 NF이고, (나)는 WHNF? HNF?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<p>이 상태가 WHNF입니다.</p></li>
</ol>
<h3 id="hnf와-whnf의-차이">HNF와 WHNF의 차이</h3>
<p>위 예시 코드를 다시 보면(Just를 임의의 값 생성자로 보세요.)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(\x <span class="ot">-&gt;</span> <span class="dt">Just3</span> x)       ((\x <span class="ot">-&gt;</span> <span class="dt">Just2</span> x)    ((\x <span class="ot">-&gt;</span> <span class="dt">Just1</span> x) <span class="dv">1</span>))</span></code></pre></div>
<p><code>Just1</code> 헤드 하나뿐만 아니라 <code>Just1</code>, <code>Just2</code>, <code>Just3</code> 같은 것 들이 모두 redex가 없는 HNF가 NF입니다.<br />
HNF인데 <code>Just2</code>, <code>Just3</code> 중 redex를 가진 게 있으면 WHNF가 됩니다.<br />
하스켈에선 반드시 redex가 없어야 되는 건 아니니, WHNF라 부릅니다. (모두 redex가 없다면 HNF인데 왜 하스켈에선 HNF는 쓰이지 않는다고 했을까요? 아직 이 말은 이해하지 못했습니다.)<br />
모든 NF는 HNF이고, 모든 HNF는 WHNF입니다. 역은 성립하지 않습니다.</p>
<p>참고<br />
<a href="https://opentutorials.org/module/1941/11208">남현욱님의 WHNF</a><br />
<a href="https://woogyun.tistory.com/520">우균님의 정규형(normal form), 상위정규형(head normal form), 최상위정규형(weak head normal form)의 차이</a><br />
<a href="https://wiki.haskell.org/Weak_head_normal_form">Haskell.org WHNF</a><br />
<a href="https://stackoverflow.com/questions/6872898/what-is-weak-head-normal-form" class="uri">https://stackoverflow.com/questions/6872898/what-is-weak-head-normal-form</a></p>
<h3 id="정리">정리</h3>
<p>전체 표현식이 NF냐 아니냐가 관심사가 아닙니다. head에 redex가 있냐 없냐에 따라 HNF, WHNF 이름을 붙여놨습니다. 아래는 추측입니다. 하스켈에서 가장 간단한 구별법은 가장 바깥이 application이면 WHNF가 아니고, 람다 abstraction이나 값 생서자면 WHNF라 합니다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(\x <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">1</span>) <span class="co">-- reduce할 게 없습니다. NF</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>(\x <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="op">+</span> <span class="dv">3</span>) <span class="co">-- 헤드에 redex를 넣어주고 있습니다. WHNF</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>(\x <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">1</span>) <span class="dv">1</span> <span class="co">-- 헤드에 redex가 아닌 걸 넣어주니 HNF?</span></span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span>, <span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span>) <span class="co">-- WHNF</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span>,<span class="dv">4</span>) <span class="co">-- WHNF, NF</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span> <span class="op">+</span> <span class="dv">3</span> <span class="co">-- HNF?</span></span></code></pre></div>
<p>안에 있는 내용물을 보지 않고, 가장 겉만 보면 ( , ) 값 생성자입니다. 안에 게 reduce 됐든 안됐든 관심이 없습니다. 이 상태는 WHNF입니다. 그런데 패턴 매칭해서 안에까지 들여다 보니 reduce할 게 없으면 NF이기도 합니다. 뒤집어서 따라가면, 모든 NF는 WHNF도 된다는 얘기입니다.</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
        </div>
        <div id="footer">
            © 2021 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
