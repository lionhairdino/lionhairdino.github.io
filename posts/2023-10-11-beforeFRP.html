<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - FRP의 Event와 Behavior (작성 중)</title>

        <meta name="description" content="FRP 문서를 볼 때, 가장 처음 이해해야 되는 Event와 Behavior 중 Behavior가 까다롭습니다. 일부 텍스트들의 서두를 읽은 것을 정리해봤습니다." />
        <meta property="og:description" content="FRP 문서를 볼 때, 가장 처음 이해해야 되는 Event와 Behavior 중 Behavior가 까다롭습니다. 일부 텍스트들의 서두를 읽은 것을 정리해봤습니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="FRP의 Event와 Behavior (작성 중)" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-10-11-beforeFRP.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

      <meta name="keywords" content="FRP, Functional React Programming, Event, Behavior">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>FRP의 Event와 Behavior (작성 중)</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on October 11, 2023
    
</div>

<p>하스켈 관련 얘기는 아니고, FRP 이해의 출발점인 <code>Event</code>와 <code>Behavior</code>를 이해가 목표입니다.</p>
<p>새로운 프로그래밍 대상을 공부할 때, 먼저 상상해 보곤 합니다. 해결해야 하는 문제를 정리해 보고, 문제들을 어떻게 풀어나갈지 생각해 봅니다.</p>
<p>사실, 그리 깊게 알고 싶진 않고 구현 아이디어와 사용법 정도 알고싶을 때가 많은데, 하스켈의 자료들은 여차하면 논문으로, 여차하면 소스 코드로 끌어 갑니다. 그런 곳으로 잘 못 끌려가면 카테고리 이론 용어들이 떡하니 버틴 경우도 많고, 처음 보는 문법으로 풀어 나가는 코드도 보게 되곤 합니다.</p>
<p>저런 곳으로 끌려가지 않기 위해, 서두의 내용만 갖고, 상상 했던 내용과 아귀를 맞추려고 시도합니다. 그러다 그럴싸하게 맞아 떨어지면 맞는 내용이겠거니 하고 넘어갑니다. 혹시나 의논을 할 수 있는 분을 만날까 해서 블로그에 글도 올려 놓고요. 그러니, 틀리는 경우가 종종 있을 수 밖에 없습니다. 틀리거나 의심스런 내용이 보이면 댓글, 혹은 메일 꼭 부탁드립니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Event</span> a    <span class="ot">=</span> <span class="dt">Event</span>    {<span class="ot"> occ ::</span> (<span class="dt">Time</span>, a) }</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Behavior</span> a <span class="ot">=</span> <span class="dt">Behavior</span> {<span class="ot"> at  ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> a }</span></code></pre></div>
<p>텍스트에선 실제가 아닌 이론적인 두 가지 형태를 먼저 설명하고 있습니다.
<code>Event</code>는 “특정 시간에 일어난 일”이고, <code>Behavior</code>는 시간마다 바뀔 수 있는 값인데, 언제고 알고 싶은 시간을 주면 값을 알려주는 함수입니다.</p>
<p>다음도 역시 실구현이 아닌 개념을 더 직관적으로 보면 아래처럼 되는데, <code>Behavior</code>와 <code>Event</code>를 굳이 나누게 된 동기?가 궁금해서 계속 뒤저 보는 중입니다. <span class="citation" data-cites="todo">@todo</span> Thu Oct 26 10:16:19 AM KST 2023</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Event는    [_,_,_,_,e,_,_,e,_,...]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>Behavior는 [b,b,b,b,b,b,b,b,b,...]</span></code></pre></div>
<p>세상에 존재하는 걸 두가지로만 봅니다. 어떤 순간에도 값이 존재하는 것과, 특정 순간에만 값이 존재하는 것. 위 <code>occ</code>, <code>at</code>보다 더 의미가 직관적으로 보이지 않나 싶은데요. 원소를 <code>Maybe</code>로 모델링하면, <code>Behavior</code>는 <code>Just</code> 값으로만 이루어진 걸로 보면되니, 위 둘을 하나로 추상화할 수 있지 않을까 싶은데요. (어떤 라이브러리는 이렇게 하나로 만든 걸 <code>Signal</code>이라 부른다고 합니다.) FRP는 왜 두 가지로 나누어서 모델링 했을까요?</p>
<p>다음 원소로 진행하는 걸 단위 시간 한 스텝을 나아가는 걸로 해석하고 있습니다.</p>
<h2 id="생각-스트레칭">생각 스트레칭</h2>
<p>텍스트들의 도입부를 읽고, 내가 구현한다면, 어떻게 할까 생각해 봤습니다. 변하는 시스템을 <strong><em>모두 반응Reaction</em></strong>으로 표현한다면</p>
<pre><code>E1   -&gt;   E2   -&gt;   E3 </code></pre>
<p>이벤트들이 연쇄적으로 반응Reactive하며 이어가는 동작이 있겠고,<br />
(※ 값이 유지되지 않는다는 뜻으로 화살표를 짧게 했습니다.)</p>
<pre><code>E1 (혹은 특정 시각)            E2나 시간등의 변경 요인          -- Discrete하게 변경
                |                         |
       Behavior B1 -----------+-----------------+------------&gt;  -- Continuous하게 유지
                              |                 |
                          값이 필요해서 들여다 보는 순간        -- Discrete하게 읽기 </code></pre>
<p>(“시작”같은 “특정 시각”도 시간 이벤트라 볼 수 있으니) 이벤트로 시스템에 변경을 가하면, 시간이 흘러가면서 지속적으로 바뀌는 정보를 생각해 볼 수 있습니다. 물론 꼭 계속 바뀌지 않고, 한 번 바뀐 값으로 계속 가는 “유지”도 포함입니다. 이런 것들은 시간에 따라 계속 바뀌고 있지만, 바뀌는 값을 실제로 꼭 계속 업데이트 할 필요는 없습니다. 필요한 순간에 <code>t -&gt; a</code>에 <code>t</code>값을 넘겨 함수를 실행해서 값을 받아오면 됩니다.</p>
<p>여기에선 <code>Event</code>와 <code>Behavior</code>의 실제 구현을 보는 게 아니라, FRP 프레임워크를 설계하면서 이들이 어떤 걸 모델링 했는지, 의미를 보려 합니다.</p>
<p>※ <span class="citation" data-cites="todo">@todo</span> - 시간, 시각 : 시는 시각처럼 특정 포인트(“각”)가 아니라, 언제부터 언제까지란 “간”이 항상 존재하는 것으로 본다면, 시각이란 말을 안쓰고 시간이란 말만 쓰면 될 것 같기도 합니다.</p>
<h2 id="event-혹은-event-stream">Event (혹은 Event Stream)</h2>
<p>참고 - <a href="https://github.com/HeinrichApfelmus/reactive-banana/blob/master/reactive-banana/src/Reactive/Banana/Model.hs">Reactive-banana의 학습용 소스 - Model.hs</a></p>
<p>구현을 생각하면, (발생 시각, 값) 두 가지 정보만 가지고 있습니다. 시간을 인자로 주거나 하는 게 아닙니다. 여러 시간이 아니라, 특정 시각에 변화를 주는 일이 일어났을 뿐입니다.</p>
<h2 id="behavior">Behavior</h2>
<p><code>Event</code>는 그리 어렵지 않게 넘어 갔는데 <code>Behavior</code>는 설명들이 혼란을 줍니다. 어떤 라이브러리 구현은 이 둘을 구분하지 않고 <code>Signal</code>이란 하나의 타입을 두고 구현한 것도 있다고 합니다. 둘은 성격이 달라 보이는데, 하나로 본다니 금방 수긍이 가지 않습니다. 이벤트 발생과 지속을 구분하는 게 무슨 철학적인 접근인가 싶기도 합니다.</p>
<p>시간에 따라 변하는 값입니다. (실제 구현은 아니고)의미로는 <code>t -&gt; a</code>로 볼 수 있다고 합니다. (semantic function)</p>
<blockquote>
<p><strong>생각 스트레칭</strong><br />
아직 정답은 모르고 추측입니다.<br />
수정: 아래같이 접근하는 게 아닌 것 같습니다. 의미상으로만 t -&gt; a 일 뿐, 실제로 간단한 t -&gt; a 함수로만 구현하는 건 아닌 것 같습니다. 아래는 삭제 예정입니다.</p>
<p><strong>Q1. 어떻게 <code>t -&gt; a</code> “함수”로 현실을 모델링 할 수 있을까요?</strong><br />
함수는 이미 벌어질 일을 다 알고 있는, 즉 매핑이 정해져 있는데, 이 걸로 어떻게 변할지 모를 현실을 어떻게 표현할까요?</p>
<p><strong>ex1)</strong> 정말로 시간에 따라 벌어질 일을 이미 알고 있을 수 있습니다.
빨간불을 시작으로 60초 주기로 바뀌는 신호등을 위한 함수는</p>
<pre><code>신호등함수 = \t -&gt; if t를 120으로 나눈 나머지가 &lt; 60 이면 녹색, 아니면 빨강</code></pre>
<p>신호등 시작 스위치를 켜는 이벤트에 반응으로 위 함수를 가진 <code>Behavior</code>를 만듭니다. 언제든 어떤 순간에 신호등 상태를 알고 싶다면, 신호등함수에 현재 시각을 넣고 결과값을 받아 오면 됩니다.</p>
<p>그런데 문제가 있습니다. <code>Behavior</code>는 <code>Event</code>와 달리 자신의 변화를 다른 곳에 알릴 수가 없습니다. 화면에 신호등을 표시해 주는 그림이 있다면, <code>Behavior</code> 자체가 외부에 알려주는 기능이 없으니 계속 물어 보는(폴링하는) 수밖에 없습니다.</p>
<p>원하는 순간에만 값을 알면 되는 경우와, 값의 변화가 있으면 눈치 채야 하는 경우가 있습니다. 신호등의 경우는 시간에 따라 변하는 값이기도 하고, 외부에 변화를 알려줘야 되기도 합니다. 이럴 때는 <code>Behavior</code>만으로 해결할 수 없습니다.</p>
<p><strong>ex2)</strong> <code>\_ -&gt; constant</code> 이벤트에 대한 리액트로 한 번 바뀐값이 그대로 유지되고 있을 수도 있습니다.</p>
<p><strong>ex3)</strong> <code>t -&gt; a</code>에서 반환값 <code>a</code>가 함수인 <code>t -&gt; (b -&gt; c)</code> 이런식이면 어떨까요? 순간마다 함수를 돌려주는데, 함수들이 가지고 있는 정보들은 불특정 순간에 바뀔 수 있는 값들을 참조할 수도 있습니다.</p>
<p><strong>ex4)</strong> 이미 지난 과거라면 매핑 테이블이 만들어진 것으로 볼 수 있습니다.</p>
<p>저는 <code>t -&gt; a</code>란 걸, 항상 값을 얻을 수 있지만, 실제론 <strong>불특정 순간에 항상 값을 얻을 수 있다는 표현</strong>으로 이해했습니다. 항상 값을 폴링해간다면 효율적인 다른 방식이 있습니다.
<code>t -&gt; a</code>는 시간<code>t</code>에 따라 <code>a</code>가 달라질 수 있다는 뜻이지, 엄밀히 얘기하면 통상의 “함수”는 아니지 않을까요?</p>
<p><strong>Q2. <code>Event</code>와 다르게 연속Continuous적인 시간에 벌어지는 일이라고 합니다. 결국 컴퓨터로 표현하려면 모두 discrete하게(불연속, 이산) 바꿔야 하는 것 아닌가요?</strong></p>
<p>실제 구현이 연속Continuous적인 동작을 한다는 게 아니라, 시간에 연속인 대상을 모델링을 했다는 뜻일 뿐, <code>Behavior</code>가 연속으로 계속 업데이트 하고 있는 모양은 아닙니다. <code>Behavior</code>의 값을 가져다는 쓰는 쪽에서 연속이란 의미는, 바꿔 말하면, 언제든 “값을 원하는 순간”에 값을 얻을 수 있다는 말입니다. 무엇이 일정 시간동안 “존재”한다는 뜻에는 Continuous란 의미가 들어가 있다는 생각이 듭니다.</p>
<p><strong>Q3. <code>Behavior</code>는 시간의 흐름을 강조합니다. FRP가 내부적으로 흘러가는 타이머를 두는 건가요?</strong><br />
폴링 작업이 들어가면 타이머가 돈다고 볼 수 있겠습니다. 항상 변경되는 걸 결과로 바로 보여야 하는 건 아니니, 그럴 수도 아닐 수도 있습니다. 만일 실시간으로 계속 값을 가져와야 한다면 타이머가 돌아야 합니다. 참고 - <a href="http://conal.net/papers/push-pull-frp/push-pull-frp.pdf">Push-Pull FRP - Conal Elliot 섹션5.1</a><br />
보통 예시들을 보면 입력을 스트림으로 주는데, <code>[_, _, _, ...]</code>에서 원소 하나를 가져와 작업하고, 다음 원소를 가져오는 걸 시간이 흘러간 것으로 표현하는 곳도 있습니다.</p>
</blockquote>
<p>전 <code>Behavior</code>가 FRP에서 일종의 <strong>기억 장소</strong> 역할을 하는 것으로 이해했습니다. 시간에 연속적으로 변할 수 있는 값이긴 하나, 실 구현에선 (매 단위시간마다 업데이트를 하고 있는 게 아니라) 적절한 동작이 필요하겠습니다. 마치, FRP의 원조처럼 여기 저기 거론되는 <a href="http://conal.net/papers/icfp97/icfp97.pdf">FRAN</a>에선, 이론대로</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Behavior</span> a <span class="ot">=</span> <span class="dt">Behavior</span> (<span class="dt">Time</span> <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p>로 표현하는데, 이렇게 하면 공간 시간 낭비가 너무 심하니, 적절한 트레이드 오프가 필요하다고 합니다.</p>
<p><a href="https://wiki.haskell.org/Functional_Reactive_Programming">Functional Reactive Programming - Haskell Wiki</a>에 보면 위젯을 1급first class 값으로 다루는 것에 대한 얘기가 나옵니다. <del>Lazy 평가를 기본으로 하는 하스켈에서 <code>Behavior</code>를 시간에 대한 <strong>함수</strong>로 모델링하면, 다음과 같은 코드 모양이 가능합니다.</del> 잘 못 생각한 것 같습니다. WHNF까지만 reduc하는 Lazy가 영향이 있을 것 같긴 한데, 아직 정리가 안됩니다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>myEditWidget <span class="op">:</span>; <span class="dt">Behavior</span> <span class="dt">Text</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> edit1 <span class="ot">&lt;-</span> editWidget</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>   edit2 <span class="ot">&lt;-</span> editWidget</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>   label <span class="ot">&lt;-</span> label (liftA2 (<span class="op">&lt;&gt;</span>) edit1 edit2)</span></code></pre></div>
<p><span class="citation" data-cites="todo">@todo</span> 아직 아하 모먼트가 오지 않은 채 작성 중입니다. Thu Oct 26 10:15:54 AM KST 2023</p>
<p>어찌 됐건 <code>Behavior</code>는 시간을 주면 값을 돌려줘야 합니다. 실제 함수든 아니든 말입니다.</p>
<h2 id="예시">예시</h2>
<p>마우스는 움직일 때마다 <code>Event</code>가 발생하고, 이 <code>Event</code>가 <code>Behavior</code>에 마우스 위치를 저장합니다.<br />
어떤 상황에서 마우스 위치값이 필요하면 <code>Behavior</code>를 읽어 오면 됩니다.<br />
값이 필요할 때 직접 <code>Event</code>에서 값을 받아 오지 않는 이유는, 마우스가 멈춰 있다면 <code>Event</code>는 발생하지 않지만, 위치값은 존재해야 합니다.<br />
</p>
<p><code>Behavior</code>의 시간은 Continuous하게 흐르지만, <code>Behavior</code>의 값이 변경되는 시점과, 값을 필요로 하는 시점은 Discrete합니다.<br />
반면, <code>Event</code>의 시간은 Discrete하고, Event의 값을 받아가는 시점은, <code>Event</code>가 발생한 순간입니다.</p>
<p>※ Reflex에는 위 두개에 더해 <code>Dynamic</code>이란 타입이 있습니다.
<code>Behavior</code>처럼 모든 시간에 값을 가지는데, 가지고 있는 값이 바뀌면 외부로 알릴 수 있습니다. 기본적인 구현은 <code>Event</code>와 <code>Behavior</code>를 튜플로 가지고 있습니다.</p>
<p>참고 - <a href="http://docs.reflex-frp.org/en/latest/overview.html#reflex-basics">Reflex Basics</a></p>
<p><span class="citation" data-cites="todo">@todo</span> 작성 중 …</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
