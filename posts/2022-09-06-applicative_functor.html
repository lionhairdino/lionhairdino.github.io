<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">

<head>
  <script>
    (function () {
      const savedTheme = localStorage.getItem('theme');
      if (savedTheme === 'dark') {
        document.documentElement.classList.add('dark-mode');
      }
    })();

    function loadUtterances() {
      const savedTheme = localStorage.getItem('theme');
      const themeValue = savedTheme === 'dark' ? 'github-dark' : 'github-light';

      console.log("theme");
      console.log(themeValue);
      const script = document.createElement('script');
      script.src = 'https://utteranc.es/client.js';
      script.setAttribute('repo', 'lionhairdino/lionhairdino.github.io');
      script.setAttribute('issue-term', 'url');
      script.setAttribute('theme', themeValue);
      script.setAttribute('crossorigin', 'anonymous');
      script.async = true;
      document.body.appendChild(script);
    };

    function updateUtterancesTheme() {
      const savedTheme = localStorage.getItem('theme');
      const themeValue = savedTheme === 'dark' ? 'github-dark' : 'github-light';

      // Utterances iframe에 메시지 전송
      const utterances = document.querySelector('.utterances iframe');
      if (utterances) {
        utterances.contentWindow.postMessage(
          {type: 'set-theme', theme: themeValue},
          'https://utteranc.es'
        );
      }
    }

  </script>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>lionhairdino - Applicative Functor와 Monad의 차이</title>
  
  <meta name="description" content="Applicative Functor의 기본 개념보다는, 모나드와의 차이점을 살펴 봤습니다." />
  <meta property="og:description" content="Applicative Functor의 기본 개념보다는, 모나드와의 차이점을 살펴 봤습니다." />
  
  <link rel="stylesheet" type="text/css" href="../css/default.css" />
  <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
  <link rel="shortcut icon" href="../favicon.ico" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
  <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
  <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
  <link rel="manifest" href="../site.webmanifest" />
  <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
  <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
  <meta name="msapplication-TileColor" content="#ff7500" />
  <meta name="theme-color" content="#ffffff" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Applicative Functor와 Monad의 차이" />
  <meta property="og:site_name" content="Lionhairdino" />
  <meta property="og:url" content="https://lionhairdino.github.io/posts/2022-09-06-applicative_functor.html" />
  
  <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />
  
  
  <meta name="keywords" content="Applicative Functor, <*>, Effect, Monad, parallel, haskell, 하스켈, 함수형, Functional">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-E9WZ6VXGHP');
  </script>
  <script src="../script/copycode.js"></script>

  <script src="../script/darkmode.js"></script>
  <script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
  <meta name="fediverse:creator" content="@lionhairdino@mastodon.social" />
  <link rel="alternate" type="application/rss+xml" title="상상 하스켈 - Lionhairdino" href="rss.xml" />
</head>

<body>
  <div id="header">
    <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
      <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
    </div>
    <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
      <a href="../">lionhairdino</a>
      <a href="../about.html">about</a>
      <!--<a href="/archive.html">archive</a>-->
    </div>
    <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
      <div style="display:inline-block;vertical-align: top;padding-top: 5px"></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:18px;border:none" src="../images/bluesky.svg"></a>
      </div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://discordapp.com/users/lionhairdino#7687"><img style="width:20px;border:none" src="../images/discord.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://x.com/lionhairdino"><img style="width:15px;border:none" src="../images/X.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://linkedin.com/in/lionhairdino-l-baaa54244"><img style="width:20px;border:none" src="../images/linkedin.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://github.com/lionhairdino"><img style="width:20px;border:none" src="../images/github.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://www.threads.net/@linohairdino"><img style="width:20px;border:none" src="../images/threads.svg"></a></div>
      <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a rel="me" href="https://hackers.pub/@lionhairdino">Hackers'Pub</a></div>
    </div>
    <div>
      <div style="display:inline-block;width:180px;">
        <div class="gcse-searchbox-only"></div>
        <div><button id="theme-toggle">
            <script>
              const savedTheme = localStorage.getItem('theme');
              if (savedTheme === 'dark')
                document.write("☉");
              else
                document.write("☾");
            </script>
          </button></div>
      </div>
    </div>
    <div>
      여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다. 여기 글을 처음 읽는 분은, 먼저 <a href="../warning.html">주의문</a>을 꼭 읽어보세요.
    </div>
  </div>
  <div class="js-toc-content">
    <h1>Applicative Functor와 Monad의 차이</h1>
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on September  6, 2022
    
</div>

<p>Applicative Functor 또는 줄여서 Applicatives라 부릅니다.<br />
</p>
<p>2025.2.25 추가<br />
&gt; 왜 이름이 Applicative Functor일까?
&gt; <code>Maybe</code>를 예를 들면, <code>(a -&gt; b)</code>함수를 <code>Maybe</code> 안에 있는 <code>a</code>에 접근할 수 있게 해주는 <code>fmap</code>을 가지고 있는 구조를 펑터라 하고, <code>Maybe a</code>를 <code>Maybe</code> 안에 있는 <code>(a -&gt; b)</code>를 만날 수 있게 해주는 <code>&lt;*&gt;</code>를 가진 구조를 Applictives라 합니다.<br />
&gt; 지금부터 상상입니다. 함수, 값, 그리고 적용까지 따로 분리해서 보겠습니다. 함수에 값을 넣어주면 당연히 적용이되는 것인데, 이 적용이란 절차를 따로 떼어 보면,<br />
&gt; <code>f a -&gt; f b, f a, $</code> “적용 <code>$</code>”이란 동작은 원래 있던 걸 그대로 쓰고 있습니다.<br />
&gt; <code>f (a -&gt; b), f a, &lt;*&gt;</code> 기존 적용 <code>$</code>과는 다른 “적용<code>&lt;*&gt;</code>”을 정의해서 해결합니다.<br />
&gt; 적용까지 새로 구현한 걸 가지고 있는, 즉, <code>f</code>타입에 특화 되어 있는 <code>apply</code>를 가진 펑터입니다.
&gt;
&gt; 모든 값을 <code>Identity</code> 펑터 값으로 본다면, “적용apply”을 일반화한 게 <code>&lt;*&gt;</code>입니다.</p>
<p>Applicatives의 기본 개념은 <a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">learnyouahaskell</a>를 참고해 주시고, 여기서는 Applicatives와 Monad의 다른 점을 주로 보겠습니다.</p>
<blockquote>
<h4 id="아직-결정되지-않은-effect">아직 결정되지 않은 Effect</h4>
<p>2022-12-18 추가<br />
모나드는 <code>join</code>과 <code>return</code>이 있으면 모나드입니다. <code>join</code>이 있으면 Effect를 합칠join 수 있습니다. 모나딕 동작이란 아직 결정되지 않은 Effect를 이 전 계산값에 의존해서 바꿀 수 있고, 이를 합칠 때 나타납니다. 그런데, <code>join :: m (m a) -&gt; m a</code>만으로는 <code>m</code>을 변형 혹은 만들어 낸다는 의미가 보이지 않고, <code>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</code>에는 <code>a -&gt; m b</code>로 <code>a</code>에 의존해서 바뀌는 <code>m</code>이 있다는 게 분명히 보입니다. <code>join</code>과 <code>(&gt;&gt;=)</code>는 같은 동작을 하는 걸로, <code>(&gt;&gt;=)</code>는 그저 <code>join</code>을 편하게 쓰기 위한 컴비네이터 쯤으로 생각했는데, 두 개가 주는 정보량이 다른 것으로 보였습니다.</p>
<p>어라, 기존에 내가 생각하던 것과 다른데?</p>
<p>모나딕 동작은 반드시 변형 가능한 Effect를, 즉 Effect Computation을 받아야만 모나딕 동작이 이루어집니다. 그래서, 생각을 <code>a -&gt; m b</code> 모양이 반드시 필요하다로 가정하고, <code>join</code>이 있으면 모나딕 동작이 가능한 능력을 가진 상태로 <code>a -&gt; m b</code>를 만나야 모나딕 동작을 한다고 가정했습니다.<br />
또 한가지, Applicatives의 <code>(&lt;*&gt;)</code>로 모나드 <code>join</code>을 써서 구현한 <code>ap</code>를 그대로 가져다 쓰는 경우가 있습니다. 그렇다는 얘기는 <code>join</code>이 동작한다고 항상 모나드는 아닌 걸로 가정했습니다.</p>
<p>결론부터 얘기하면, 틀린 가정이었습니다.</p>
<p>Applicatives와 다르게 모나드는 Effect Computation(즉, 아직 결정된 Effect가 아니라 계산하면, 계산 결과값과 Effect가 나오는 식)을 받아야, 이전 결과값에 따라 Effect가 다르게 될 수 있는 건 틀리지 않았습니다. 틀린 부분은 <code>a -&gt; m b</code>만이 Effect Computation이고 <code>m (m a)</code>는 Effect Computation을 받지 못한다는 생각입니다. <code>m a</code>으로 표현한 게, 더 이상 외부 개입이 불가능하게 계산이 끝난 상태가 아닙니다. 이미 계산이 끝나 결정된 상태는 Effect라 부르고, 계산하면 Effect가 나오는 식을 Effect Computation이라 부릅니다. <code>m a</code>는 Effect가 아니라, Effect Computation입니다. <code>m a</code>는 필요하기 전까진 <code>&lt;thunk&gt;</code>이며, 패턴 매칭이 필요한 때가 오면, 계산을 해서 <code>결과값 + Effect</code>를 만들어냅니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>thunk<span class="op">&gt;</span> --평가evaluate--<span class="op">&gt;</span> 결과값 <span class="ex">+</span> Effect</span></code></pre></div>
<p><code>m a</code>도 평가가 필요한 Effect Computation입니다. <code>a</code>에 의존해서 바뀔 수도 있는 “식”입니다.<br />
Effect Computation과 Effect를 합치는 작업이 있어야 모나드인데, <code>join :: m (m a) -&gt; m a</code>만으론 이 걸 표현하지 못한다는 생각이 틀렸습니다. <code>join</code>에 이미 “Effect Computation을 계산해서 합친다”는 의미가 들어가 있습니다. 기존의 생각대로, 다른 조건 없이 <code>join</code>과 <code>return</code>만 있으면 모나드입니다. 기존에 “우연히” 제대로 알고 있던 걸, 좀 더 확실히 알게 되는 계기가 되었습니다.
※ 엄밀히는 추가로 몇 개의 모나드 법칙law을 만족해야 모나드가 됩니다.</p>
<p>잘 못 따라가는데도, 끝까지 바로 잡아주신 <span class="citation" data-cites="Ailrun님">@Ailrun님</span> 감사합니다.</p>
<p>※ 엄밀하게는 이렇게 알고 있어야 하고, 타입 서명을 읽을 때는 <code>f a</code>도 Computation이지만, <code>a -&gt; m b</code>와 비교하면서 읽을 때는 <code>a</code>에 의존하며 변형되지 않는 Computation으로 우선 읽는게 코드 동작을 이해하는데 도움이 되긴 합니다.</p>
</blockquote>
<blockquote>
<h4 id="타입으로-읽기-확신은-아니고-추측만">타입으로 읽기 (확신은 아니고 추측만)</h4>
<p>2022-12-12 추가</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">m</span> a, a <span class="at">-</span><span class="op">&gt;</span> m b</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ex">f</span> a, a <span class="er">(</span><span class="ex">a</span> <span class="at">-</span><span class="op">&gt;</span> b<span class="kw">)</span></span></code></pre></div>
<p>모나드와 applicative를 타입으로 읽어 보겠습니다.</p>
<p>의존성은 함수로 표현됩니다. <code>b</code>가 <code>a</code>에 의존한다면 <code>a -&gt; b</code> 함수로 표현됩니다. <code>a</code>에 의존해서 <code>b</code>를 만들어낸다고 읽기도 합니다. - 2022-12-18 추가 : 일반적인 함수라는 개념으로 표현된다는 맞는 얘기지만, 하스켈 함수로만 표현된다고 하면 틀린 얘기입니다. <code>m a</code>도 <code>a</code>에 의존해서 바뀌는 Computation을 의미하니, 하스켈에서는 의존이 반드시 <code>-&gt;</code>가 들어간 함수 모양으로 나타나진 않습니다.</p>
<p>모나드에는 <code>m a</code>로, <code>m</code> 하나를 인자로 받고, <code>a -&gt; m b</code>가 있으니, <code>a</code>에 의존해서 새로운 <code>m</code> effect를 만듭니다. 반면 Applicative는 <code>f a</code>로 <code>f</code>하나, <code>f (a -&gt; b)</code>로 <code>f</code> 하나, 이렇게 두 개를 받습니다. <em>새로 만들어지는 f가 없습니다.</em> 타입만으로 읽을 수 있는 가장 큰 차이입니다.</p>
<p>모나드도 <code>m</code> 두 개를 하나로 만들어 내보내고, Applicative도 <code>f</code> 두 개를 하나로 만들어 내보내는 건 같습니다.</p>
<p>※ <code>m a</code>나 <code>f a</code>도 Computation이니, 타입만으로 이렇게 읽는 게 꼭 맞는 건 아닙니다. 타입을 이렇게 읽어서 동작을 <em>추측</em>만 한다고 생각하면 좋을 것 같습니다. <em>m a라고 썼는데, a에 의존해서 m을 바꾸는 동작이 들어 있을 수도 있습니다.</em></p>
</blockquote>
<p>저는 하스켈 학교 디스코드 서버에서 두 개가 어떻게 다른가란 질문만 하고, <span class="citation" data-cites="Ailrun님">@Ailrun님</span>, <span class="citation" data-cites="재원님">@재원님</span>, <span class="citation" data-cites="준규님">@준규님</span>, <span class="citation" data-cites="기정님">@기정님</span>, <span class="citation" data-cites="찬우님이">@찬우님이</span> 답변해 주신 것들을 정리한 글입니다. 답변해 주신 모든분께 감사드리고, 특히 최종 결론에 이르도록 많은 도움을 주신 <span class="citation" data-cites="Ailrun님께">@Ailrun님께</span> 감사드립니다.</p>
<h2 id="이-글의-목적">이 글의 목적</h2>
<p>Applicatives의 정의, 구현을 설명하지 않습니다. 모나드와 Applicatives 차이점에만 주목하고, 어떤 상황에 모나드를 쓸지 Applicatives를 쓸지 아는 게 목표입니다.</p>
<p>파서를 아래와 같이 구현할 수 있습니다. 흐름만 보기 위해 return, pure는 생략했습니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>결과를 모으는 작업 <span class="op">&lt;*&gt;</span> 파서1 <span class="op">&lt;*&gt;</span> 파서2 <span class="op">&lt;*&gt;</span> 파서3</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>파서1 <span class="op">&gt;&gt;=</span> 파서2 <span class="op">&gt;&gt;=</span> 파서3 <span class="op">&gt;&gt;=</span> 결과를 모으는 작업</span></code></pre></div>
<p>Applicatives 스타일로 파서를 구현할지, 모나드 스타일로 구현할지 뭘 보고 결정하면 될까요?</p>
<h2 id="moi와-state">Moi와 State</h2>
<p>State 모나드와 비슷해 보이는 Moi Applicatives입니다. 둘 코드를 읽어보면 많이 비슷하지요? State Applicatives도 비슷한 모양인데, 일부러 구별되는 이름을 가진 Moi를 <span class="citation" data-cites="준규님이">@준규님이</span> 알려 주셨습니다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Moi Applicative Functor @준규: State스러운 Applicatives</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Moi</span> s a <span class="ot">=</span> <span class="dt">Moi</span> {<span class="ot"> runMoi ::</span> s <span class="ot">-&gt;</span> (a, s) }</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Moi</span> moifunc <span class="op">&lt;*&gt;</span> <span class="dt">Moi</span> moiarg <span class="ot">=</span> <span class="dt">Moi</span> <span class="op">$</span> \state0 <span class="ot">-&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (func, state1) <span class="ot">=</span> moifunc state0</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>      (arg, state2) <span class="ot">=</span> moiarg state1</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span>  (func arg, state2)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>       <span class="op">^^^^^^^^</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        apply</span></code></pre></div>
<p><code>&lt;*&gt;</code> 체인을 거치면서 바뀐 <code>state2</code>를 반환합니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- State Monad</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a,s) }</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>(<span class="dt">State</span> statefunc) <span class="op">&gt;&gt;=</span> make_st <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \state0 <span class="ot">-&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (val, state1) <span class="ot">=</span> statefunc state0</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">State</span> newfunc) <span class="ot">=</span> make_st val</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span>  newfunc state1</span></code></pre></div>
<p><code>&gt;&gt;=</code> 체인을 거치면서 바뀐 <code>state1</code>에 <strong><em>새로 생성된 함수를 적용</em></strong>해서 새로운 <code>state</code>를 반환합니다.</p>
<p>추상화해서 말하면, 계산 결과가 Effect에 영향을 주느냐 아니냐의 차이가 있습니다. Monad는 계산 결과를 Effect에 반영할 수 있고, Applicatives는 그렇게 할 수 없습니다. (왜 그런지는 위에 타입으로 읽기에 설명해 두었습니다.)</p>
<p><code>Moi</code> 구현에선 <code>state1</code>, <code>state2</code>를 통해 모나드처럼 실행 순서가 생겨, 이게 일반적인 속성으로 오해할 수 있는데, 순서는 Applicatives의 일반적인 특징은 아닙니다. 순차적으로 하든, 병렬로 돌아가든 그 건 Applicatives가 요구하는 특성은 아닙니다.</p>
<p>위에 <code>&lt;*&gt;</code>의 구현을 보면서 <code>state</code>를 주고 받는 것에 정신이 팔렸는데, <code>&lt;*&gt;</code>의 목적은 끝에 <code>func arg</code>, 즉 <code>apply</code>입니다.</p>
<p>2025.1.14 추가<br />
</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;$&gt;) ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span>       (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;*&gt;) ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p><code>(&lt;*&gt;)</code>는 Applicative apply라 부릅니다. <code>fmap</code>(<code>&lt;$&gt;</code>)도 함수를 펑터 값에 적용하고, Applicative apply도 함수를 펑터 값에 적용하는 건 같지만, 후자는 함수도 펑터 컨텍스트에 들어 있습니다. 이 덕분에 펑터 컨텍스트를 유지하며 커링할 수 있습니다.</p>
<blockquote>
<p>2022-12-17 추가<br />
모나드는 <code>m a, (a -&gt; m b)</code>에서 <code>m</code> 두 개가 있는 게 보이고,<br />
Applicatives는 <code>f a, f (a -&gt; b)</code>에서 <code>f</code> 두 개가 있는 게 보입니다.<br />
</p>
<p>최종 <code>m a</code>나 <code>f a</code>로 되려면, 어떻게든 두 개를 하나로 만드는 작업이 있어야 합니다.<br />
모나드는 <code>join</code>에서 <code>m (m a)</code>가 나타나지만, Applicatives는 <code>f (f a)</code>가 보이지 않는 것으로 알았습니다. 하지만 Applicatives도 effect 두 개를 하나로 만드는 작업은 필요합니다. 꼭, 모나드의 <code>join</code>과 같은 동작을 해야 하는 것은 아닙니다. 모나드 인스턴스가 없는 Applicatives 타입도 <code>f (f a) -&gt; f a</code> 동작은 있습니다.<br />
</p>
<p><code>join</code>과 <code>return</code>만 있으면 모나드입니다. 모나드 인스턴스가 없는 Applicatives는 <code>join</code>이 없다는 얘기지만, <code>f (f a) -&gt; f a</code>가 없다는 얘긴 아닙니다. 또 하나, 모나드의 바인드로 구현한 <code>ap</code>가 <code>(&lt;*&gt;)</code>로 돈다고, <code>(&lt;*&gt;)</code>가 모나딕한 작업을 하는 건 아닙니다. 다시 말해, <code>join</code>이 돈다고 반드시 모나딕 작업을 하는 것도 아닙니다.</p>
<p><code>join</code>이 이전 계산값에 의존해서 다음 Effect가 변형되는 걸 표현하면, 보통 <code>a</code>에 <code>a -&gt; m ...</code>을 적용하는 모양으로 나타납니다. (반드시 꼭 이 모양이란 건 아니고, Computation만 들어가 있으면 되니 <code>m a</code>, <code>a -&gt; m b</code>, <code>(a -&gt; m b) -&gt; m b</code>… 얼마든지 다른 모양이 가능합니다. 개념을 말한다고 봐주세요.) 그런데, <code>a</code>에 <code>\_ -&gt; ...</code>를 넣어주면, <code>join</code>을 썼지만, 딱히 이전 값에 의존하는 동작이 나오지 않을 수도 있습니다. <code>join</code> 구현은 단순히 절차만 열어두었을 뿐이지, 어떤 함수를 넣어주냐에 따라 모나딕할 수도, 아닐 수도 있습니다.</p>
<p><code>Just (+1)</code>에서 <code>(+1)</code>을 꺼내 <code>1</code>에 적용하려면,</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (\f <span class="ot">-&gt;</span> f <span class="op">$</span> <span class="dv">1</span>) (<span class="dt">Just</span> (<span class="op">+</span><span class="dv">1</span>))</span></code></pre></div>
<p><code>Just (+1)</code>에서 <code>(+1)</code>을 꺼내 <code>Just 1</code>에 적용하려면,</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (\f <span class="ot">-&gt;</span> <span class="fu">fmap</span> f (<span class="dt">Just</span> <span class="dv">1</span>)) (<span class="dt">Just</span> (<span class="op">+</span><span class="dv">1</span>))</span></code></pre></div>
<p>이 됩니다. 실행한 결과 값은</p>
<pre><code>Just (Just 1)</code></pre>
<p>Applicatives 동작만 하고 있지만, 마지막에 <code>join</code>과 같이 <code>f (f a)</code>를 <code>f a</code>로 만들어야 하는 게 보입니다. <code>ap</code>가 곧 <code>(&lt;*&gt;)</code>인 경우는 <code>join</code>이 동작합니다. 다시 말해, <code>join</code>이 있어야 모나드가 되지만, 그렇다고 <code>join</code>이 돈다고 모두 모나딕 동작을 하는 건 아닙니다.<br />
※ 위 fmap이 두 번 들어가는 예시는 <code>ap</code>를 <code>ma &gt;&gt;= func = join (fmap func ma)</code>를 써서 <code>fmap</code>과 <code>join</code>으로 표현하면 같은 코드를 얻을 수 있습니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>mf <span class="ot">`ap`</span> mx <span class="ot">=</span> mf <span class="op">&gt;&gt;=</span> \f <span class="ot">-&gt;</span> mx <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> <span class="fu">return</span> f x</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- ma &gt;&gt;= func = join (fmap func ma)로 풀어 보면</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>join (<span class="fu">fmap</span> (\f <span class="ot">-&gt;</span> join (<span class="fu">fmap</span> (\x <span class="ot">-&gt;</span> <span class="fu">return</span> f x) mx)) mf)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                  <span class="op">^^^^</span>              <span class="op">^^^^^^</span></span></code></pre></div>
<p>밑 줄 친 부분을 지우면 위와 같은 코드가 됩니다.</p>
</blockquote>
<h2 id="reader의-와">Reader의 &lt;*&gt;와 &gt;&gt;=</h2>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> \x <span class="ot">-&gt;</span> f (g x) x <span class="co">-- f :: a -&gt; (r -&gt; b)</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">&lt;*&gt;</span> g <span class="ot">=</span> \x <span class="ot">-&gt;</span> f x (g x) <span class="co">-- f :: r -&gt; (a -&gt; b)</span></span></code></pre></div>
<p>둘이 거의 같아 보이지 않나요? 인자 순서만 좀 다르고 하는 일은 같은 걸로 보입니다. 저는 샘플 인스턴스를 찾아 볼 때, 이 걸 보는 바람에 잠깐동안 Applicatives도 Effect를 합성하는 것이 아닐까 생각했습니다. Reader 모나드의 Effect는 외부 스코프 변수를 참조하는 것입니다. (물론, 하스켈에서는 실제로 현재 함수의 스코프를 벗어나는 값에 접근하는 게 아니라, 외부 스코프인 척 하는 값을 컴비네이터<code>bind</code>가 끌고 다닙니다.) 이 값을 <code>r</code>이라고 할 때, <code>r</code>을 두 번 받는 Effect를 합치면 <code>r</code>을 한 번 받도록 만들면 됩니다. <code>r</code>을 한 번만 받아서 컴비네이터가 두 번 써먹으면 되게 만든게 바로 Reader의 <code>join</code>입니다. <code>bind</code>는 이 <code>join</code>을 이용합니다. 위 소스를 보시면 <code>\x -&gt; ...</code> 로 둘 다 한 번만 <code>r</code>을 받고, <code>g</code>에 한 번, <code>f</code>에 한 번 써먹고 있습니다. 이 코드를 보면서 <code>&lt;*&gt;</code>도 바인드와 비슷하게 Effect를 합성하는구나로 오해 했습니다.</p>
<p>Applicatives의 속성은 Effect를 합성하는 걸 강요하지 않습니다. 물론, 합성해도 됩니다만, 합성을 하냐 안하냐는 Applicatives의 속성이 아닙니다. Applicatives를 공부하면서 기존 인스턴스<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>를 찾아봤는데, 하필 모나드이기도 한 것들만 찾아 보는 바람에 Applicatives도 Effect를 합성하는 일종이라 오해했습니다. 대부분 모나드이기도 한 Applicatives는 Effect를 모나드와 비슷하게 합성하고, 마지막에만 apply가 나타납니다. 모나드에 있는 <code>ap</code>로 <code>&lt;*&gt;</code>를 구현하기도 하고, <code>&gt;&gt;=</code>로도 <code>&lt;*&gt;</code>를 구현할 수 있습니다.</p>
<h2 id="applicatives는-effect를-다루는가">Applicatives는 Effect를 다루는가</h2>
<p>Effect는 <code>join</code>이 있어야만 합니다. 즉 <code>Monad</code> 클래스의 인스턴스여야만 Effect로 볼 수 있습니다. 하지만, Applicatives에서 다루는 것은 <code>join</code>이 없어 딱 Effect라고 볼 수는 없습니다. 딱 지칭할 용어를 아직 찾지 못했습니다. 이 문서에서는 용어를 알게 될 때까지 Effect Like 라고 표기하겠습니다. 보통 모나드는 모두 Applicatives의 인스턴스를 만들 수 있기 때문에, 그냥 Effect로 표기하는 문서들도 많습니다. 그리고, 공식 문서들에서도 Effectful 함수를 지칭하는 action이란 용어를 쓰기도 합니다. Effect 정의에 따라, Effct로 불러도 되는 건지 아직 확실하지 않습니다. – 2022.10.21 추가 : Monad의 Effect와 구별해서 Applicative Effect라 부릅니다.</p>
<h2 id="의-타입">&lt;*&gt;의 타입</h2>
<p>※ 아래는 모나드에서 다루는 Effect와는 반드시 같지 않을 수 있기에 Effect Like라고 임시 표기했는데, 특별한 이름 없이 Applicative Effect라 부르기도 합니다.</p>
<p>타입만 보고도 추론할 수 있는게 있습니다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;*&gt;) ::</span> f(a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>         <span class="op">^^^^^^^^^</span>    <span class="op">^^^</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>            함수       값</span></code></pre></div>
<p>이름 그대로, Effect Like를 가진 함수를 Effect Like를 가진 값에 적용apply하는 컴비네이터입니다.</p>
<p>Effect Like를 가지고 있는 함수 <code>f (a -&gt; b)</code>와 Effect Like를 가진 <code>f a</code>를 받아서 <code>f b</code>를 만들어 내려면, 어찌됐건 <code>a</code>에 <code>a -&gt; b</code>를 적용해서 <code>b</code>를 얻어야 합니다. 그럼 <code>f</code> 두 개가 있는데, 어느 <code>f</code>가 가지고 있던 Effect Like를 살려야 할까요? 모나드의 바인드는 (편의상, 다 같은 <code>m</code>이지만 번호를 붙이겠습니다.) <code>m1 a -&gt; (a -&gt; m2 b) -&gt; m3 b</code>에서 <code>m1</code>이 이미 있고, <code>m2</code>가 새로 생깁니다. 그럼, 이 두 개의 Effect를 합쳐join서 <code>m3</code>를 만들어 냅니다. <code>&lt;*&gt;</code>도 Effect Like를 합칠까요? 답은, 합쳐도 되고, 버려도 되고, 둘 중 하나를 골라도 되고, 따로 Applicatives가 되기 위한 제약은 없습니다.</p>
<p>※ Theorem for free로 유니크한 <code>&lt;*&gt;</code>가 정의되는 걸 보일 수 있다하니 신기하기도 합니다. 타입만으로 구현이 정해진다는 게 신기하다까지만 보고 넘어간 상태인데, 언젠가 자세히 봐야겠습니다.</p>
<p>2023.9.19 추가 ※ theorem for free를 우리 말로 풀어 놓은 페이지를 발견 했습니다. <a href="https://velog.io/@yokitomi/you-already-know-functor">당신은 이미 펑터Functor를 알고 있다 - YOKITOMI.log</a></p>
<h2 id="리스트의-applicative-apply-와-바인드">리스트의 Applicative apply &lt;*&gt;와 바인드 &gt;&gt;=</h2>
<p>2025.1 추가</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x <span class="ot">=</span> [x]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    fs <span class="op">&lt;*&gt;</span> xs <span class="ot">=</span> <span class="kw">case</span> fs <span class="kw">of</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        []     <span class="ot">-&gt;</span> []</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        (f<span class="op">:</span>fs') <span class="ot">-&gt;</span> <span class="fu">fmap</span> f xs <span class="op">++</span> (fs' <span class="op">&lt;*&gt;</span> xs)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> [(\x <span class="ot">-&gt;</span> <span class="fu">replicate</span> x <span class="dv">1</span>)] <span class="op">&lt;*&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]]</span></code></pre></div>
<p>위와 비슷하지만, 모나드는 <code>join</code>이 동작해서 <code>[[]]</code>를 <code>[]</code>로 만듭니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="kw">case</span> xs <span class="kw">of</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        [] <span class="ot">-&gt;</span> []</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        (x<span class="op">:</span>xs') <span class="ot">-&gt;</span> k x <span class="op">++</span> (xs' <span class="op">&gt;&gt;=</span> k)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- @찬우: Applicatives가 할 수 없는 일</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> <span class="fu">replicate</span> x <span class="dv">1</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]</span></code></pre></div>
<p>둘이 거의 비슷해 보입니다만,</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>(f<span class="op">:</span>fs') <span class="ot">-&gt;</span> <span class="fu">fmap</span> f xs <span class="op">++</span> (fs' <span class="op">&lt;*&gt;</span> xs)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>(x<span class="op">:</span>xs') <span class="ot">-&gt;</span>      k x  <span class="op">++</span> (xs' <span class="op">&gt;&gt;=</span> k)</span></code></pre></div>
<p><code>fmap f xs</code>는 <code>fmap</code>이 있으니, <code>xs</code> <strong><em>구조는 그대로 유지</em></strong>한 채로 <code>f</code>를 적용합니다.<br />
<code>k x</code>는 <strong><em>새로운 리스트를 생성</em></strong>합니다.</p>
<p>리스트의 경우는 “구조를 유지한 채로 함수를 각 각의 원소들에 적용”하는 것과, “하나씩 꺼내 함수를 적용하고 다시 리스트로 만든 결과”가 거의 같아 차이점이 눈에 잘 안 띌 수 있습니다.</p>
<p>더 자세히 살펴 보겠습니다.</p>
<h3 id="applicative-apply의-동작">Applicative apply의 동작</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>[(<span class="op">+</span><span class="dv">1</span>), (<span class="op">*</span><span class="dv">10</span>)] <span class="op">&lt;*&gt;</span> [<span class="dv">2</span>,<span class="dv">3</span>]</span></code></pre></div>
<ol type="1">
<li><code>[2,3]</code>의 구조는 유지한채로 원소 각 각에 <code>(+1)</code>을 적용 <code>[3,4]</code>,<br />
</li>
<li>또 <code>[2,3]</code>의 구조는 유지한채로 각 각에 <code>(*10)</code>을 적용 <code>[20,30]</code><br />
</li>
<li>둘을 <code>++</code>로 합칩니다. <code>[3,4,20,30]</code></li>
</ol>
<h3 id="바인드의-동작">바인드의 동작</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> [x<span class="op">+</span><span class="dv">1</span>, x<span class="op">*</span><span class="dv">10</span>])</span></code></pre></div>
<ol type="1">
<li><code>2</code>에 <code>\x-&gt;...</code> 적용해서 <code>[3,20]</code>을 생성하고,</li>
<li><code>3</code>에 <code>\x-&gt;...</code> 적용해서 <code>[4,30]</code>을 생성하고,</li>
<li>둘을 <code>++</code>하면 <code>[3,20,4,30]</code></li>
</ol>
<p>비슷한 작업을 하는 듯 보입니다. 차이가 뭘까요? 결과도 거의 같아 둘의 차이를 보기 어렵습니다. Applicative는 이펙트들이 고정이고, 바인드는 이펙트를 생성한다고 말합니다. 리스트의 경우 이펙트 고정이 무슨 말일까요? 리스트의 이펙트는 비결정성이라 부르고, 리스트 원소들 모두에 각 각 함수를 적용하는 동작을 합니다. “모든 원소에 적용한다” 컨텍스트 자체는 변할 부분이 안 보입니다.</p>
<p>지금부터 상상입니다.</p>
<p>먼저 <strong>리스트의 이펙트</strong>를 살펴 보겠습니다. 예를 들어,</p>
<p>정수 <code>1</code>에 함수를 적용해서 나온 값이 <code>2</code>일 때는 이펙트가 없는 경우입니다.<br />
정수 <code>1</code>에 함수를 적용해서 나온 값이 <code>[]</code>,<code>[2]</code>,<code>[2,3,...]</code>일 때는 이펙트가 있는 경우입니다.</p>
<p>이렇게 이펙트가 있는 값이 되어버린 경우 그냥 정수를 받던 함수에 넣어 줄 수가 없고, <strong>이펙트를 이해하는 함수</strong>가 받아서 처리하게 됩니다. 이 함수는 정해지지 않은 개수의 원소를 받을 수 있어야 합니다. 보통 모나드는 <strong>이펙트 값이 변할 수 있고, 더 인포멀하게는 이펙트가 변할 수 있다고</strong> 말하기도 하는데, 리스트에서 이펙트가 변했다 하면 뭐가 변했다는 걸까요? 여기서는 타입들의 이펙트 자체는 당연히 고정이고, <strong>이펙트 구조</strong>가 바뀐다고 말하는 게 적당하지 않나 상상 중입니다.</p>
<p><code>Maybe</code>로 예를 들면, “<code>Just</code>인지 <code>Nothing</code>인지 확인한다”는 컨텍스트(이펙트)는 변하지 않지만, <code>a -&gt; Maybe b</code> 모나드 바인드 함수 결과는 <code>Just 1</code>, <code>Just 2</code>, <code>Nothing</code> 같은 결과값을 가질 수 있습니다. 이 걸 <code>a</code>에 따라 <strong>이펙트가 변했다</strong>고 말합니다. 다시 말해 결과는 <code>a</code>에 따라 <code>Just</code> 생성자를 써서 생성한 값이거나, <code>Nothing</code> 생성자로 생성한 값일 수 있습니다. 반면, Applicative는 <code>&lt;*&gt;</code>를 적용한 결과는 <code>Just</code>였던 값은 여전히 <code>Just</code>고, <code>Nothing</code>이었던 값은 여전히 <code>Nothing</code>입니다. 이펙트는 바뀌지 않았다고 할 수 있습니다.</p>
<p>다시 돌아와서 리스트를 보면, 리스트의 <strong>이펙트 값</strong>은 <code>[]</code>생성자나, <code>(:)</code> 생성자로 생성한 <code>[]</code>, <code>[1]</code>, <code>[2,3,...]</code>등의 모양으로 원소 수가 고정되지 않은 값을 <strong>이펙트 값</strong>으로 갖고 있습니다. Applicative <code>&lt;*&gt;</code>도 모나드도 바인드도 <strong>이펙트 값</strong>은 바꾸지만, Applicative는 처음에 인자로 들어왔던 리스트의 구조, 즉 리스트의 원소 수는 바꾸지 않는 반면, 모나드는 원소의 수를 바꿀 수 있습니다.</p>
<p>위에 예시에서 Applicative는 <code>[2,3]</code>의 구조를 유지하기 때문에, 함수 하나를 적용한 결과는 반드시 구조가 유지된 <code>[x,x]</code> 형태만 가능합니다. 구현을 보면 <code>fmap</code>이 돌고 있으니, 구조를 건드리지 않는다는 걸 금방 알 수 있습니다. 반면, 바인드는 다시 구조를 생성하고 있기 때문에 그런 제약이 없습니다.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> <span class="kw">if</span> <span class="fu">even</span> x <span class="kw">then</span> [x<span class="op">+</span><span class="dv">1</span>, x<span class="op">*</span><span class="dv">10</span>] <span class="kw">else</span> [x<span class="op">+</span><span class="dv">1</span>]</span></code></pre></div>
<ol type="1">
<li><code>2</code>에 <code>\x-&gt;...</code> 적용해서 <code>[3,20]</code>을 생성하고,</li>
<li><code>3</code>에 <code>\x-&gt;...</code> 적용해서 <code>[4]</code>을 생성하고,(<code>[ , ]</code>의 구조를 깨고 있습니다.)</li>
<li>둘을 <code>++</code>하면 <code>[3,20,4]</code></li>
</ol>
<p>그런데, 이런 차이는 아래처럼 해 버리면 Applicative도 비슷한 일을 할 수 있습니다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>[(\x <span class="ot">-&gt;</span> <span class="kw">if</span> <span class="fu">even</span> x <span class="kw">then</span> [x<span class="op">+</span><span class="dv">1</span>, x<span class="op">*</span><span class="dv">10</span>] <span class="kw">else</span> [x<span class="op">+</span><span class="dv">1</span>])] <span class="op">&lt;*&gt;</span> [<span class="dv">2</span>,<span class="dv">3</span>]</span></code></pre></div>
<p>결과는 <code>[2,3]</code>의 구조를 유지한 <code>[[3,20],[4]]</code>로 모나드 결과와 비슷하지만, 리스트가 중첩되어 있습니다. 둘이 가진 정보가 얼핏 보면 별차이 없어 보이지만, Applicative의 결과는 <code>[[Int]]</code>로 <code>[Int]</code>를 받는 함수에 더 이상 넘겨 줄 수 없는 값이 됐습니다. 그리고, 모나드를 쓰면 아래처럼 쓰는 것도 가능합니다.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> [<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> <span class="kw">if</span> <span class="fu">even</span> x <span class="kw">then</span> [x<span class="op">+</span><span class="dv">1</span>, x<span class="op">*</span><span class="dv">10</span>] <span class="kw">else</span> [x<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> y <span class="op">+</span> x</span></code></pre></div>
<p>마지막 줄을 보면 <code>x</code>를 또 쓸 수 있습니다.</p>
<p>Applicative는 이펙트가 고정이라 말하고, 모나드는 첫 째 인자에 따라 생성되는 이펙트가 다를 수 있다 말하는데, 이 문장에서 쓰인 “이펙트”를 “이펙트 구조”라 말하는 게 좀 더 명확하지 않나 생각합니다.</p>
<h2 id="병렬-작업">병렬 작업</h2>
<p><code>&lt;*&gt;</code>로 엮은 체인에서 실행 순서는 따로 정해져 있지 않습니다. 물론, Moi나 State처럼 순서가 생기도록 할 수도 있지만, 일반적인 경우는 아닙니다. 따로, 실행 순서에 대한 제약은 없으니 병렬 작업을 표현하는데도 Applicatives를 활용할 수 있습니다.</p>
<p>아래는 <span class="citation" data-cites="Ailrun님이">@Ailrun님이</span> 예를 들어 주신 <code>Concurrently</code> 타입입니다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>testFunc <span class="ot">=</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  runConcurrently</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">$</span> (,,)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;$&gt;</span> <span class="dt">Concurrently</span> (<span class="fu">print</span> <span class="dv">1</span>)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> <span class="dt">Concurrently</span> (<span class="fu">print</span> <span class="dv">2</span>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> <span class="dt">Concurrently</span> (<span class="fu">print</span> <span class="dv">3</span>)</span></code></pre></div>
<h2 id="결론">결론</h2>
<p>이름 그대로 함수를 어딘가에 적용하는 겁니다. 일반 함수를 위한 <code>($) :: (a -&gt; b) -&gt; a -&gt; b</code>처럼, 함수와 인자를 받아, 함수를 인자에 적용하는 일을 하는데, 단 함수와 인자가 Effect Like를 가지고 있습니다.</p>
<p>다음 Effect는 이전 액션 결과와 상관 없이, 항상 일정하게 나오는 경우 모나드보다 Applicative가 어울립니다.</p>
<p>a 5개 파싱, b 5개 파싱, c 5개 파싱 같은 건 Applicatives로 구현하지만,<br />
a 여러 개 파싱, 앞에 b 개수만큼 파싱, 앞에 c 개수만큼 파싱처럼, 앞 파서의 결과값에 따라 파싱 동작이 달라질 경우 모나드로 구현해야 합니다.</p>
<p>참고 <a href="https://www.idziorek.net/blog/Haskell/Applicative-vs-Monadic-Parsing/index.html"><del>Applicative vs. Monadic Parsing</del></a>(2023.11.30 확인 결과, 깨진 링크입니다.)</p>
<p>※ <span class="citation" data-cites="todo">@todo</span> a 여러 개 파싱, b 여러 개 파싱 은 Applicatives로 구현 가능하다고 합니다.<br />
하지만, a 여러 개 파싱, b 여러 개 파싱, c 여러 개 파싱은 Applicatives로 안된다고 합니다. 조금 더 공부가 필요한데, 얼핏 보기에 정보 누적을 재귀를 이용하여 구현하는 것 같습니다.</p>
<p>일반적인 용도는 <a href="../posts/2020-07-02-Context.html">컨텍스트, Applicative Functor, Traversable</a>에서 일부 다루었습니다.</p>
<p>P.S<br />
Functor, Applicatives, Monad를 하나의 계보에 올려 놓고,<br />
“Functor보다 Applicatives가 더 강력하다”<br />
“Applicatives보다 Monad가 더 강력하다”<br />
등으로 표현하기도 하고,<br />
“모나드가 꼭 있어야 되는 일이 아니고, Applicatives로 해결할 수도 있다”<br />
등의 말이 종종 보입니다.</p>
<p>물론, 하나의 타입이 Applicatives도, Monad도 구현되어 있다면, Applicatives가 할 수 있는 일은, Monad로 표현할 수 있긴 하나, 둘의 용도는 전혀 다른게 아닌가 합니다. 작업 체이닝을 할 때, Applicatives는 고정된 Effect 동작을 할 경우에 적합하고, Monad는 Effect가 변형되는 경우에 적합합니다. 그리고, 병렬로 동작해야 하는 경우 Monad 구현은 아예 없습니다. 이런 경우에는 Applicatives가 할 수 있는 일은 Monad가 다 할 수 있다고 말하는 게 맞지 않습니다.</p>
<p><a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/applicative_do.html">Applicative do-notation</a><br />
<a href="https://www.staff.city.ac.uk/~ross/papers/Applicative.pdf">Functional Pearl. Applicative programming with effects - Conor Mcbride, Ross paterson</a><br />
<a href="https://stackoverflow.com/questions/23342184/difference-between-monad-and-applicative-in-haskell">Difference between Monad and Applicative in Haskell(Stackoverflow)</a></p>
<p>2022.9.10 추가</p>
<p>Ailrun님께 2~3일에 걸쳐 집요하게 질문드려 이해하게 된 내용들을 정리해서 추가합니다. 혹시 틀린 내용이 있다면, 분명 제가 이해를 잘 못한 것입니다.</p>
<blockquote>
<p>Q. Applicatives에서도 이전 Effect가 다음 Effect에 영향을 주고 있습니다. <code>f a &lt;*&gt; f b</code>에서 어떻게 <code>f a</code>와 <code>f b</code>가 독립적으로 동작할 수 있을까요?</p>
<p>A. <code>a</code>와 <code>b</code>가 <code>f</code>에, 즉 Effect에 영향을 주지 않습니다. Lazy하게 생각하면, Effect에 따라 <code>a</code>작업을 만들어 놓고, 그 다음 바뀐 Effect에 따라 <code>b</code>작업을 만들어 놓습니다. 그럼, 이렇게 만들어진 <code>a</code>와 <code>b</code>사이에는 아무런 연관이 없습니다. <del>f a와 f b는 독립적으로 동작하지 못하지만<code>a</code>와 <code>b</code>는 독립적으로 동작합니다.</del>, <code>f a</code>와 <code>f b</code>는 서로 독립입니다. Effect 끼리는 영향을 줄 수 있지만, <code>f a</code>와 <code>f b</code>끼리가 아닌 <code>f a &lt;*&gt; f b</code>가 될 때만 그 둘이 가지는 Effect가 연관성이 생깁니다. <code>f a &lt;*&gt; f b</code>는 <code>f a</code>에 의존할 수 있고, <code>f b</code>에 의존할 수 있지만, <code>f a</code>와 <code>f b</code>는 서로 의존성이 없다는 말입니다.</p>
</blockquote>
<blockquote>
<p>Q. <code>bind</code>는 Effect합성을 하며 값이 Effect에 영향을 미칩니다. 어떻게 <code>bind</code>를 쓰면서 <code>&lt;*&gt;</code>를 구현할 수 있을까요?</p>
<p>A. <code>bind</code>가 하는 일은 Effect를 합치는 일이지, 누가 무슨 Effect를 어떻게 만들어 내는가에는 관여하지 않습니다. bind <strong><em>컴비네이터</em></strong>는 Effect가 있는 <code>m a</code>와 Effect를 만들어내는 <code>a -&gt; m b</code>를 받아서 어떤 작업을 합니다. <em>어떻게 Effect를 만들어내느냐는</em> <code>bind</code>가 하는 일이 아닙니다. Effect를 만들어내는 건 인자로 들어오는 <code>a -&gt; m b</code>에 달렸습니다.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bind ::</span> m1 a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m2 b) <span class="ot">-&gt;</span> m3 b</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- (모두 똑같은 타입 `m`이지만 편의를 위해 숫자를 붙이겠습니다.)</span></span></code></pre></div>
<p><code>bind</code>는 <code>m1 a</code>에서 <code>a</code>를 꺼내어 <code>f :: a -&gt; m2 b</code>를 적용하고, <code>m1</code>과 <code>m2</code>를 합처 <code>m3 b</code>를 반환합니다.<br />
<code>f</code>의 서명을 보이는대로 해석하면 <code>m2</code>와 <code>b</code>는 <code>a</code>에 의존하고 있습니다. 그런데, <code>f</code> 내부에서 <code>a</code>를 받아 (<code>\_ -&gt; ...</code> 로 받는 식으로 <code>m2</code>에 영향을 주지 않고 있다면) <code>m2</code>가 <code>return</code>이 만들었다든지 하는 trivial한 Effect만 가진다면, <code>bind</code>를 썼지만, 값이 Effect에 영향을 주지 않는 상태가 됩니다. <code>bind</code>를 썼기 때문에 반드시 값이 Effect에 영향을 미치고 있는 게 아니라, <code>f</code>가 어떤 동작을 하냐에 따라 다릅니다. Effect에 값이 영향을 미치면 안되는 Applicatives를 <code>bind</code>를 써서 구현할 수도 있다는 얘기입니다.</p>
<p>State 모나드에서 <code>bind</code>로 <code>&lt;*&gt;</code>를 구현하는 걸 살펴 보겠습니다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- State의 &lt;*&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="dt">StateT</span> mf <span class="op">&lt;*&gt;</span> <span class="dt">StateT</span> mx <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \ s <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>   <span class="op">~</span>(unwrapf, s') <span class="ot">&lt;-</span> mf s</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">~</span>(unwrapx, s'') <span class="ot">&lt;-</span> mx s'</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>   <span class="fu">return</span> (unwrapf unwrapx, s'')</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Lazy 패턴 매칭은 무시하고, `bind`의 동작을 살펴 보겠습니다.</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>mf <span class="op">&gt;&gt;=</span> \(unwrapf, s') <span class="ot">-&gt;</span> mx <span class="op">&gt;&gt;=</span> \(unwrapx, s'') <span class="ot">-&gt;</span> <span class="fu">return</span> (unwrapf unwrapx, s'')</span></code></pre></div>
<p><code>\(unwrapf, s') -&gt; mx</code>는 패턴 바인딩으로 <code>mf</code>에서 <code>m</code>을 벗겨 <code>unwrapf</code>에 바인딩해 놓을 뿐 Effect에 영향을 미치는 동작이 없습니다.<br />
<code>\(unwrapx, s'') -&gt; return (unwrapf unwrapx, s'')</code>는 패턴 바인딩으로 <code>mx</code>에서 <code>m</code>을 벗겨 <code>unwrapx</code>에 바인딩해 놓을 뿐 Effect에 영향을 미치는 동작이 없습니다.<br />
여기서 <code>s''</code>이 <code>unwrapf</code>에 의존해서 바뀐다거나, <code>s''</code>을 읽어오는 동작이 바뀐다면, 모나드를 써야만 합니다.</p>
</blockquote>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Applicative 인스턴스이며 Monad인 예시</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">STM</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  liftA2 <span class="ot">=</span> liftM2</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">IO</span> <span class="kw">where</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  liftA2 <span class="ot">=</span> liftM2</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>nstance <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> f  <span class="op">&lt;*&gt;</span> m       <span class="ot">=</span> <span class="fu">fmap</span> f m</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="op">&lt;*&gt;</span> _m      <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  liftA2 f (<span class="dt">Just</span> x) (<span class="dt">Just</span> y) <span class="ot">=</span> <span class="dt">Just</span> (f x y)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  liftA2 _ _ _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Applicative</span> ((,) a) <span class="kw">where</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>  (u, f) <span class="op">&lt;*&gt;</span> (v, x) <span class="ot">=</span> (u <span class="op">&lt;&gt;</span> v, f x)</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>  liftA2 f (u, x) (v, y) <span class="ot">=</span> (u <span class="op">&lt;&gt;</span> v, f x y)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Functor</span> m, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">StateT</span> mf <span class="op">&lt;*&gt;</span> <span class="dt">StateT</span> mx <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \ s <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>      <span class="op">~</span>(f, s') <span class="ot">&lt;-</span> mf s</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>      <span class="op">~</span>(x, s'') <span class="ot">&lt;-</span> mx s'</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> (f x, s'')</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="co">--            ^^^</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a><span class="co">--           apply</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>  fs <span class="op">&lt;*&gt;</span> xs <span class="ot">=</span> [f x <span class="op">|</span> f <span class="ot">&lt;-</span> fs, x <span class="ot">&lt;-</span> xs]</span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a><span class="co">--             ^^^</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a><span class="co">--            apply</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> ((<span class="ot">-&gt;</span>) r) <span class="kw">where</span>  </span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>  f <span class="op">&lt;*&gt;</span> g <span class="ot">=</span> \x <span class="ot">-&gt;</span> f x (g x)</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a><span class="co">--                ^^^</span></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a><span class="co">--               apply</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Functor</span> m, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">WriterT</span> w m) <span class="kw">where</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>  <span class="dt">WriterT</span> mf <span class="op">&lt;*&gt;</span> <span class="dt">WriterT</span> mx <span class="ot">=</span> <span class="dt">WriterT</span> <span class="op">$</span> \ w <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>      (f, w') <span class="ot">&lt;-</span> mf w</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>      (x, w'') <span class="ot">&lt;-</span> mx w'</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> (f x, w'')</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a><span class="co">--            ^^^</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a><span class="co">--           apply</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a><span class="co">-- 참고</span></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a><span class="co">-- 모나드에 있는 ap를 쓰지 않고 구현한다면 아래같이 ap와 똑같은 모양이 됩니다.</span></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a><span class="co">--instance Applicative IO where</span></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a><span class="co">--  a &lt;*&gt; b = do</span></span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a><span class="co">--    f &lt;- a</span></span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a><span class="co">--    x &lt;- b</span></span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a><span class="co">--    return (f x)</span></span></code></pre></div>
<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></li>
</ol>
</section>

<div class="comment">
  <script>
    document.addEventListener('DOMContentLoaded', loadUtterances, { once: true });
  </script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>

  </div>
  <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
  <script>
    tocbot.init({
      tocSelector: '.js-toc',
      contentSelector: '.js-toc-content',
      headingSelector: 'h2, h3',
      hasInnerContainers: true,
    });
  </script>
  <div id="footer">
    © 2025 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
  </div>
</body>

</html>
