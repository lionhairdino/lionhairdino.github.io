<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>lionhairdino - Tagless Final style</title>
        <meta name="description" content="lionhairdino - Tagless Final style">
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <meta property="og:type" content="website">
        <meta property="og:title" content="Tagless Final style">
        <meta property="og:description" content="lionhairdino - Tagless Final style">
        <meta property="og:url" content="https://lionhairdino.github.io">
    </head>
    <body>
        <div id="header">
            <div id="logo"> </div>
            <div id="navigation">
                <a href="../">lionhairdino</a> 
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
        </div>

        <div id="content">
            <h1>Tagless Final style</h1>

            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on July  7, 2020
    
</div>

<p>기본 아이디어는 “<em>똑같은 문장을 써놓고 때에 따라 다르게 번역하고 싶다</em>” 입니다. 하스켈에서 이렇게 할 수 있는 문법이 바로 <em>클래스와 인스턴스</em>입니다. 구체 타입을 지정하지 않고, 클래스 제약을 걸어두고 메소드를 쓰면, 실제 실행되는 메소드 구현체는 나중에 GHC가 추론 단서들을 보고 고르게 됩니다. 예를 들면 getData라 메소드를 선언해서 사용하고, 이 메소드가 때로는 database에서 값을 가져오고, 때로는 file에서 값을 가져오게 하고 싶을 때 같은 경우를 말합니다.</p>
<p>eDSL(embedded Domain Specific Language)[1]을 모두 클래스의 메소드로 정의해 놓고, 나중에 인스턴스를 바꿔서 적용 가능하게 해 놓는 걸 tagless final style 이라 부릅니다. Free 모나드를 같은 목적으로 쓰는 경우가 많은데, Free 모나드에 비해 장점은 런타임에 인터프리팅되는게 아니라, GHC가 컴파일 타임에 코드 조합에 따라 인스턴스를 골라서 컴파일 하니 퍼포먼스측면에서 장점이 있습니다.<br />
mtl 스타일에 익숙하다면, mtl과 아이디어는 같다고 보면 됩니다. 실용 코드에서는 application monad[2] 안에서 mtl에 얹혀서 tagless final을 사용합니다.</p>
<p>DSL에 들어 있는 명령어들을, 나중에 인터프리터를 만나 실제 실행될 코드를 고르도록 하는 표식 정도의 의미로 tag라고 부르고 이런 표식없이 컴파일 타임에 바로 DSL을 실행 코드로 바꿔서 컴파일 한다는 의미에서 tagless라 부르는게 아닐까 합니다. tagless final이라 이름 붙인 이유를 아시는 분은 댓글 부탁드립니다.</p>
<p>Reference:<br />
<a href="https://serokell.io/blog/tagless-final" class="uri">https://serokell.io/blog/tagless-final</a></p>
<hr />
<p>[1] eDSL (embedded Domain Specific Language)<br />
요리 레시피처럼 할 일들을 순서대로 주욱 기록해 두는 것과 비슷합니다. 실제 실행 코드로 조합하는게 아닌, 작업에 붙여 놓은 작업명을 DSL이라 보면 됩니다. 어디선가는 작업명에 맞는 실행 코드를 가져와서 실행하게 될텐데 Free 모나드는 런타임에, tagless final은 컴파일 타임에 인터프리팅이 일어납니다. 크게 보면 프로그래밍 언어 자체가 DSL이긴 하지만, 보통은 언어내embedded에서 사용자가 정의한 태그들로, 나중에 인터프리팅 단계를 거쳐 실행 코드로 바뀌는 것들을 뜻하는 좁은 의미로 쓰입니다.</p>
<p>하스켈에서는, 어떤 사람들은 do 표현이 가능한 정도로만 DSL이라 부르기도 하고, 어떤 사람들은 메소드들로 AST(Abstraction Syntax Tree)를 정의해야만 DSL이라 부르기도 합니다.</p>
<p>[2] Application Monad<br />
Tagless final 스타일에서, 한 모나드 안에서 DSL을 조합해서(보통 do 표현을 이용해서) 쓰게되는데, 이 때의 모나드를 application monad라 부릅니다.</p>

<div id="disqus_thread" style="padding-top:40px"></div>
<script>

var disqus_config = function () {
this.page.url = 'https://lionhairdino.github.io/posts/2020-07-07-taglessFinal.html';
this.page.identifier = 'posts/2020-07-07-taglessFinal.markdown';
};
(function() {
var d = document, s = d.createElement('script');
s.src = 'https://lionhairdino.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
        </div>
        <div id="footer">
            © 2020 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
