<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - Arrow 예시 - Circuit</title>

        <meta name="description" content="어떨 때 Arrow를 쓰면 좋은지 보여주는 좋은 예시입니다." />
        <meta property="og:description" content="어떨 때 Arrow를 쓰면 좋은지 보여주는 좋은 예시입니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="Arrow 예시 - Circuit" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2023-09-29-needArrow.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

      <meta name="keywords" content="Arrow, Circuit">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>Arrow 예시 - Circuit</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on September 29, 2023
    
</div>

<p>Sat Sep 30 12:37:49 AM KST 2023 작성 중… 아직 완전히 이해하지 못하고, 일부는 추측하며 정리하고 있습니다.</p>
<p><a href="https://en.wikibooks.org/wiki/Haskell/Arrow_tutorial#Stephen's_Arrow_Tutorial">Haskell/Arrow tutorial - wikibooks</a><br />
Arrow 실 사용 예시를, 자세한 설명과 함께 볼 수 있는 글 입니다. 처음엔 언제 Arrow를 사용하면 좋을 지 알기 위해 봤는데, 재귀 패턴, 모양을 더 공부하게 만든 예시입니다. Arrow가 어떻게 쓰이는 지만 보기엔 적당한 글이 아닐 수도 있습니다. 우아한 Arrow로 넘어가기 전에 일단 Circuit에서 막히니까요. 여기 글은 위 링크에 있는 튜토리얼을 그대로 가져와 읽으며, 메모를 추가한 정도의 글입니다. 아래에 나오는 코드는 모두 위 링크에서 발췌했습니다.</p>
<p>어느 정도 쓰고 돌아보니, 길게도 썼습니다. 오류가 있을지도 모르는 긴 글을 누가 읽을까 싶은데요. 위 텍스트로 Arrow를 공부하며 벽에 부딪히는 분들을 위한 아이디어가 몇 개 있긴 합니다. 정답을 알려주는 텍스트가 아니라, 같이 공부하는 옆 친구의 노트입니다.</p>
<p>※ 추가적인 메모없이 깨끗한 번역만 보시려면, codeonwort님의 <a href="https://wikidocs.net/1928">애로우 튜토리얼 - WikibooksHaskell</a> 번역이 공개되어 있습니다.</p>
<h2 id="생각-스트레칭">생각 스트레칭</h2>
<p>반복을 표현하는 방법</p>
<p>A.<br />
<code>(+10)</code>을 <code>for</code>, <code>재귀</code> 등으로 <code>10</code>번 반복해</p>
<p>B.<br />
<code>data AddTen a = AddTen (AddTen a)</code></p>
<p>즉 <code>AddTen (AddTen (AddTen ...))</code> 무한이 가능한 재귀 타입을 만든다.<br />
패턴 매칭으로 <code>AddTen</code>을 벗겨 낼 때마다 <code>(+10)</code>을 하도록 정의한다.<br />
패턴 매칭을 <code>10</code>번 한다.</p>
<p><code>(+10)</code>을 한 번 더하고 싶으면, A 경우엔 그냥 <code>(+10)</code>을 한 번 더하면 되고,<br />
B 경우엔 한 번 패턴 매칭하면 됩니다.</p>
<p>그런데, <code>AddTen</code>타입은 리스트 정의처럼 종료(<code>[] 혹은 Empty</code>)를 표시하는 엣지 케이스가 없습니다. <code>AddTen</code>은 <code>AddTen</code>값이 있어야 되는데, 처음 <code>AddTen</code>값은 어떻게 정의할까요? 그리고 정의가 되었다 해도, 무한하게 가버리는 걸 실용에서 어찌 써먹을까요?</p>
<p>A보다 B가 훨씬 더 복잡하고, 머리를 괴롭히는데 B로 하면 A로 하는 것 보다 어떤 장점이 있을까요?</p>
<h2 id="circuit">Circuit</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Circuit</span> a b <span class="ot">=</span> <span class="dt">Circuit</span> {<span class="ot">unCircuit ::</span> a <span class="ot">-&gt;</span> (<span class="dt">Circuit</span> a b, b)}</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                                                  <span class="op">^^^^^^^^^^^</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                                                  continuation</span></code></pre></div>
<h3 id="circuit안에-또-circuit">Circuit안에 또 Circuit</h3>
<p>순환하는 타입 읽기가 불편하지 않나요? 저는 아직도 편하지 않습니다.</p>
<p><code>Circuit</code> 타입을 생성하려면 생성자 <code>Circuit</code>에 <code>(\a -&gt; ???)</code> 같은 함수를 넣어야 하는데, <code>???</code> 부분에는 뭐가 들어가면 될까요? <code>Circuit</code> 타입을 넣어 줘야 하는데, 그러려면 안 쪽에 또 <code>Circuit</code> 타입이 있고, 그냥 대체하면서 따라가면 무한으로 가버립니다. 타입에서는 이렇게 써 준다고 무한 재귀하는 모양이 아닙니다. 안에 있는 <code>Circuit</code>타입 값이, 꼭 현재 정의하고 있는 <code>Circuit</code>과 같은 값일 필요는 없으니, 재귀가 아닌 경우도 있을 수 있습니다. 물론, 값을 만들 때 재귀하는 모양의 값을 만들 순 있습니다. 하지만, <strong><em>혼자서</em></strong> 무한히 도는 일은 일어나지 않습니다.</p>
<p><code>data List a = a : List a | []</code></p>
<p><code>[]</code>, <code>1:[]</code>, <code>1:2:[]</code> … 등이 모두 <code>List</code> 타입의 값이 될 수 있다는 얘기지, 재귀 함수를 읽듯 <code>List</code>가 무한히 호출되지는 않습니다. 그런데, <code>List</code>의 경우는 에지 케이스, 즉 <code>[]</code>라는 표현이 있어, 더 이상 이어지는 값이 없을 경우 <code>[]</code>으로 마감하면 됩니다. 하지만 <code>Circuit</code>의 경우는 Sum타입으로 에지 케이스를 가지고 있지 않습니다. <code>Circuit</code>은 종료를 표현할 수 없으니 무한 반복으로 갈 것만 같습니다.</p>
<p>하스켈은 Lazy합니다. 타입 생성자로 쌓여 있는 건 패턴 매칭으로 벗겨내거나, <code>unCircuit</code>같은 함수를 실행하기 전에는 안에 들어있는 값을 볼 수 없습니다. <code>Circuit</code> 안에 들어 있는 <code>Circuit</code>은 또 풀려고 하지 말고, 그냥 안을 보지 않은 채로 <code>Circuit</code>으로만 봐야 합니다. 안을 들여다 볼 필요가 있기 전 까지, 안은 안보면 됩니다.</p>
<p>여기까진 그런대로 쫓아 올만한데, 그럼 아무 <code>Circuit</code>타입 값이 없는 제일 처음에 <code>Circuit</code> 타입의 값을 만들려면(값 생성자로 생성하려면) 어떻게 할까요?</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cir <span class="ot">=</span> <span class="dt">Circuit</span> (\a <span class="ot">-&gt;</span> (<span class="op">???</span>,b))</span></code></pre></div>
<p><code>cir</code>에 넣어 줄, 알고 있는 <code>Circuit</code> 타입 값이 없습니다?!<br />
아닙니다. 적어도 하나가 있습니다. 바로 정의되고 있는 자기 자신입니다.<br />
(아래 쪽에 보면, <code>id</code>도 있긴 합니다. 다른 <code>Circuit</code>값을 못 쓰진 않지만, 텍스트에선 “처음 생성”에는 모두 순환하는 예시만 보입니다. )</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cir <span class="ot">=</span></span></code></pre></div>
<p>이라고만 해도, 쓸 수 있는 <code>cir</code>이 하나 생겼습니다. <code>???</code> 자리엔 <code>Circuit</code>을 넣어줘야 하니, <code>cir</code>을 넣어줘도 됩니다. Lazy하니 <code>cir</code>이 무슨 값인지는 필요할 때, 또 보면 됩니다. ※ 컴파일러가 바인딩하는 과정(WHNF 개념 포함)을 보면, 이런 재귀적인 표현들이 “약간” 더 편해지긴 합니다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> cir <span class="ot">=</span> <span class="dt">Circuit</span> (\a <span class="ot">-&gt;</span> (cir, b))</span></code></pre></div>
<p>타입 정의 자체가 순환 정의는 아니지만, 위와 같이 값을 선언하면 순환하는 값을 가지게 됩니다.<br />
※ <code>cir</code>값을 위와 같이 만들어 뒀다면, <code>let cir2 = Circuit (\a -&gt; (cir, b))</code>로 <code>cir2</code> 정의할 때 <code>cir</code>을 가져다 쓸 수 있습니다. 텍스트를 보면, 시작부터 다른 <code>Circuit</code>을 가지게 하진 않고, 컴비네이션을 하는 동안, 두 <code>Circuit</code>을 합친다든지 하며 다른 <code>Circuit</code>이 들어갑니다.</p>
<h3 id="category-클래스의-인스턴스">Category 클래스의 인스턴스</h3>
<p>합성을 추상화 시킨 인터페이스는 <code>Category</code> 클래스에 있습니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> cat <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  id ::</span> cat a a</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (.) ::</span> cat b c <span class="ot">-&gt;</span> cat a b <span class="ot">-&gt;</span> cat a c</span></code></pre></div>
<h4 id="section">(.)</h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Cat.Category</span> <span class="dt">Circuit</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  (<span class="op">.</span>) <span class="ot">=</span> dot</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Circuit</span> cir2) <span class="ot">`dot`</span> (<span class="dt">Circuit</span> cir1) <span class="ot">=</span> <span class="dt">Circuit</span> <span class="op">$</span> \a <span class="ot">-&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (cir1', b) <span class="ot">=</span> cir1 a</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>            (cir2', c) <span class="ot">=</span> cir2 b</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span>  (cir2' <span class="ot">`dot`</span> cir1', c)</span></code></pre></div>
<p><code>Circuit</code> 두 개를 모두 거쳐 결과값<code>c</code>를 만들고, 또 언제든 두 개를 모두 거칠 수 있도록 <code>dot</code>으로 합성한 걸 가지고 있습니다. <code>dot</code>을 구현하는데, 안에 또 <code>dot</code>이 나옵니다. <code>Circuit</code>안에 <code>Circuit</code>이 또 들어 있으니, 당연히 또 나오겠거니 예측할 수 있긴 합니다.</p>
<p><code>Circuit</code>은 <code>a</code>를 받고, 결과값을 갖고 있는 2튜플을 돌려주는 함수입니다. <code>Circuit</code>을 잠시 가리고 보면,</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> (           , b)</span></code></pre></div>
<p>텍스트에선 <code>b</code>를 내부 상태값internal state이라 표현하고 있습니다. <code>a</code>를 받아 <code>b</code>상태가 되고, <code>b</code>를 받아 <code>c</code>상태가 되게 하고, 여전히 <code>Circuit</code>안에 들어 있게 하면 2튜플의 두 번째 자리에 상태를 유지할 수 있습니다. 저는 정보량으로 추상화 시켜서 보곤 합니다. <code>a -&gt; b</code>와 달리 <code>a -&gt; (??, b)</code>는 분명히 추가 정보를 가지고 있습니다. 이 <strong><em>함수 자체만으로는 추가 정보가 어떤 역할을 하지 못하지만</em></strong>, <code>??</code>을 꺼내가는 다른 절차가 끼어들어 다른 역할을 할 수 있을 거라 추측해 볼 수 있습니다.</p>
<h5 id="무한히-반복될-것만-같아-불편하다.">무한히 반복될 것만 같아 불편하다.</h5>
<p>마지막 <code>(cir2'</code> <code>dot</code> <code>cir1')</code> 해석이 어렵습니다.</p>
<p>실제 코드가 아니라 눈에 잘 보이게, <code>c1</code>과 <code>c2</code>의 합성을 <code>c1-c2</code>로 쓰고, 합성 결과에 있는 <code>...(c2' dot c1',...)</code>를 <code>c1'-c2'</code>라고 쓰겠습니다. 한 번돌고나서 새로 만들어지는 <code>Circuit</code>은 프라임<code>'</code>을 붙이겠습니다.</p>
<p>이 무한히 쌓여갈 것만 같은 <code>dot</code>의 반복은 어떻게 해석할까요?</p>
<p><code>in</code>을 빼고 <code>let</code>부분만 보면, 첫 번째 <code>Circuit</code>를 돌리고 나온 결과를, 두 번째 <code>Circuit</code>에 입력으로 넣어주고 있습니다. 텍스트에서 보면 <code>c1</code>이 안에 가지고 있는 <code>c1'</code>은 둘이 같거나, <code>c1</code>과 인자를 달리해서 만들어냅니다.(텍스트에선 결과에 의존해서 새 <code>Circuit</code>을 만듭니다.) <code>c1-c2</code>를 돌린 다음에, <strong><em>또</em></strong> 돌린다면 <code>c1'-c2'</code>을 돌립니다. 그 다음에 돌린다면 <code>c1''-c2''</code>을 돌릴 겁니다. <code>Circuit</code>들은 입출력으로 서로 이어지고 있지만, 다음 돌릴 자신의 “후임” <code>Circuit</code>은 각자 알아서 독립적으로 만들어 냅니다.</p>
<p>만일 5개의 <code>Circuit</code>을 합성했다면, 순서대로 입출력을 넘겨 받으며 <code>c1-c2-c3-c4-c5</code>를 실행하고, 다음 번에도 <code>c1'-c2'-c3'-c4'-c5'</code>를 돌릴거란 뜻으로 <code>Circuit $ \a -&gt; (c1'-c2'-c3'-c4'-c5', 다섯 개 Circuit을 연이어 돈 결과)</code>를 반환합니다. <code>runCircuit</code>이 “리스트에 남은 원소가 있다면”, 준비한 <code>c1'-c2'-c3'-c4'-c5'</code>를 돌리고, 다음 돌릴 <code>Circuit</code>은 <code>c1''-c2''-c3''-c4''-c5''</code>으로 준비 할 겁니다. 만일, <code>runCircuit</code>하기 전에 <code>c6</code>을 합성한다면 <code>(c1-c2-c3-c4-c5-c6, 여섯 개 Circuit을 연이어 돈 결과)</code>를 준비합니다.</p>
<p>제 생각을 쓰는 것도 어려우니, 읽는 분들에게 전달이 잘 될리가 없겠습니만, 그래도, 최선을 다해 불편함을 주는 부분을 짚어보면,</p>
<ul>
<li><code>Circuit</code>은 독립적으로 다음 <code>Circuit</code>을 준비합니다. 처음 <code>Circuit</code>에서 변하지 않을 수도 있고, 변했을 수도 있습니다.</li>
<li>합성하면, 입출력 값으로 이어져 돌긴 하지만, 자신들의 후임 <code>Circuit</code>은 각자 독립적으로 준비한 다음, 이 들을 모아서 다음 돌릴 준비를 합니다.</li>
</ul>
<p>전체적으로 불편함을 주는 이유는, <strong><em>여기선 무한 반복으로 갈 것만 같은 코드 모양이지만, runCircuit이 리스트에 원소가 남아 있는 동안만 반복 시킵니다.</em></strong> 무한 리스트를 정의하고, 필요한 만큼만 <code>take</code>하는 것과 비슷합니다. 하스켈에서 만나는 (실용적인) 무한한 것들은 대부분 필요한 만큼만 꺼내올 줄 아는 파트너가 존재합니다. 언제 멈출 수 있는지, <strong><em>언제 다음 반복을 시작하는지</em></strong>를 알게 되면 조금 덜 불편합니다.</p>
<h4 id="id">id</h4>
<p>이제 위 <code>(.)</code>을 만나 아무 일도 일어나지 않는 <code>id</code>를 정의합니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Cat.Category</span> <span class="dt">Circuit</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="ot">=</span> <span class="dt">Circuit</span> <span class="op">$</span> \a <span class="ot">-&gt;</span> (Cat.id, a)</span></code></pre></div>
<blockquote>
<p>Q. <code>Circuit</code>값이 들어갈 자리에 <code>Cat.id</code>가 들어가 있다. <code>cat a a</code>타입이니 컴파일러가 <code>Circuit a a</code>로 추론할 수는 있겠지만, 디폴트 구현이 있거나 하진 않다. 실제 구현은 없는 상태인데, 이래도 되는가?<br />
A. 추측) <code>Cat.id</code>를 <code>Circuit a a</code>로 추론할텐데, 그럼 현재 정의하고 있는 <code>id</code>를 재귀적으로 가지고 오면 됩니다.</p>
</blockquote>
<p><code>(.)</code>구현에 넣어 보겠습니다. 두 번째 인자로 주면</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Circuit</span> cir2) <span class="ot">`dot`</span> (<span class="dt">Circuit</span> <span class="op">$</span> \a <span class="ot">-&gt;</span> (Cat.id, a)) <span class="ot">=</span> <span class="dt">Circuit</span> <span class="op">$</span> \<span class="fu">init</span> <span class="ot">-&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (cir1', b) <span class="ot">=</span> (\a <span class="ot">-&gt;</span> (Cat.id, a) <span class="fu">init</span>)  </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">--             = (Cat.id, init)</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>      (cir2', c) <span class="ot">=</span> cir2 b </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">--                    init</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span>  (cir2' <span class="ot">`dot`</span> Cat.id, c)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">--                       c는 init에 Circuit을 한 번 적용한 것 과 같다.</span></span></code></pre></div>
<p>첫 번째 인자로 주면</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Circuit</span> <span class="op">$</span> \a <span class="ot">-&gt;</span> (Cat.id, a)) <span class="ot">`dot`</span> (<span class="dt">Circuit</span> cir1) <span class="ot">=</span> <span class="dt">Circuit</span> <span class="op">$</span> \<span class="fu">init</span> <span class="ot">-&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (cir1', b) <span class="ot">=</span> cir1 <span class="fu">init</span> </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>      (cir2', c) <span class="ot">=</span> (\a <span class="ot">-&gt;</span> (Cat.id, a) b)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">--             = (Cat.id, b)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span>  (Cat.id <span class="ot">`dot`</span> cir1', c)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">--                       c는 init에 Circuit을 한 번 적용한 것 과 같다.</span></span></code></pre></div>
<p>최종 결과에 여전히 남아 있는 <code>Cat.id</code>가 어찌될까 보기에 불편하긴 합니다. 그래도 정보량에서 다른 건 아닌가 하고요. 나중에 <code>runCircuit</code>으로 돌릴 때를 생각하면<br />
<code>Cat.id</code> <code>dot</code> <code>Circuit cir1</code>과<br />
<code>Circuit cir1</code> <code>dot</code> <code>Cat.id</code>는<br />
<code>Circuit cir1</code>과 같은 결과값을 가집니다.</p>
<h3 id="arrow-인스턴스">Arrow 인스턴스</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> <span class="dt">Circuit</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  arr f <span class="ot">=</span> <span class="dt">Circuit</span> <span class="op">$</span> \a <span class="ot">-&gt;</span> (arr f, f a)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  first (<span class="dt">Circuit</span> cir) <span class="ot">=</span> <span class="dt">Circuit</span> <span class="op">$</span> (\(b, d) <span class="ot">-&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (cir', c) <span class="ot">=</span> cir b</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span>  (first cir', (c, d)) <span class="co">-- d는 손 대지 않는다.</span></span></code></pre></div>
<p>Arrow는 합성할 함수를 래핑합니다. 여기선 <code>입력 -&gt; ( 다음에 쓸 Circuit , 현재 결과 )</code>를 래핑합니다.</p>
<p><code>arr</code>은 보통의 하스켈 함수를 Arrow로 리프팅할 때 씁니다.</p>
<h3 id="runcircuit">runCircuit</h3>
<p>타입으로 래핑해서 컴비네이션을 하는 것들은, 보통 <code>run~</code>과정을 거쳐 결과값을 얻습니다. 패턴 매칭이나 <code>unCircuit</code>같은 과정을 통해 래핑된 타입의 바깥 세계와 만나게 됩니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runCircuit ::</span> <span class="dt">Circuit</span> a b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>runCircuit _   []     <span class="ot">=</span> []</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>runCircuit cir (x<span class="op">:</span>xs) <span class="ot">=</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (cir', x') <span class="ot">=</span> unCircuit cir x</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span>  x' <span class="op">:</span> runCircuit cir' xs</span></code></pre></div>
<p>자기 자신을 가지고 있는 <code>Circuit</code>의 경우는 <code>cir'</code>과 <code>cir</code>이 같아져서 이런 패턴의 코드가 필요 없어도 될 것만 같지만, 다른 <code>Circuit</code>을 가지고 있을 수도 있기 때문에, <code>runCircuit</code>은 위와 같이 <code>cir</code>이 돈 후에, <code>cir'</code>이 돌도록 정의해햐 합니다. 무한 <code>Circuit</code>을 끊어주는 작업은 <code>[]</code> 패턴매칭이 담당합니다.</p>
<h3 id="accum">accum</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">accum ::</span> acc <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> acc <span class="ot">-&gt;</span> (b, acc)) <span class="ot">-&gt;</span> <span class="dt">Circuit</span> a b</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>accum acc f <span class="ot">=</span> <span class="dt">Circuit</span> <span class="op">$</span> \input <span class="ot">-&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (output, acc') <span class="ot">=</span> input <span class="ot">`f`</span> acc</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span>  (accum acc' f, output)</span></code></pre></div>
<p><code>f input acc</code> 작업을 <code>Circuit</code>으로 한 번 래핑한 덕분에, <code>acc</code>를 유지 및 유통할 수 있습니다.</p>
<blockquote>
<p>Q. <code>Circuit</code>이 들어갈 자리에 <code>accum acc' f</code>가 들어갔다?<br />
A. <code>accum</code>의 반환 타입은 <code>Circuit a b</code>입니다.</p>
</blockquote>
<blockquote>
<p>Q. <code>accum</code>이 무한 반복되는 건가?<br />
A. <code>acc</code>, <code>f</code>만 줘서 <code>accum</code>을 실행하면, 안에 있는 <code>accum</code>이 바로 불리지 않습니다. 안에 있는 <code>accum</code>이 불리려면 추가 절차가 있어야 합니다. <code>Circuit</code>으로 패턴 매칭을 해서 <code>\input -&gt; ... (accum ...)</code> 함수를 꺼내고, <code>input</code>값을 줘서 실행해야 합니다. 그렇게 실행하면 또 다시 <code>Circuit</code>값에 머물러 있고, 또 언젠가 패턴 매칭하면 그 때 다음 동작이 일어날 겁니다. 정리하면, 그냥은 반복되지 않고, 반복 절차로 들어가기 위한 추가 조건이 있는 셈입니다.</p>
</blockquote>
<p><code>accum</code>같은 함수를 읽을 때, 다음처럼 읽으면 도움이 됩니다.<br />
<code>accum</code>은 <code>acc</code>와 <code>f</code>를 받아서 <code>Circuit</code>을 <strong><em>만들어 내는 함수</em></strong>입니다. 현재는 <code>acc</code>, <code>f</code>를 가지고 작업했지만, 다음 작업은 <code>acc'</code>, <code>f</code>를 가지고 작업할 겁니다. <code>acc</code>가 <code>acc'</code>으로 바뀌었습니다.</p>
<h3 id="circuit-primitives">Circuit primitives</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">accum' ::</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Circuit</span> a b</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>accum' acc f <span class="ot">=</span> accum acc (\a b <span class="ot">-&gt;</span> <span class="kw">let</span> b' <span class="ot">=</span> a <span class="ot">`f`</span> b <span class="kw">in</span> (b', b'))</span></code></pre></div>
<p><code>accum</code>이 두 번째 인자로 받는 함수는 <code>a -&gt; acc -&gt; (b, acc)</code> 2튜플을 반환하는 함수를 받습니다. <code>accum'</code>는 반환값이 2튜플이 아닌 <code>a -&gt; b -&gt; b</code> 함수를 받아, 결과를 복사해서 2튜플로 만드는 과정을 붙여 <code>accum</code>에게 넘기는 보조 함수입니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">total ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Circuit</span> a a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>total <span class="ot">=</span> accum' <span class="dv">0</span> (<span class="op">+</span>)</span></code></pre></div>
<p>위 작업은 다음과 같습니다.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>total <span class="ot">=</span> accum <span class="dv">0</span> (결과값 복사해서 <span class="dv">2</span>튜플 만들기 <span class="op">.</span> (<span class="op">+</span>))</span></code></pre></div>
<p>이제 위에 그냥 무한 반복이 아니라, 반복하려면 절차가 필요하다고 말했던, 그 절차를 <code>runCircuit</code>으로 아래와 같이 실행할 수 있습니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runCircuit total [1,0,1,0,0,2]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>[1,1,2,2,2,4]</span></code></pre></div>
<p><code>runCircuit</code>은 <code>Circuit</code>타입과 리스트를 넘겨주면, 리스트 맨 앞 원소에 <code>Circuit</code>이 갖고 있는 작업을 진행해서 바꿔 놓고, 이어서 그 다음 원소에는 <code>Circuit</code>이 안에 갖고 있는 후임 <code>Circuit</code>을 적용합니다. 보통, 자기 자신과 같은 <code>Circuit</code>을 적용하거나, 조금 다른 인자로 만들어진 <code>Circuit</code>를 적용합니다.</p>
<blockquote>
<p>Q. 자신과 같은 <code>Circuit</code>을 계속 부르는데, 어떻게 값이 누적되고 있을까?<br />
A. <code>accum</code>의 반환 값 안에 있는 <code>...(accum acc' f, ...)</code>에서 <code>accum</code>은 함수고, <code>acc</code>와 <code>f</code>를 줘야만 <code>Circuit</code>이 됩니다. 현재 <code>Circuit</code>에 있는 함수를 적용해서 <code>acc'</code>을 만들고, 이 값으로 <code>accum</code>을 호출해서 다음 적용할 <code>Circuit</code>을 만듭니다. 완전 동일한 <code>Circuit</code>을 매 번 적용하고 있는 건 아닙니다.</p>
</blockquote>
<h3 id="arrow-proc-notation">Arrow <code>proc</code> notation</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mean1 ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Circuit</span> a a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>mean1 <span class="ot">=</span> (total <span class="op">&amp;&amp;&amp;</span> (<span class="fu">const</span> <span class="dv">1</span> <span class="op">^&gt;&gt;</span> total)) <span class="op">&gt;&gt;&gt;</span> arr (<span class="fu">uncurry</span> (<span class="op">/</span>))</span></code></pre></div>
<p>평균을 내려면 전체 합과 원소 수가 필요합니다.</p>
<p>여기선, 컴비네이터들이 하는 일만 간단히 보면,<br />
<code>(&amp;&amp;&amp;)</code>는 Arrow 두 개를 받아, 각각의 계산computation을 실행하고, 결과를 2튜플로 만듭니다.<br />
<code>(&gt;&gt;&gt;)</code>는 Arrow 두 개를 합성합니다.<br />
<code>(^&gt;&gt;)</code>는 <code>const 1 ^&gt;&gt; total</code> = <code>arr (const 1) &gt;&gt;&gt; total</code> 입니다.<br />
</p>
<p>※ 참고 - <a href="../posts/2023-09-14-arrow.html">Arrow는 모나드의 일반화</a></p>
<p><code>mean1</code>을 해석해 보면, 나중에 <code>runCircuit</code>으로 리스트가 들어오면,<br />
<code>total</code>을 돌려 누적값으로 바꾸고,<br />
<code>const 1 ^&gt;&gt; total</code>을 돌려, 들어온 값을 <code>1</code>로 바꾸고 <code>total</code>을 돌려 누적값으로 바꿉니다.<br />
결국 리스트의 가장 마지막 누적값이 원소 개수가 됩니다.</p>
<p><code>uncurry</code>가 없다면 <code>[(모든 원소를 더한 값, 원소 개수)]</code>이 됩니다. <code>C1 &amp;&amp;&amp; C2</code>에서 <code>C1</code>은 <code>C1</code>대로 후임 <code>Circuit</code>을 만들고, <code>C2</code>는 <code>C2</code>대로 후임 <code>Circuit</code>을 만듭니다.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runCircuit (total &amp;&amp;&amp; (const 1 ^&gt;&gt; total)) $ [0,10,7,8]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>[(0,1),(10,2),(17,3),(25,4)]</span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mean2 ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Circuit</span> a a</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>mean2 <span class="ot">=</span> proc value <span class="ot">-&gt;</span> <span class="kw">do</span> <span class="co">-- value에 0 10 7 8 순서대로 들어가면</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  t <span class="ot">&lt;-</span> total <span class="op">-&lt;</span> value <span class="co">-- 0 10 17 25 </span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> total <span class="op">-&lt;</span> <span class="dv">1</span> <span class="co">-- 1 2 3 4</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">-&lt;</span> t <span class="op">/</span> n <span class="co">-- 한 번 돌면 0/1 : 두 번째 10/2 : 세 번째 17/3 : 네 번째 25/4</span></span></code></pre></div>
<p>※ 참고 - <a href="../extensions/2023-09-14-arrow-extension.html">확장 Arrows</a></p>
<p><code>mean1</code>, <code>mean2</code>의 실행 결과는</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runCircuit mean1 [0,10,7,8]</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>[0.0,5.0,5.666666666666667,6.25]</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runCircuit mean2 [0,10,7,8]</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>[0.0,5.0,5.666666666666667,6.25]</span></code></pre></div>
<p><code>total</code>이 Arrow이기 때문에 <code>(&amp;&amp;&amp;)</code>을 써서 <strong><em>병행하는 작업</em></strong>을 쉽게 표현할 수 있습니다.</p>
<h3 id="hangman-게임">Hangman 게임</h3>
<p>행맨 게임: 낱말 맞추기. 알파벳 글자 수 만큼 빈자리를 만들어 둡니다. 돌아가며 한 글자를 골라서 낱말 안에 있으면 해당 자리에 보여주고, 없으면 페널티 포인트를 올리는 게임입니다.</p>
<p>위에서 정의한 <code>Circuit</code>을 이용해 게임 흐름을 모두 Arrow로 만드는 방법을 보여 줍니다.</p>
<p>제일 먼저 사전에서 랜덤하게 문제를 뽑습니다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">generator ::</span> <span class="dt">Random</span> a <span class="ot">=&gt;</span> (a, a) <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Circuit</span> () a</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>generator <span class="fu">range</span> rng <span class="ot">=</span> accum rng <span class="op">$</span> \() rng <span class="ot">-&gt;</span> randomR <span class="fu">range</span> rng</span></code></pre></div>
<p><code>accum</code>은 나중에 <code>runCircuit</code>을 통해 입력을 받아 <code>\() rng -&gt; ...</code> 함수를 실행한 후, 결과값을 가진 상태로 또 다음 <code>accum</code> 실행을 “준비”하는 함수입니다. 한 가지만 빼 놓고, 나머지 필요한 것들은 모두 미리 준비해 둔 작업입니다 .</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>dictionary <span class="ot">=</span> [<span class="st">&quot;dog&quot;</span>, <span class="st">&quot;cat&quot;</span>, <span class="st">&quot;bird&quot;</span>]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="ot">pickWord ::</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Circuit</span> () <span class="dt">String</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>pickWord rng <span class="ot">=</span> proc () <span class="ot">-&gt;</span> <span class="kw">do</span> <span class="co">-- 나중에 runCircuit으로 rng에 랜덤gen을 넘깁니다.</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  idx <span class="ot">&lt;-</span> generator (<span class="dv">0</span>, <span class="fu">length</span> dictionary <span class="op">-</span> <span class="dv">1</span>) rng <span class="op">-&lt;</span> ()</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  returnA <span class="op">-&lt;</span> dictionary <span class="op">!!</span> idx</span></code></pre></div>
<p>여기선 특별한 외부 입력값을 받는 건 아니고, <code>runCircuit</code>으로 더미로 <code>()</code> 유닛을 받을 겁니다. 유닛으로 채워진 리스트를 받으면, <code>gen</code>값이 바뀌는 걸 잃어버리지 않고 다음으로 넘겨가며 유닛 개수만큼 랜덤값을 뽑아냅니다.<br />
※ Reactive로 가면 이런 모양을 자주 만납니다. 시간의 흐름을 <code>()</code> 무한 리스트로 두고, 한 스텝(샘플링) 나아갈 때마다 <code>()</code>를 가져오는 것으로 모델링합니다.<br />
<code>Circuit</code>으로 래핑되어 있기 때문에, 안 쪽에 있는 함수에게 값을 주어 실행한다든지, 결과를 바깥으로 내보내려면, 매 번 패턴 매칭을 해서 풀어야 합니다. 하지만, Arrow 인스턴스로 만들었기 때문에, <code>&lt;-</code>,<code>-&lt;</code> 등을 이용해 쉽게 표현할 수 있습니다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>GHCi&gt; rng &lt;- getStdGen</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runCircuit (pickWord rng) [(), (), ()]</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>[&quot;dog&quot;,&quot;bird&quot;,&quot;dog&quot;]</span></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">oneShot ::</span> <span class="dt">Circuit</span> () <span class="dt">Bool</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>oneShot <span class="ot">=</span> accum <span class="dt">True</span> <span class="op">$</span> \_ acc <span class="ot">-&gt;</span> (acc, <span class="dt">False</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co">--                                     False로 하드 코딩</span></span></code></pre></div>
<p>당장은 이게 뭐하는 <code>Circuit</code>인가 싶은데 일단, 처음만 <code>True</code>를 돌려주고 그 후로는 <code>False</code>를 돌려준다는 것만 보고 넘어가 가겠습니다. (나중에 게임 시작에 딱 한 번만 일어나야 하는 동작을 표현할 때 씁니다.)</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runCircuit oneShot [(), (), (), (), ()]</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>[True,False,False,False,False]</span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">delayedEcho ::</span> a <span class="ot">-&gt;</span> <span class="dt">Circuit</span> a a</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>delayedEcho acc <span class="ot">=</span> accum acc (\a b <span class="ot">-&gt;</span> (b, a))</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co">--                                   누적값과 결과값을 스왑</span></span></code></pre></div>
<p>누적값과 결과값을 바꿔치기 합니다. 이 것도 뭐에 쓰는 물건인가 싶습니다.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runCircuit (delayedEcho False) [True, False, False, False, True]</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>[False,True,False,False,False]</span></code></pre></div>
<h4 id="arrowchoice">ArrowChoice</h4>
<p>게임의 메인 Arrow는 계속 반복해서 실행되고, 낱말은 처음 한 번만 뽑고, 게임 진행동안 계속 기억하고 있어야 합니다. Rather than just mask its output on subsequent loops (이 말은 아마도, 실제 뽑는 작업은 하면서, 쓰지 않는 걸 얘기하는 것 같습니다.) 실제 한 번만 돌아가는게 퍼포먼스에서 유리합니다. 하지만, Circuit에선 “Arrow 뭉치combination”에 포함된 Arrow 컴포넌트의 모든 경로로 데이터가 흘러갑니다. (골드 버그 장치 혹은 도미노 등이 연상됩니다.) 하나의 경로로만 흘러가게 하려면, <code>ArrowChoice</code>클래스의 인스턴스로 만들어야 합니다.</p>
<p>※ 뭉치란 말이 투박하긴 하지만, 컴비네이션 결과물을 지칭하기에 적당한 의미를 가진 듯 합니다. 다른 곳에서도 쓰이는 “용어”는 아닙니다. 순수 한글 말을 쓰려고 고른 게 아니라, 대상을 가장 잘 표현하는 적당한 말같아 골랐습니다.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ArrowChoice</span> <span class="dt">Circuit</span> <span class="kw">where</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  left orig<span class="op">@</span>(<span class="dt">Circuit</span> cir) <span class="ot">=</span> <span class="dt">Circuit</span> <span class="op">$</span> \ebd <span class="ot">-&gt;</span> <span class="kw">case</span> ebd <span class="kw">of</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> b  <span class="ot">-&gt;</span> <span class="kw">let</span> (cir', c) <span class="ot">=</span> cir b</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>               <span class="kw">in</span>  (left cir', <span class="dt">Left</span> c)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> d <span class="ot">-&gt;</span> (left orig, <span class="dt">Right</span> d)</span></code></pre></div>
<p><code>left</code>에 <code>Circuit</code>을 넣으면, <code>Either</code>를 받는 <code>Circuit</code>으로 바뀝니다. 입력으로 <code>Left</code>값이 들어 오면, 현재 <code>Circuit</code>이 가지고 있는 작업을 하고, <code>Right</code>가 들어 오면, 아무 작업도 하지 않습니다. 역시 마지막 라인의 <code>(left orig, Right d)</code>가 목에 걸립니다. <code>Either</code>를 받도록 바뀐 이 <code>Circuit</code>은, 다음 번 반복에도 <code>Either</code>를 받습니다. 위에서 설명한 <code>(.)</code>을 다시 떠올리면, <code>c1-c2</code> <code>Circuit</code>을 돌렸다면, 다음 번엔 <code>c1'-c2'</code>을 돌리게 됩니다. 반복하려 할 때, 매 번 처음부터 다시 Arrow 뭉치를 만드는 게 아닙니다. <strong><em>이전 반복에서 나온 결과들을 가지고 있는 상태</em></strong>입니다.</p>
<p>※ 하스켈은 다른 언어의 런타임들이 해주는 일을, <code>runCircuit</code>같은 걸로 사용자 수준으로 당겨온 느낌입니다.</p>
<p><code>ArrrowChoice</code> 인스턴스로 만들면, <strong><em>&lt;- 다음에 if를 쓸 수 있어</em></strong>, 이제 어떤 Arrow를 실행할지 고를 수 있습니다. 여기서 쓰인 <code>if</code>는 하스켈에서 보통 쓰던 그 <code>if</code>가 아닙니다.</p>
<h4 id="local-name-binding">local name binding</h4>
<p><code>&lt;-</code>와 <code>-&lt;</code> 사이에는 <code>proc</code>의 인자를 포함해서 어떤 local name binding도 들어갈 수 없습니다.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>proc rng <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    idx <span class="ot">&lt;-</span> generator (<span class="dv">0</span>, <span class="fu">length</span> dictionary <span class="op">-</span><span class="dv">1</span>) rng <span class="op">-&lt;</span> ()  <span class="co">--X 이렇게 못씀</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>                                           <span class="co">-- proc의 인자 rng를 &lt;-, -&lt; 사이에 써줄 수 없다.</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    returnA <span class="op">-&lt;</span> dictionary <span class="op">!!</span> idx</span></code></pre></div>
<p><code>generator (0, length disctionary -1)</code>을 평가 할 때는 <code>rng</code>가 스코프에 없습니다. 시작할 때만 Arrow가 생성되기 때문에 그렇습니다. 만일, 매 번 실행될 때마다 생성된다면 Arrow가 안에 상태state를 유지할 수 없을 겁니다.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getWord ::</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Circuit</span> () <span class="dt">String</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>getWord rng <span class="ot">=</span> proc () <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  firstTime <span class="ot">&lt;-</span> oneShot <span class="op">-&lt;</span> () <span class="co">-- 처음 시작에만 True고, 그 뒤로는 모두 False</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  mPicked <span class="ot">&lt;-</span> <span class="kw">if</span> firstTime</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="kw">do</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>      pciked <span class="ot">&lt;-</span> pickWord rng <span class="op">-&lt;</span> () <span class="co">-- 처음 시작이면 단어 선택</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>      returnA <span class="op">-&lt;</span> <span class="dt">Just</span> picked</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>      returnA <span class="op">-&lt;</span> <span class="dt">Nothing</span> <span class="co">-- 처음 시작이 아니라면 Nothing</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>  mWord <span class="ot">&lt;-</span> accum' <span class="dt">Nothing</span> mplus <span class="op">-&lt;</span> mPicked </span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Nothing `mplus` (Just &quot;dog&quot;) = Just &quot;dog&quot;</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (Just &quot;cat&quot;) `mplus` (Just &quot;dog&quot;) = Just &quot;cat&quot;</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>  returnA <span class="op">-&lt;</span> fromJust mWord</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- fromJust는 Nothing이면 error를 던진다.</span></span></code></pre></div>
<p><code>getWord</code>를 실행해 보면,</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>GHCi&gt; rng &lt;- getStdGen</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>GHCi&gt; runCircuit (getWord rng) [(), (), (), (), (), ()]</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>[&quot;dog&quot;,&quot;dog&quot;,&quot;dog&quot;,&quot;dog&quot;,&quot;dog&quot;,&quot;dog&quot;]</span></code></pre></div>
<p>여러 개의 <code>Circuit</code>들을 붙여 <code>Circuit</code> 뭉치를 만들고, 이 뭉치를 <code>runCircuit</code>으로 반복해서 돌릴텐데, 이렇게 도는 동안 <code>getWord</code>는 몇 번을 돌려도 처음 선택한 값만 가지고 있습니다.</p>
<h4 id="circuit-뭉치-실행">Circuit 뭉치 실행</h4>
<p>게임중에 반복되어 실행될 코드를 보면</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">attempts ::</span> <span class="dt">Int</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>attempts <span class="ot">=</span> <span class="dv">5</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="ot">livesLeft ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>livesLeft hung <span class="ot">=</span> <span class="st">&quot;Lives: [&quot;</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>                <span class="op">++</span> <span class="fu">replicate</span> (attempts <span class="op">-</span> hung) <span class="ch">'#'</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>                <span class="op">++</span> <span class="fu">replicate</span> hung <span class="ch">' '</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>                <span class="op">++</span> <span class="st">&quot;]&quot;</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="ot">hangman ::</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Circuit</span> <span class="dt">String</span> (<span class="dt">Bool</span>, [<span class="dt">String</span>]) <span class="co">------- Circuit 타입!</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>hangman rng <span class="ot">=</span> proc userInput <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>  word <span class="ot">&lt;-</span> getWord rng <span class="op">-&lt;</span> () <span class="co">-- 문제를 랜덤하게 고르고,</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> letter <span class="ot">=</span> listToMaybe userInput <span class="co">-- 나중에 runCircuit이 넣어 준다.</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>  guessed <span class="ot">&lt;-</span> updateGuess <span class="op">-&lt;</span> (word, letter)</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>  hung <span class="ot">&lt;-</span> updateHung <span class="op">-&lt;</span> (word, letter)</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>  end <span class="ot">&lt;-</span> delayedEcho <span class="dt">True</span> <span class="op">-&lt;</span> <span class="fu">not</span> (word <span class="op">==</span> guessed <span class="op">||</span> hung <span class="op">&gt;=</span> attempts)</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> result <span class="ot">=</span> <span class="kw">if</span> word <span class="op">==</span> guessed</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">then</span> [guessed, <span class="st">&quot;You won!&quot;</span>]</span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">else</span> <span class="kw">if</span> hung <span class="op">&gt;=</span> attempts</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>                       <span class="kw">then</span> [guessed, livesLeft hung, <span class="st">&quot;You died!&quot;</span>]</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>                       <span class="kw">else</span> [guessed, livesLeft hung]</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>  returnA <span class="op">-&lt;</span> (end, result)</span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a><span class="ot">  updateGuess ::</span> <span class="dt">Circuit</span> (<span class="dt">String</span>, <span class="dt">Maybe</span> <span class="dt">Char</span>) <span class="dt">String</span> <span class="co">------- Circuit 타입!</span></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>  updateGuess <span class="ot">=</span> accum' (<span class="fu">repeat</span> <span class="ch">'_'</span>) <span class="op">$</span> \(word, letter) guess <span class="ot">-&gt;</span></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> letter <span class="kw">of</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> l <span class="ot">-&gt;</span> <span class="fu">map</span> (\(w, g) <span class="ot">-&gt;</span> <span class="kw">if</span> w <span class="op">==</span> l <span class="kw">then</span> w <span class="kw">else</span> g) (<span class="fu">zip</span> word guess)</span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">take</span> (<span class="fu">length</span> word) guess</span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a><span class="ot">  updateHung ::</span> <span class="dt">Circuit</span> (<span class="dt">String</span>, <span class="dt">Maybe</span> <span class="dt">Char</span>) <span class="dt">Int</span> <span class="co">------- Circuit 타입!</span></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>  updateHung <span class="ot">=</span> proc (word, letter) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a>    total <span class="op">-&lt;</span> <span class="kw">case</span> letter <span class="kw">of</span></span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> l <span class="ot">-&gt;</span> <span class="kw">if</span> l <span class="ot">`elem`</span> word <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> <span class="dv">1</span></span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dv">0</span></span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a>  rng <span class="ot">&lt;-</span> getStdGen</span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a>  <span class="fu">interact</span> <span class="op">$</span> <span class="fu">unlines</span></span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span> (<span class="st">&quot;Welcome to Arrow Hangman&quot;</span><span class="op">:</span>)</span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span> <span class="fu">concat</span> <span class="op">.</span> <span class="fu">map</span> <span class="fu">snd</span> <span class="op">.</span> <span class="fu">takeWhile</span> <span class="fu">fst</span></span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span> runCircuit (hangman rng)</span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span> (<span class="st">&quot;&quot;</span><span class="op">:</span>)</span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span> <span class="fu">lines</span></span></code></pre></div>
<p><code>hangman</code>이란 커다란 <code>Circuit</code> 뭉치를 만들고, <code>runCircuit</code>이 입력이 “한 번” 들어올 때마다 돌립니다. (합성 설명할 때처럼 바뀌었다는 의미에서 프라임을 붙이겠습니다.) 처음엔 <code>Circuit</code>을 돌리고, 그 다음 번엔 <code>Circuit'</code>을 돌리고, 그 다음엔 <code>Circuit''</code>… 이런 식입니다. <code>Circuit</code>이 돌고 나서 (continuation으로) 후임 <code>Circuit'</code>을 준비하는데, 기억해야 하는 정보를 모두 집어 넣어 준비합니다.</p>
<p>전역 변수 같은 바깥 스코프의 mutable한 변수-기억 장소-를 둘 수 없기 때문에 필요한 테크닉입니다. 지금 동작하는 함수 뭉치가, 결과값과 함께 다음 번 돌릴 함수continuation를 준비하면서 <strong><em>기억해야 될 것들을 새로 만드는 함수에 실어 놓습니다.</em></strong> 그리고는 <code>run</code>Circuit 같은 것들이 <code>run</code>하면서 준비된 함수를 실행합니다.</p>
<p>※ Reactive(Reactive-banana, Yampa, Reflex)를 볼 때 비슷한 모양들을 만나게 되니, 이런 continuation을 가진 모양에 충분히 익숙해지면 도움이 됩니다. 쓰고 보니, 함수형 전반에 걸쳐서 계속 만나는 모양입니다.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>Welcome to Arrow Hangman</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>___</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>Lives: [#####]</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>a</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>___</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>Lives: [#### ]</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>g</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>__g</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>Lives: [#### ]</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>d</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>d_g</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>Lives: [#### ]</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>o</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>dog</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>You won!</span></code></pre></div>
<h4 id="lazy-와-stream">Lazy 와 Stream</h4>
<p><code>interact</code>함수는 전체 stdin 입력을 받아 <code>String -&gt; String</code> 함수에 넘깁니다.<br />
<code>lines</code>는 <code>String</code>을 받아 <code>[String]</code> 리스트로 만듭니다.<br />
<code>runCircuit</code>은 <code>Circuit</code>과 리스트를 받으면 리스트를 출력합니다.<br />
</p>
<p><code>interact</code>가 받은 함수는, 한 번 돌아서 작업을 마친 후에, 또 반복하며 도는게 아닙니다. <code>String</code>을 받아 한 번만 돌고 <code>String</code>을 출력할 뿐입니다. 중간에, 원소 하나에 대한 작업이 끝나면 볼 수 있게 해놨을 뿐, <code>interact</code>가 <code>String -&gt; String</code>함수를 loop 돌리는 게 아닙니다. 실행시킨 후 특별히 Ctrl-c 등으로 stdin을 끌내지 않으면, 입력으로 들어가는 <code>String</code>이 무한히 들어갑니다. <code>Enter</code>키를 누를 때마다 <code>lines</code>가 출력할 리스트의 원소 하나가 준비됩니다. 그럼 리스트를 받는 <code>runCircuit</code>이 전체는 아직이라도, 원소 하나가 준비되는대로 가져옵니다. 원소 하나를 받아 <code>Circuit</code>을 돌리고, 후임 <code>Circuit</code>을 준비한 후 다음 원소를 Lazy하게 기다립니다.</p>
<p><strong>스트림</strong>(여기선 무한 리스트지만, 어떤 것이든 재귀로 정의된 타입)을 다루는 Lazy 표현은 우아하지만, Strict 나라에서 살던 사람이, Lazy 나라로 넘어와서, 읽는 것을 넘어 원어민처럼 생각 자체를 Lazy하게 하려면 벽이 심하게 높은 것 같습니다.</p>
<h3 id="바나나-브라켓---함수와-arrow-명령어-묶기combine">바나나 브라켓 - 함수와 arrow 명령어 묶기combine</h3>
<p>GHC에는 <code>arrow</code> 구문과, <code>arrow</code>에 적용하는 함수를 컴바인하는 바나나 브라켓 <code>(|   |)</code>가 있습니다. 이를 이용하면 다음처럼 쓸 수 있습니다.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mean3 ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Circuit</span> a a</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>mean3 <span class="ot">=</span> proc value <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  (t, n) <span class="ot">&lt;-</span> (<span class="op">|</span> (<span class="op">&amp;&amp;&amp;</span>) (total <span class="op">-&lt;</span> value) (total <span class="op">-&lt;</span> <span class="dv">1</span>) <span class="op">|</span>)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  returnA <span class="op">-&lt;</span> t <span class="op">/</span> n</span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mean2 ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Circuit</span> a a</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>mean2 <span class="ot">=</span> proc value <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  t <span class="ot">&lt;-</span> total <span class="op">-&lt;</span> value</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> total <span class="op">-&lt;</span> <span class="dv">1</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  returnA <span class="op">-&lt;</span> t <span class="op">/</span> n</span></code></pre></div>
<p><code>Arrow</code>를 인자로 받아 동작하는 함수와 <code>Arrow</code> 구문을 묶을 때 바나나 브라켓을 쓴다고 합니다. (Ross Paterson 논문에선 괄호 대신 <code>form</code> 키워드를 썼다고 합니다.) 바나나 브라켓 안의 첫 번째 아이템은 임의의 개수의 <code>Arrow</code>를 입력으로 받아 <code>Arrow</code>를 돌려주는 함수입니다. 중위 연산자는 이 안에서는 쓸 수 없습니다.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mean3 ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Circuit</span> a a</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>mean3 <span class="ot">=</span> proc value <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  (t, n) <span class="ot">&lt;-</span> (<span class="op">|</span> (<span class="op">&amp;&amp;&amp;</span>) (total <span class="op">-&lt;</span> value) (total <span class="op">-&lt;</span> <span class="dv">1</span>) <span class="op">|</span>)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>               <span class="op">^^^^^</span> <span class="op">^^^^^^^^^^^^^^^^</span> <span class="op">^^^^^^^^^^^^</span> </span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span>        <span class="dt">Arrow</span>          <span class="dt">Arrow</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>               <span class="dt">Arrow</span>를 받는 함수</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  returnA <span class="op">-&lt;</span> t <span class="op">/</span> n</span></code></pre></div>
<p>“Although there’s no reason to” 라고 하는 걸로 보아, 잘 안 쓰이나 봅니다. <code>proc</code> 구문을 쓰지 않고 편하게 <code>Arrow</code>를 묶을combine 수 있는 게 장점인데,</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mean4 ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Circuit</span> a a</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>mean4 <span class="ot">=</span> proc value <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  (t, n) <span class="ot">&lt;-</span> (total <span class="op">-&lt;</span> value) <span class="op">&amp;&amp;&amp;</span> (total <span class="op">-&lt;</span> <span class="dv">1</span>)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">-&lt;</span> t <span class="op">/</span> n</span></code></pre></div>
<p>이렇게, 바나나 브라켓을 떼어내도 GHC가 알아서 잘 해석한다니, 가볍게 보고 지나가도 될 것 같습니다.</p>
<h2 id="왜-hangman-게임-흐름을-arrow-인스턴스인-circuit으로-모델링했을까">왜 Hangman 게임 흐름을 Arrow 인스턴스인 Circuit으로 모델링했을까?</h2>
<p>이 글은, 어떤 요소가 Arrow로 해결하면 좋은가를 찾는 게 목표입니다.</p>
<p>먼저 <code>Circuit</code>을 왜 Arrow 인스턴스로 만들었을까요?</p>
<h3 id="circuit-타입은-뭘-의미할까요"><code>Circuit</code> 타입은 뭘 의미할까요?</h3>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>eachTimeAddOne <span class="ot">=</span> <span class="dt">Circuit</span> (\a <span class="ot">-&gt;</span> ( eachTimeAddOne, (<span class="op">+</span><span class="dv">1</span>) a))</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 원래 작업은            \a -&gt;                   (+1) a  </span></span></code></pre></div>
<p><code>\a -&gt; a + 1</code>을 <code>Circuit</code> 타입에 넣으면 무슨 일을 할 수 있을까요?</p>
<p>함수형은 모든 필요한 값은 인자로 받아야만 하고, 전역 변수같이 메모리를 따로 둘 수 없어 체이닝동안 생기는 기억해야 할 값들을 편리하게 다루기 위한 테크닉들이 필요합니다.</p>
<p>(지금 부터는 아주 상상입니다.)</p>
<h4 id="함수-추가-정보">함수 + 추가 정보</h4>
<p><code>\a -&gt; a + 1</code>을 <code>Circuit</code>으로 래핑해 두면, 반드시 <code>Circuit</code>을 패턴 매칭해서 안을 봐야 <code>a + 1</code>을 꺼내 올 수 있으니, 반드시 일어나야 하는 절차를 둘 곳이 생깁니다. 타입으로 래핑하니, 같이 따라 다녀야 할 정보를 둘 자리도 튜플같은 Product 타입으로 마련할 수 있습니다.</p>
<p>여러 정보를 한 곳에 묶어두는 방법으로 함수 안에다 두는 방법이 있습니다. 체이닝동안 필요한 정보를 product 타입으로 둘 수도 있지만, 함수가 가지고 있게 할 수도 있습니다. 동적인 정보라면 이렇게 하는 쪽이 더 적합할 수 있습니다.</p>
<h4 id="사실은-컴비네이터-체이닝">사실은 컴비네이터 체이닝</h4>
<p>보통 함수 체이닝을 할 때 <code>(.)</code>을 써서 체이닝을 합니다. 하스켈에서 이루어지는 체이닝(컴비네이션)들은 자세히 보면, 타입이 가지고 있는 함수를 체이닝 하거나, 혹은 함수 자체를 체이닝 하는 것처럼 말하지만, 사실은 컴비네이터를 체이닝하는 것입니다. 예를 들어 <code>a -&gt; b</code>, <code>b -&gt; c</code>, <code>c -&gt; d</code>를 체이닝한다면, <code>(.) (b -&gt; c) (a -&gt; b)</code>와 <code>(c -&gt; d)</code>를 다시 <code>(.)</code>으로 묶습니다. <code>(.)</code>의 체인입니다. 체이닝할때마다 반복되는 작업이 있다면 <code>(.)</code>을 새롭게 정의하면 됩니다. 모나드 같은 경우는 Effect 관련 작업은 바인드가 맡아서 하도록 해 뒀습니다. 모나드 경우도 <code>a -&gt; m b</code>의 체인이 아니라, 바인드의 체인입니다.</p>
<h4 id="run">RUN!</h4>
<p>코드 구석 구석을 읽다보면, 이 부분을 간과하는 경우가 많은 것 같습니다. 타입, 컴비네이터 공조만으로 끝난 게 아니라, 한 가지가 더 있습니다. 바로 트리거를 당기는 역할을 하는 <code>run~</code>류의 함수들입니다. 우리말로는 “실행기runner”라 번역하기도 합니다. <code>Circuit</code>타입을 정의하고, 합성하거나 흐름을 제어하는 컴비네이터들을 정의해서 커다란 <code>Circuit</code> 뭉치를 만들었다면, 마지막 <code>runCircuit</code>을 거치게 됩니다.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>입력 a를 받아서 b를 얻기까지 보통 함수와 Circuit의 차이</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>a -&gt; b    vs    Circuit 타입</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>                각 종 컴비네이터</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>                runCircuit</span></code></pre></div>
<p>절차를 이리 많이 추가해 뒀으니, 훨씬 많은 걸 표현할 수 있는 건 당연한데, 명령형에 머리가 고정되어 있어, 가끔 퍼포먼스가 염려되긴 합니다.</p>
<h4 id="반복해서-돈다.-그래서-이름이-circuit이다.">반복해서 돈다. 그래서 이름이 Circuit이다.</h4>
<p>이제 위 시각으로 <code>Circuit</code>을 읽어 보겠습니다.<br />
언젠가 <code>a</code>를 받으면 <code>b</code>를 돌려주는 게 아니라,<br />
언젠가 <code>a</code>를 받으면, <code>(후임 Circuit - 다음 이어지는 작업에 할 일, 결과 b)</code> 2튜플을 결과로 돌려줄 “준비”를 한 함수를 돌려줍니다. <strong><em>후임 Circuit은 결과 b에 의존해서 만들거나 현재 Circuit과 같을 수 있습니다.</em></strong> 그럼, <code>runCircuit</code>이 처음 입력값 <code>a</code>를 가지고, 리스트의 첫 번째 원소에 작업을 하고, 그 다음 원소를 꺼내 후임 <code>Circuit</code>을 꺼내와 사용합니다. 이 후임 <code>Circuit</code> 안에는 또 이어서 쓸 후임 <code>Circuit</code>이 들어 있습니다.</p>
<h3 id="반복되는-작업을-circuit으로-모델링">반복되는 작업을 Circuit으로 모델링</h3>
<p>계속 반복되는 메인 루프가 있고, 루프가 도는 동안 기억해야 할 정보들이 있습니다. 아주 일반적인 상황 아닌가 싶은데요. 행맨 정도의 게임에서는 <code>Circuit</code>으로 모델링하는 게 우아해 보이기는 한데, 루프가 복잡해져도 우아할 수 있을까 싶습니다.</p>
<h3 id="왜-circuit을-arrow-인스턴스로-만들까">왜 Circuit을 Arrow 인스턴스로 만들까?</h3>
<p>루프 안을 뜯어보면, 데이터 흐름을 요리 조리 바꿔야 합니다. 병행 작업을 하는 것도 있고, 상황에 따라 분기(<code>if</code>)해야 하는 것도 있고요. 이럴 때 <code>Arrow</code> 인터페이스를 도입하면, 병행, <code>if</code>를 다루는 인터페이스도 있고, 무엇보다 <code>do</code> 노테이션으로 보기 좋게 표현할 수 있다는데 눈이 갑니다.</p>
<p>위 정리는 너무 일반적인 상황이라, 이 게 Arrow가 쓰이는 이유라면, 엄청나게 많은 경우에 Arrow를 쓸텐데, 그러지 않는 걸 보면 모델링 대상이 복잡해지면 우아하지 않기 때문 아닐까요?</p>
<p>합성 <code>(.)</code>을 일반화 하기 위해 타입으로 래핑한다는 생각은 어렵지 않지만, 이렇게 래핑한 것들의 흐름을 제어할 수 있는 체계들을 정돈되게 만들어 둔 건 쉽게 생각할 수 있는 건 아니겠습니다.</p>
<p>참고<br />
Arrow를 이론적으로 접근하면 Freyd Category로 접근해야 하는데, 그나마 실용에 좀 가까운 “이론”으로 접근하려면
<a href="https://www.youtube.com/watch?v=hrNfkP8iKAs">Bartosz Milewski - Arrows are strong profunctor</a> 이 출발점이 될 수 있겠습니다.</p>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
