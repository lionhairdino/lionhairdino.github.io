<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - 모나드로 가기 전 생각 스트레칭</title>

        <meta name="description" content="a와 m a를 같게 볼 수 있는 방법에 촛점을 둔 간략한 모나드 설명입니다." />
        <meta property="og:description" content="a와 m a를 같게 볼 수 있는 방법에 촛점을 둔 간략한 모나드 설명입니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="모나드로 가기 전 생각 스트레칭" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2022-03-25-beforeMonad.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/1mm.png" />

      <meta name="keywords" content="Monad, 모나드, Functor, 펑크터, 펑터, Maybe, 같음">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
    </head>
    <body>
        <div id="header" style>
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../" style>lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 주의! 틀린 내용이 있을 수 있습니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않습니다.
            </div>
        </div>
        <div id="content">
            <h1>모나드로 가기 전 생각 스트레칭</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on March 25, 2022
    
</div>

<p>모나드로 가기 전에 한 번쯤 생각해 보면 도움이 될 것 같은 내용들을 정리했습니다.<br />
사전 지식으론 <code>Functor</code>와 <code>Maybe</code>를 알고 보시면 좋습니다.</p>
<ol type="1">
<li><a href="#펑크터로-변환한-타입과-변환-전-타입의-관계">펑크터로 변환한 타입과 변환 전 타입의 관계</a></li>
<li><a href="#펑크터가-같이-있는-함수">펑크터가 같이 있는 함수</a></li>
<li><a href="#서로-다른-정도를-표현하는-방법-함수">서로 다른 정도를 표현하는 방법: 함수</a></li>
<li><a href="#갔다가-돌아올-필요는-없다-functor">갔다가 돌아올 필요는 없다 Functor</a></li>
<li><a href="#패턴-매칭">패턴 매칭</a></li>
<li><a href="#갔다가-돌아와야만-한다-monad">갔다가 돌아와야만 한다 Monad</a></li>
<li><a href="#특정-작업을-하는-동안만은-같은-걸로-보기">특정 작업을 하는 동안만은 같은 걸로 보기</a></li>
<li><a href="#우리는-이미-fmap을-갖고-있다">우리는 이미 fmap을 갖고 있다</a></li>
<li><a href="#bind">Bind</a></li>
<li><a href="#하스켈에서-join-구현">하스켈에서 join 구현</a></li>
<li><a href="#결론">결론</a></li>
<li><a href="#모나드가-필요함을-눈치-채는-예시">모나드가 필요함을 눈치 채는 예시</a></li>
<li><a href="#카테고리-이론으로-가는-힌트">카테고리 이론으로 가는 힌트</a></li>
<li><a href="#여기-글은-독일수도-있다">여기 글은 “독”일수도 있다</a></li>
</ol>
<p>하스켈에서 함수의 합성composition은 정말 중요합니다. 시작과 끝이라고 봐도 될 정도로 핵심 근간을 이루는 개념입니다. 모나드는 함수의 연이은 합성을 목표로 하는 패턴입니다. 대부분 모나드 자료는 합성에서 설명을 풀어 나갑니다. 하지만, 여기서는 “합성” 자체보다, 합성을 하기 위해 필요한 “같음”에 주목했습니다. 함수를 합성하려면 첫 함수의 결과값과 이어지는 두 번째 함수의 입력값이 서로 같아야 합니다. 아니면, 적어도 같게 만들 수 있는 함수가 있어야 합니다. “같게 볼 수 있게 만드는 함수”가 있다면, 복잡한 테크닉 없이 그냥 이 함수를 적용하기만 하면 됩니다. 눈에 보이는 “같게 볼 수 있게 만드는 함수”가 없을 경우가 문제입니다.</p>
<p><br /><font size="7em" style="font-weight: bolder">“a 와 m a는 얼마나 다를까?”</font><br /><br /></p>
<h2 id="펑크터로-변환한-타입과-변환-전-타입의-관계">펑크터로 변환한 타입과 변환 전 타입의 관계</h2>
<ol type="1">
<li>몸무게를 표현하기 위해 <code>Int</code> 타입 값이 필요한데, 몸무게가 변할 때마다 이유를 기록해 두고 싶습니다.</li>
<li><code>Weight Int [String]</code>을 타입으로 두면 될 것 같습니다. 이럴 때 <code>Int</code>에서 <code>Weight Int [String]</code>으로 “변환Transform” 되었다고 말합니다.</li>
<li><code>Int</code>용 <code>(+)</code>, <code>(-)</code>는 이미 있으니 이 함수를 그대로 써서 새로운 타입에 적용하고 싶습니다.</li>
<li><code>(+)</code>, <code>(-)</code>를 다시 정의하지 않고, 기존 함수들을 사용할 때, 바로 사용하지 않고 중간에 끼어들어 <code>Weight</code>에서 <code>Int</code>를 꺼내주는 브로커 함수를 만들면 됩니다. (이 함수를 <code>fmap</code>이라 부릅니다.)</li>
<li><code>fmap</code> 함수를 <code>Weight</code> 타입에서 쓸 수 있도록 추가해 주는데, 이럴 때 “펑크터 구조를 추가했다 또는 변환했다”라고 합니다.</li>
</ol>
<p>이런식으로 하스켈에서 프로그램을 작성하다 보면, 수많은 “타입을 갑싼 타입”들이 생기게 되는데, 이들은 기존 데이터와 아주 다른 것이 아닙니다. 위 몸무게의 예는 <code>Int</code>가 가지는 속성은 똑같이 가지고 있고, 추가적으로 “[String]”을 갖고 있다고 봅니다. <code>Int</code>를 처리하던 함수들은 모두 그대로 쓰고 싶습니다. 그럴 때 <code>fmap</code>을 추가한 타입들을 펑크터라고 부릅니다. 여기 글에서 주목하는 부분은 바로 몸무게 <code>Weight</code>와 <code>Int</code>의 <em>다른(닮은) 정도</em>입니다.</p>
<p>“<code>Weight Int [String]</code> 과 <code>Int</code>는 다르지만, <code>Int</code> 성질은 둘 다 가지고 있는 닮은 타입이다.”</p>
<h2 id="펑크터가-같이-있는-함수">펑크터가 같이 있는 함수</h2>
<p>이렇게 펑크터를 정의하면 당연히 펑크터로 변환된 타입들을 처리하는 함수들이 필요합니다. 펑크터가 적용되어 있는 타입과 관련된 함수는 3가지 형태가 있을 수 있습니다. (하스켈은 unary 함수만 있으니, 그 것만 보면 됩니다.) 하스켈 함수들은 합성이 가는해야 효용성이 높아집니다. 각 형태들의 합성을 생각해 보면</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>m a <span class="ot">-&gt;</span> m b</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>m a <span class="ot">-&gt;</span> b</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>우선 첫 번째는 입력과 출력 모두 같은 펑크터 적용이 되어 있으니 <code>a -&gt; b</code> , <code>b -&gt; c</code> 함수를 합성하듯 간단히 함수 컴포지션 <code>(.)</code>으로 연결할 수 있습니다.</p>
<figure>
<img src="../images/before_monad_mbmb.png" alt="mb와 mb가 만난다" /><figcaption aria-hidden="true">mb와 mb가 만난다</figcaption>
</figure>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(m a <span class="ot">-&gt;</span> m b) <span class="op">.</span> (m b <span class="ot">-&gt;</span> m c)</span></code></pre></div>
<p>두 번째는 입 출력이 다른 펑크터 타입이라 함수 컴포지션으로 해결할 수 없습니다. 이건 모나드가 익숙해진 후 <a href="../posts/2021-05-06-comonad.html">코모나드</a> 글에서 보도록 하겠습니다.</p>
<p>마지막 세 번째도 입력과 출력이 다른데 어떻게 연결하면 좋을까요?</p>
<figure>
<img src="../images/before_monad_mbb.png" alt="mb와 b가 만난다" /><figcaption aria-hidden="true">mb와 b가 만난다</figcaption>
</figure>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(a <span class="ot">-&gt;</span> m b) <span class="op">???</span> (b <span class="ot">-&gt;</span> m c)</span></code></pre></div>
<p><code>m b</code>와 <code>b</code> 둘이 <em>같은 걸</em>로 볼 수만 있다면, 아무 문제 없을텐데요.</p>
<p>※ 왜 <code>a -&gt; m b</code> 타입이 중요한지 <a href="../posts/2021-05-18-stateless.html">상태 “개념”은 함수형에도 있다</a> 글을 참고하시면 도움이 됩니다.</p>
<blockquote>
<p>Q. <code>m a -&gt; m b</code> 도 <code>a</code>와 <code>b</code>가 다르니 다른 타입 아닌가요? A. 여기서 같다 다르다의 관심사는 한 함수 내에서가 아니라, 다음 함수와 합성할 때 접점에서 만나게 되는 타입을 말합니다. <code>m a -&gt; m b</code>는 <code>m b -&gt; m c</code> 함수를 <code>(.)</code>으로 연결할 수 있다는 말입니다.</p>
</blockquote>
<h2 id="서로-다른-정도를-표현하는-방법-함수">서로 다른 정도를 표현하는 방법: 함수</h2>
<p><code>3</code>과 <code>5</code>가 얼마나 다를까요?</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">`3`</span>은 <span class="ot">`0`</span>에서 <span class="ot">`3`</span>만큼 떨어져 있고, (<span class="op">+</span><span class="dv">3</span>)   </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ot">`5`</span>는 <span class="ot">`0`</span>에서 <span class="ot">`5`</span>만큼 떨어져 있다<span class="op">.</span> (<span class="op">+</span><span class="dv">5</span>)</span></code></pre></div>
<p>기준에서 부터 측정된 값들을 서로 계산해서 둘의 다른 정도를 구하게 됩니다.<br />
“(5 - 3) = 2, 또는 (3 - 5) = -2”<br />
“3에서 5는 2만큼 떨어져 있다.”<br />
기준을 만들고 특정 연산(함수)을 이용해서 대상들을 비교하면, 같은지 다른지 좀 더 모호하지 않게 얘기할 수 있게 됩니다.</p>
<figure>
<img src="../images/1mm.png" alt="기준이 되는 자가 있어야 합니다." /><figcaption aria-hidden="true">기준이 되는 자가 있어야 합니다.</figcaption>
</figure>
<p><code>a</code> 와 <code>m a</code>는 다릅니다. “얼마나” 다를까요?<br />
기준이 있다면 기준과 <code>a</code>는 이만큼 다르고, 기준과 <code>m a</code>는 저만큼 다르다라고 얘기할 수 있습니다.</p>
<p><code>m a</code>를 기준으로 잡고, <code>a</code>가 얼마나 다른지 나타내는 함수가 있으면, <em>함수만큼 다르다</em>고 말할 수 있습니다. (기준을 <code>a</code>가 아닌 <code>m a</code>로 잡은 이유는, 보통 우리가 필요로 하는 정보를 모두 갖고 있는 타입은 <code>m a</code>인데, 함수들이 <code>a</code> 타입을 받아 문제가 생깁니다.)</p>
<h2 id="갔다가-돌아올-필요는-없다-functor">갔다가 돌아올 필요는 없다 Functor</h2>
<p><code>m a</code>값에 적용해야 될 함수가 <code>a -&gt; b</code>이면 <code>m a</code>와 <code>a</code>가 달라 적용할 수 없습니다. 매직은 없습니다. <code>m a</code>를 <code>a</code>로 바꾸든, <code>a -&gt; b</code>를 <code>m a -&gt; b</code> 또는 <code>m a -&gt; m b</code>로 바꾸든 해야 합니다. 필요한 정보를 모두 가지고 있는 타입은 <code>m b</code>이니, <code>m a -&gt; m b</code> 타입으로 만듭니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- tip: 여기서는 (a -&gt; b) -&gt; (f a -&gt; f b) 보다는</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- (a -&gt; b) 와 f a 를 받아 f b를 돌려주는 함수로 읽는게 더 직관적으로 보입니다.</span></span></code></pre></div>
<p><code>Functor</code> 클래스의 <code>fmap</code>을 구현할 때는 단순히 타입만 변경하는게 아닙니다. <code>f</code>을 벗겨 낼때는 <code>a</code>에서 <code>f a</code>로 만든 이유를 반드시 여기서 처리해야 합니다. 펑크터는 감쌀 때는 대부분 편하게 감싸지만, 떼어낼 때는(안쪽 것을 볼 때는) 반드시 약속된 절차를 따라야 합니다. 펑크터 타입 생성자는 반드시 약속된 절차를 해야만 한다는 표시입니다.</p>
<p><code>Maybe</code> 타입을 예로 들어 보겠습니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span>  <span class="dt">Maybe</span> a  <span class="ot">=</span>  <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a <span class="co">-- 여기선 deriving (Eq, Ord)는 잠시 생략하고 볼게요 </span></span></code></pre></div>
<p>그럼 <code>Int</code>와 <code>Maybe Int</code>의 차이는</p>
<pre><code>Int : ... -2, -1, 0, 1 , 2 ...
Maybe Int : ... Just (-2), Just (-1), Just 0, Just 1, Just 2 ...| Nothing</code></pre>
<p><code>Just</code>들이야 <code>Int</code>와 일대일 대응이 되지만, <code>Int</code>에는 없던 <code>Nothing</code>이라는 값생성자를 추가하여 Sum 타입으로 만들어 두었습니다. 하스켈에서 <em>Sum 타입들은 모두 패턴 매칭으로 각 각 처리</em>해야 합니다. 어느 한 값생성자라도 놓치면 런타임에 그 형태의 값이 들어오면 오류가 나기 때문에 모든 값 생성자에 대한 처리를 해두어야 합니다. <code>Nothing</code>처리를 추가하겠다가 <code>Maybe</code>를 벗겨 낼 때 반드시 하기로 한 약속입니다.</p>
<h2 id="패턴-매칭">패턴 매칭</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> _ <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">Just</span> a) <span class="ot">=</span> <span class="dt">Just</span> (f a)</span></code></pre></div>
<p>우리가 최종 원하는 결과는 <code>b</code>가 아니라 <code>m b</code>, 즉 <code>Nothing</code>일 수도 있는 <code>Maybe b</code> 입니다. 이제 <code>m a</code>에 <code>f :: a -&gt; b</code> 함수를 적용하려면 <code>fmap f</code>라고 써주면 하스켈이 인자 타입을 보고 알아서 <code>m</code>의 <code>fmap</code>을 찾아 옵니다. <code>f :: a -&gt; b</code>, <code>g :: b -&gt; c</code>, <code>h :: c -&gt; d</code> 함수를 합성하려면 <code>fmap f . fmap g . fmap h</code>로 합성하면 됩니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>m a <span class="ot">-&gt;</span> m b</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>       m b <span class="ot">-&gt;</span> m c</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>              m c <span class="ot">-&gt;</span> m d</span></code></pre></div>
<p>같은 타입들끼리 만나고 있으니 문제가 없습니다.</p>
<p>물론 <code>m a</code>에 <code>f :: a -&gt; m b</code> 함수를 적용할 때도 <code>fmap f</code>라고 써주면 됩니다. 단, 이 때는 <em>합성에 문제가 생깁니다.</em> <code>f :: a -&gt; m b</code>, <code>g :: b -&gt; m c</code>, <code>h :: c -&gt; m d</code> 함수를 합성하려면 <code>fmap</code>만으로 해결이 되지 않습니다. <code>fmap f</code>의 결과는 <code>m b</code>가 아니라 <code>m m b</code>입니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>m a <span class="ot">-&gt;</span> m m b</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>         m b <span class="ot">-&gt;</span> m m c</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                  m c <span class="ot">-&gt;</span> m m d </span></code></pre></div>
<p>함수들을 합성할 수가 없습니다. 합성할 일이 없다면 펑크터의 <code>fmap</code>만으로 해결할 수 있지만, 합성을 해야 되면 다른 조치가 필요해졌습니다.</p>
<h2 id="갔다가-돌아와야만-한다-monad">갔다가 돌아와야만 한다 Monad</h2>
<p>아래와 같이 동작하는 함수가 있습니다.</p>
<figure>
<img src="../images/before_monad_iso.png" alt="전단사bijective" /><figcaption aria-hidden="true">전단사bijective</figcaption>
</figure>
<p><code>A</code>와 <code>B</code>는 서로 전사Surjective이며, 단사injective로 연결된 전단사 관계입니다. <code>f: A -&gt; B</code> 함수가 있고, 돌아 오는 <code>g: B -&gt; A</code> 함수(<code>f</code>의 역함수)도 있습니다. <code>A</code>를 넣어줘야 할 곳에 <code>g(B)</code>를 해서 넣어 줄수도 있고, <code>B</code>를 넣어줘야 할 곳에 <code>f(A)</code>를 해서 넣어줘도 됩니다. ※이런 관계를 Isomorphic 관계라 합니다. 서로 다른 정도를 표현하는 함수를 적용하면 바로 같은 것으로 바뀌고 있습니다.</p>
<figure>
<img src="../images/before_monad_noniso.png" alt="A에서 B로 가며 정보를 잃어버렸습니다." /><figcaption aria-hidden="true">A에서 B로 가며 정보를 잃어버렸습니다.</figcaption>
</figure>
<p>A의 1과 2는 B의 a로 연결되고, A의 3은 b로 B의 b로 연결되었습니다.</p>
<p><code>f: A -&gt; B</code> 로 갔다가 다시 <code>g: B -&gt; A</code> 으로 돌아올 수 없습니다. <code>a</code>에서 출발하면 <code>1</code>로 가야 하는지 <code>2</code>로 가야 하는지 알 수 없습니다. <code>c</code>에서 출발해도 마찬가지로 어디로 가야할지 알 수 없습니다. 이럴 때는 둘이 같은 것으로 볼 방법이 없습니다. 그런데, 만일 <code>f</code>로 <code>B</code>의 <code>a</code>에 도착할 때마다 <code>1</code>에서 왔는지, <code>2</code>에서 왔는지 기록하는 보조 함수를 만든다면, <code>g</code>를 이용해 바로 올 수는 없지만, 이 보조 함수와 결합하면 마치 전단사 함수처럼 동작할 수도 있습니다. (꼭 그정도 같게 만들어야 되는 건 아닙니다.)</p>
<p>“<code>m a</code>와 <code>a</code>는 보조 함수만큼 다르다고 말할 수 있습니다.”</p>
<h2 id="특정-작업을-하는-동안만은-같은-걸로-보기">특정 작업을 하는 동안만은 같은 걸로 보기</h2>
<p>특정 작업을 하는 동안만 다음처럼 제약을 두었다고 생각해 봅시다. ※ “특정 작업을 하는 동안”이란 표현은 함수가 연이어 합성되어 있는 모양이 실행되는 동안을 말합니다. 예) working = act1 . act2 . act3</p>
<p>“함수는 함수와 바로 연결하지 못하고, 반드시 중간에 다른 접착 함수Combinator를 두어 연결 작업을 맡긴다.”</p>
<p>그러면, 위에서 봤던 둘이 달라서 생기는 문제들을 모두 컴비네이터 함수에 떠 넘길 수 있습니다. 뭔가 특별한 것 같지만, 사실 합성 <code>(.)</code> 연산자도 아래와 같이 정의되어 있는 컴비네이터 함수입니다.</p>
<p>※ 컴비네이터 함수가 여러 함수들을 연결해서 체인을 만드는 동안, 연결할 때마다 반복해서 처리하는 작업을 컨텍스트라 부릅니다. <code>(.)</code>는 컨텍스트가 없는 컴포지션이라고 말할 수 있습니다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.)    ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">.</span>) f g <span class="ot">=</span> \x <span class="ot">-&gt;</span> f (g x)</span></code></pre></div>
<p>출력과 입력 타입이 같은 함수 합성을 할 때, 보통 <code>(.)</code>을 쓰는데, <code>a -&gt; m b</code> 형태의 합성을 할 때만 쓸 다른 함수를 정의해서 <code>(.)</code>에는 없는 컨텍스트 작업을 추가합니다.</p>
<p>다시 <code>Maybe</code>를 가져와서 예를 들겠습니다. <code>m a</code>에 <code>a -&gt; m b</code>를 적용하려면 두 가지 방법이 있을 수 있습니다.</p>
<ol type="1">
<li><code>m a</code>를 <code>a</code>로 만들고, 다른 함수가 <code>Nothing</code>에 대한 처리를 도와주든지,<br />
</li>
<li><code>a -&gt; m b</code>를 <code>m a -&gt; m b</code>로 만들든지 해야 합니다.</li>
</ol>
<h2 id="우리는-이미-fmap을-갖고-있다">우리는 이미 fmap을 갖고 있다</h2>
<p>위에서 봤던 것처럼 <code>Maybe a</code>와 <code>a</code>가 달라서 생기는 문제, 즉 추가된 <code>Nothing</code> 생성자 문제를 위해 또 함수를 만들 필요 없이, 이미 만들어져 있는 <code>fmap</code>을 가져옵니다. <code>fmap</code>이 알아서 <code>Nothing</code>에 대한 처리를 하고 <code>m a</code>에 <code>m a -&gt; m m b</code> 함수를 적용합니다. 남은 작업은 하나만 남았습니다. <code>m m b</code>를 <code>m b</code>로 만들어만 주면 또 다시 다른 <code>fmap (a -&gt; m b)</code> 모양의 함수와 연이어 합성 할 수 있습니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- join :: (Monad m) =&gt; m (m a) -&gt; m a</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 여기서는 아래로 단순화 해서 보겠습니다. </span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> m (m a) <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p><code>fmap</code>으로 나온 결과에 <code>join</code>을 적용하면 연이어 합성할 수 있게 됩니다.</p>
<figure>
<img src="../images/before_monad_bind.png" alt="join :: m (m a) -&gt; m a" /><figcaption aria-hidden="true">join :: m (m a) -&gt; m a</figcaption>
</figure>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 실제 코드는 아니고, &gt;&gt;&gt; 는 입출력을 의미합니다. </span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>m a <span class="op">&gt;&gt;&gt;</span> join (<span class="fu">fmap</span> f a) <span class="op">&gt;&gt;&gt;</span> m b</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                            m b <span class="op">&gt;&gt;&gt;</span> join (<span class="fu">fmap</span> f b) <span class="op">&gt;&gt;&gt;</span> m c</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                                                        m c <span class="op">&gt;&gt;&gt;</span> join (<span class="fu">fmap</span> f c) <span class="op">&gt;&gt;&gt;</span> m d</span></code></pre></div>
<blockquote>
<p>Q. 함수 합성은 <code>(.)</code>으로 함수와 함수를 합성해서 결과로 합성을 돌려주는데, <code>bind</code>는 값과 함수를 합성해서 값을 돌려 주고 있습니다.<br />
A. 모나드 바탕에 들어간 생각을 <code>(.)</code>과 비슷한 모양으로 구현할 수도 있는데, 편의상 하스켈 쪽에서는 bind 정의를 더 선호한다고 합니다. 하지만, 둘은 어느 한쪽이 구현되어 있으면 다른 하나를 구현할 수 있습니다. <code>(.)</code>과 비슷한 모양은 아래와 같이 정의되어 있습니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 이 연산자는 이름이 따로 있습니다. kleisli arrow라고 부릅니다.</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;=&gt;)       ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m c)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> g     <span class="ot">=</span> \x <span class="ot">-&gt;</span> f x <span class="op">&gt;&gt;=</span> g</span></code></pre></div>
</blockquote>
<h2 id="bind">Bind</h2>
<p>정리하면, 위에 <code>join</code>, <code>fmap</code>을 써서 함수 변환과 다음 연결될 함수에게 값을 줄 준비를 하는 Combinator 함수(접착 함수, 브로커 함수, 중계 역할 함수, 생태계에 자리 잡힌 번역어가 뭔지 모릅니다.) Bind <code>&gt;&gt;=</code>를 아래와 같이 정의합니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- a -&gt; m b 모양의 함수를 특별히 모나드 action이라 지칭하기도 합니다.</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>ma <span class="op">&gt;&gt;=</span> action <span class="ot">=</span> join (<span class="fu">fmap</span> action ma)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- join을 쓰지 않고 &gt;&gt;= 구현</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;&gt;=</span>) <span class="dt">Nothing</span> g  <span class="ot">=</span> <span class="dt">Nothing</span> </span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;&gt;=</span>) (<span class="dt">Just</span> x) g <span class="ot">=</span> g x</span></code></pre></div>
<blockquote>
<p>Q. Functor의 <code>fmap</code>과 <code>(&gt;&gt;=)</code> 정의가 같지 않나요? A. 혹시 Functor의 <code>fmap</code>과 같아 보인다면, 둘의 받는 함수의 타입을 확인해 보세요. <code>fmap</code> 은 <code>(a -&gt; b)</code> 함수를, <code>&gt;&gt;=</code> 는 <code>(a -&gt; m b)</code> 함수를 받습니다.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre></div>
</blockquote>
<p>이제 저 컴비네이터 함수를 이용하면</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>(m a <span class="op">&gt;&gt;=</span> act1) 결과 m b  </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                   (m b <span class="op">&gt;&gt;=</span> act2) 결과 m c  </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                                      (m c <span class="op">&gt;&gt;=</span> act3) 결과 m d  </span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- 간단히 쓰면</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>m a <span class="op">&gt;&gt;=</span> act1 <span class="op">&gt;&gt;=</span> act2 <span class="op">&gt;&gt;=</span> act3</span></code></pre></div>
<figure>
<img src="../images/before_monad_bindGraph.png" alt="목표는 m a -&gt; … -&gt; m b 입니다" /><figcaption aria-hidden="true">목표는 m a -&gt; … -&gt; m b 입니다</figcaption>
</figure>
<p>연산자 우선 순위<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<h2 id="하스켈에서-join-구현">하스켈에서 join 구현</h2>
<p><code>bind</code>와 <code>join</code>은 어느 한 쪽만 구현되어 있으면 다른 쪽을 구현할 수 있습니다. 하스켈에선 먼저 <code>bind</code>가 구현되어 있고, 이를 써서 <code>join</code>이 구현되어 있습니다. 어떻게 구현되어 있건 <code>m</code>하나를 떼어내며 약속대로 <code>Nothing</code>인지 보는 패턴 매칭을 실행합니다.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">join   ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>join x <span class="ot">=</span>  x <span class="op">&gt;&gt;=</span> <span class="fu">id</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- bind 없이 구현</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>join <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span> </span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>join (<span class="dt">Just</span> x) <span class="ot">=</span> x</span></code></pre></div>
<p>어떤 타입의 <code>id</code>가 들어가는 지 보는 방법[^2] [^2]: Q. id는 어떤 타입이 들어가는지 어떻게 알까요? A. _ (hole)을 넣어주면 GHC가 어떤 값으로 추론했는지 알 수 있습니다.</p>
<pre><code>~~~ haskell
Prelude Data.Functor&gt; join (Just 1) &gt;&gt;= _
&lt;interactive&gt;:9:19: error:
• Found hole: _ :: a0 -&gt; m b
~~~
 </code></pre>
<h2 id="결론">결론</h2>
<p>※ 딱 이렇게 정의를 내리는 곳은 없으니, 주의해서 보세요.<br />
서로 다른 <code>a</code>와 <code>m a</code>를 연결해야만 되는 <code>a -&gt; m b</code> 합성을 위해 <code>a</code>와 <code>m a</code>의 다름을 분리해서 별도로 처리하는 패턴을 모나드라 합니다. 타입만 먼저 생각해 보는 것도 도움이 됩니다. <code>a -&gt; m b</code> 함수의 입력 타입 <code>a</code>와 다른 <code>m a</code>를, bind가 <em>체이닝하는 동안은 “같은 것으로 볼 수 있게 만들고”</em> 있습니다. 다른 말로 하면, “<code>a</code>와 <code>m a</code>의 다름을 문제없이” 처리합니다. (함수 체인동안 반복되어 실행되는 바인드의 실제 코드는 <code>m b</code>와 <code>m m b</code>의 다름을 <code>join</code>이 처리합니다.) 이 글의 목적은 모나드의 완벽한 이해가 아니라, <code>a</code>와 <code>m a</code>의 다름을 해결하기 위해 모나드가 나왔다를 이해하는 겁니다.<br />
<img align="right" src="../images/before_monad_bindblock.png"></p>
<p>정확히 코드 모양으로 얘기하면 <code>a -&gt; m b</code>와 <code>b -&gt; m c</code>를 연결하는 게 아니라, <code>bind (&gt;&gt;=)</code>를 연결합니다. <code>bind (&gt;&gt;=)</code>는 그림에 비어있는 박스 부분에 적당한 걸 채워 넣으면 합성되게 구조를 만들어 둔다고 볼 수 있습니다.</p>
<h2 id="모나드가-필요함을-눈치-채는-예시">모나드가 필요함을 눈치 채는 예시</h2>
<p>숫자 두개 알파벳 하나를 받는 Parser 함수를 구현한다면, numParser 두 번, alphabetParser 한 번 연결해서 구현하면 좋겠다는 생각을 할 수 있습니다.</p>
<p>그럼, 입력 문자열 “12A”를 파싱하는 동작을 생각해 보면</p>
<ol type="1">
<li><code>numParser &gt;&gt;&gt; numParser &gt;&gt;&gt; alphabetParser</code> 이렇게 붙여서 파서를 만들면 좋겠습니다.</li>
<li><code>numParser</code>가 입력 <code>String</code>에서 숫자 하나외 매칭을 시도하고, 매칭 성공하면 <code>("1", 남은 String)</code>을 리턴합니다.</li>
<li>다음 파서 <code>numParser</code>가 받아야 할 건 <code>String</code>인데, <code>("1", 남은 String)</code>이 들어 오고 있습니다. 바로 같은 정보를 가지고 있지만 조금 다른 모양이 눈에 들어옵니다. <code>String</code>이 <code>a</code>라면 <code>("1", 남은 String)</code> 튜플은 <code>m a</code>입니다.</li>
<li>이것만 보고 바로 모나드를 떠올려도 됩니다. 파서의 타입은 <code>a -&gt; m b</code> 타입이고, 먼저 실행한 파서에서 들어오는 건 <code>m a</code>가 들어올거라 생각할 수 있습니다. 바로 모나드와 딱 맞아 떨어지는 타입 모양입니다.</li>
</ol>
<h2 id="카테고리-이론으로-가는-힌트">카테고리 이론으로 가는 힌트</h2>
<p>※ 워낙 추상적인 분야라, 여기서 고작 간단히 하는 얘기가 전체 속성이란 말은 아닙니다. 비전공자인 제 시각은 모나드를 위해서만 좁혀져서 카테고리 이론의 다른 막강함은 알지 못합니다.<br />
수학의 카테고리 이론은 무언가가 같은지 다른지 보는데 필요한 정교한 툴들을 가지고 있습니다. 둘이 얼마나 다른지, 다른 정도를 표현하는 함수들을 어떻게 정의하면 좋은지 등을 다루는데 있어 탁월하다고 합니다.</p>
<p>기본이 되는 구조(Category)를 정의해 두고,<br />
Functor 하나를 이용해 구조는 유지한 채 다른 모양으로 매핑하고,<br />
다른 Functor를 이용해 역시 구조는 유지한 채 다른 모양으로 매핑합니다.<br />
그런 후 변환된 두 대상들을 얼마나 다르다고 말할 수 있는지를 Natural Transform (:: Functor -&gt; Functor)으로 표현합니다.</p>
<p>위 방법을 포함해서 여러가지 방법으로 다른 것과 관계를 찾아, 기존 수학에 있던 개념들을 오로지 이들 관계로만 표현해서 체계를 만들어 갑니다. 이렇게 하면, 대상의 속성들에 의존하지 않게 되어 다른 곳에서도 카테고리로 정의만 되면 기존 개념들을 그대로 적용할 수 있게 된다고 합니다. 그 과정 속에서 위에서 보았던 <code>m m</code>을 <code>m</code>으로 바꾸는 것과 동일하게, <code>m m</code>과 <code>m</code>의 다름을 처리하는 경우가 나옵니다. 카테고리에서 이런 동작이 포함되어 있는 구조를 모나드라합니다. 하스켈에 있는 펑크터와 모나드가 나온 곳이라 하여, 딱 모나드까지만 가보려고 하는데 그리 순탄하지는 않습니다.</p>
<h2 id="여기-글은-독일수도-있다">여기 글은 “독”일수도 있다</h2>
<p>모나드 설명 글들은, 보통 “합성”을 시작으로 접근하는 경우가 많은데, 여기 글은 “같음”에 촛점을 두었습니다. 개인 의견은 모나드 설명을 “같음”으로 풀어나가는 것이 좀 더 이해하는데 도움이 된다고 생각합니다. 모두 <code>a -&gt; b</code> 나 <code>m a -&gt; m b</code>만 있어, 단순 컴포지션으로 해결할 수 있었다면 모나드를 볼 필요가 없었을 겁니다. <code>m a</code>와 <code>a</code>가 달라서 생기는 문제가 원인이며, 여기서 시작하는 게 맞다고 생각합니다.</p>
<p>카테고리 이론은 들여다 볼수록 하스켈과 정말 많이 닮았다는 생각이 들긴 하는데, 글로 정리할 정도로 이해하기가 쉽지 않네요. 국내에도 “프로그래밍 언어”등을 전공으로 하는 분들이 많을텐데, 가볍게 볼 수 있는 글들을 많이 남겨 주면 좋겠습니다.</p>
<p>블로그 글은 출판된 글과 다릅니다. 가장 큰 차이는 정교함, 정확성이란 생각이 듭니다. 출판 글들은 좀 더 자본을 들여 여러 사람들의 감수 절차도 밟고 정확한 내용을 출판하게 되지만(아! 물론 가장 중요한 요소는 저자겠지요.), 블로그 글은 글쓴이가 잘 못 이해하거나 해도, 감수라는 절차들이 따로 없어 틀릴 확률이 높아 주의해서 봐야 합니다. 저도 반복해서 검증하기 위해 노력하긴 하지만, 모두 정확하다는 확신을 갖고 올리는 글들은 아닙니다. 읽는이들이 감수자가 되어서 읽어야 합니다. 정말 안좋은 경우도 충분히 생길 수 있을거라 봅니다. 처음 접하는 개념들을 틀린 설명으로 시작한다면 확실히 독이 될 수도 있습니다. 다른 곳에 있는 내용들을 번역하거나 옮기는 글들이 많지 않아, 다시 말해 정확히 근거가 있지 않은 경우가 있어 여기 글들은 독이 될 수도 있습니다. 항상 경계하며 보시고 다른 분들과 의견을 나누거나 생태계 공식 텍스트들을 통해 검증하며 보시기 바랍니다.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>중위infix 연산자 <code>(&gt;&gt;=)</code>의 우선 순위 지정 덕분에 간단하게 쓸 수 있습니다.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">1</span>  <span class="op">&gt;&gt;</span>, <span class="op">&gt;&gt;=</span></span></code></pre></div>
<p>바인드의 우선 순위는 위와 같이 정의되어 있습니다. <code>infix</code>에 붙어 있는 <code>l</code>이 왼쪽 우선이란 뜻입니다.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <div id="footer">
            © 2021 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
