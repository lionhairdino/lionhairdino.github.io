<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - 모나드, 같음 - m (m a)와 m a는 얼마나 다를까?</title>

        <meta name="description" content="m (m a)와 m a를 같게 볼 수 있는 방법에 촛점을 둔 간략한 모나드 설명입니다." />
        <meta property="og:description" content="m (m a)와 m a를 같게 볼 수 있는 방법에 촛점을 둔 간략한 모나드 설명입니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="모나드, 같음 - m (m a)와 m a는 얼마나 다를까?" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2022-03-25-beforeMonad.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/1mm.png" />

      <meta name="keywords" content="Monad, 모나드, Functor, 펑크터, 펑터, Maybe, 같음">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
    </head>
    <body>
        <div id="header" style>
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../" style>lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px">사이트내 검색</div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 주의! 틀린 내용이 있을 수 있습니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않습니다.
            </div>
        </div>
        <div id="content">
            <h1>모나드, 같음 - m (m a)와 m a는 얼마나 다를까?</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on March 25, 2022
    
</div>

<p>모나드로 가는 도중 생각해 보면 도움이 될 것 같은 내용들을 정리했습니다.<br />
처음 모나드를 접하시는 분들보다는 한 번쯤 모나드 설명을 봤던 분들에게 적합한 글일 것 같습니다.<br />
<code>Functor</code>와 <code>Maybe</code> 동작에 대한 지식이 있으면 도움이 됩니다.</p>
<p>주의 )<br />
모나드의 독특함 때문에 수많은 모나드 튜토리얼들이 올라오는데, 잘못된 이해로 남긴 글을 <a href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">부리토 Burrito</a>라고 부르는 것 같습니다. 이 글도 부리토 중에 하나일 수 있습니다. 그렇게 되지 않기 위해 노력하지만 모든게 확실한 내용이라 장담할 수 없습니다. 여기 글에서 무언가를 알게 된다면, 꼭 다른 분들과 상의해서 검증하시기 바랍니다.</p>
<blockquote>
<p><strong>요약</strong><br />
<strong>Effect를 합성할 수 있는 <code>return</code>, <code>join</code>이 있어, 펑크터 <code>m</code>을 여러번 적용한 <code>m (m (m ...))</code>을 <code>m</code>을 한 번 적용한 것으로 표현 가능한 구조를 모나드라 합니다. <code>a -&gt; m b</code> 타입의 함수를 합성할 때 <code>m</code>부분을 합성하기 위해 모나드 구조로 만들어 해결합니다.</strong></p>
</blockquote>
<p>위 문장이 이해가 되시는 분은 이 글을 보시지 않아도 됩니다.</p>
<ol type="1">
<li><a href="#펑크터로-변환한-타입과-변환-전-타입의-관계">펑크터로 변환한 타입과 변환 전 타입의 관계</a></li>
<li><a href="#펑크터-타입이-같이-있는-함수">펑크터 타입이 같이 있는 함수</a></li>
<li><a href="#서로-다른-정도를-표현하는-방법-함수">서로 다른 정도를 표현하는 방법: 함수</a></li>
<li><a href="#역변환inverse이-없는데-어떻게-같게-볼-수-있을까">역변환Inverse이 없는데, 어떻게 같게 볼 수 있을까?</a></li>
<li><a href="#m-a에서-a로-돌아오기"><code>m a</code>에서 <code>a</code>로 돌아오기?</a>
<ol type="1">
<li><a href="#maybe-펑크터가-추가한-구조effect"><code>Maybe</code> 펑크터가 추가한 구조effect</a></li>
<li><a href="#패턴-매칭">패턴 매칭</a></li>
</ol></li>
<li><a href="#합성composition--특정-작업을-하는-동안만은-같은-걸로-보기">합성Composition : 특정 작업을 하는 동안만은 같은 걸로 보기</a></li>
<li><a href="#이미-fmap을-갖고-있다">이미 <code>fmap</code>을 갖고 있다</a></li>
<li><a href="#join"><code>join</code></a></li>
<li><a href="#m-a와-a가-다른-문제를-m-a---a-아니고-왜-m-m-a---m-a를-볼까">m a와 a가 다른 문제를 m a -&gt; a 아니고, 왜 m (m a) -&gt; m a를 볼까?</a></li>
<li><a href="#bind-">Bind <code>(&gt;&gt;=)</code></a></li>
<li><a href="#하스켈에서-join-구현">하스켈에서 <code>join</code> 구현</a></li>
<li><a href="#결론">결론</a></li>
<li><a href="#모나드가-필요함을-눈치-채는-예시">모나드가 필요함을 눈치 채는 예시</a></li>
<li><a href="#카테고리-이론으로-가는-힌트">카테고리 이론으로 가는 힌트</a></li>
<li><a href="#도움을-주신-분들">도움을 주신 분들</a></li>
<li><a href="#여기-글은-독일수도-있다">여기 글은 “독”일수도 있다</a></li>
<li><a href="#appendix">Appendix</a>
<ol type="1">
<li><a href="#effect-합성-예시">effect 합성 예시</a>
<ol type="1">
<li><a href="#state">State</a></li>
<li><a href="#writer">Writer</a></li>
<li><a href="#reader">Reader</a></li>
</ol></li>
<li><a href="#그럼-join의-동작은-마음대로-만들어도-되나">그럼 join의 동작은 마음대로 만들어도 되나?</a></li>
</ol></li>
</ol>
<p>하스켈에서 함수의 합성composition은 정말 중요합니다. 시작과 끝이라고 봐도 될 정도로 핵심 근간을 이루는 개념입니다. 모나드는 특정 타입의 함수를 연이어 합성하려면 필요하게 되는 구조입니다. 대부분 모나드 자료는 합성에서 설명을 풀어 나갑니다. 하지만, 여기서는 “합성” 자체보다, 합성을 하기 위해 필요한 “같음”에 주목했습니다.</p>
<p>합성은 첫 함수의 결과값과 이어지는 두 번째 함수의 입력값이 서로 같아야 한다는 생각에서 시작했습니다. 아니면, 적어도 같게 만들 수 있는 함수가 있다면, 복잡한 테크닉 없이 그냥 이 함수를 적용하기만 하면 된다고 생각했습니다.</p>
<p>이 글의 결론부터 말하면, 컴비네이터를 이용한 합성은 접점의 타입이 꼭 같아야 할 필요가 없습니다. 각 함수들의 결과를 잃어버리지 않을 수만 있다면 합성이 가능합니다.</p>
<br />
<center>
<font size="7em" style="font-style:italic; font-weight: bolder; line-height: 1.2em">“m a와 a는 얼마나 다를까?”</font><br />이 글의 부제는 m (m a)와 m a는 얼마나 다를까입니다.
</center>
<p><br /></p>
<h2 id="펑크터로-변환한-타입과-변환-전-타입의-관계">펑크터로 변환한 타입과 변환 전 타입의 관계</h2>
<p>몸무게를 표현하기 위해 <code>Int</code> 타입 값이 필요한데, 몸무게가 변할 때마다 이유를 기록해 두고 싶습니다.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">HasLog</span> a <span class="ot">=</span> <span class="dt">HasLog</span> a [<span class="dt">String</span>]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Weight</span> <span class="ot">=</span> <span class="dt">HasLog</span> <span class="dt">Int</span></span></code></pre></div>
<p>이럴 때 <code>Int</code>에서 <code>Weight</code>로 “변환Transform” 되었다고 말합니다. <code>Int</code>용 <code>(+)</code>, <code>(-)</code>는 이미 있으니 이 함수를 그대로 써서 새로운 타입에 적용하고 싶습니다. <code>(+)</code>, <code>(-)</code>를 다시 정의하지 않고, 기존 함수들을 사용할 때, 바로 사용하지 않고 중간에 끼어들어 <code>Weight</code>에서 <code>Int</code>를 꺼내주는 브로커 함수를 만들면 됩니다. (이 함수를 <code>fmap</code>이라 부릅니다.) <code>fmap</code> 함수를 <code>Weight</code> 타입에서 쓸 수 있도록 추가해 주는데, 이럴 때 “펑크터 구조를 추가했다 또는 변환했다”라고 합니다.</p>
<p>이런식으로 하스켈에서 프로그램을 작성하다 보면, 수많은 “타입을 갑싼 타입”들이 생기게 되는데, 이들은 기존 데이터와 아주 다른 것이 아닙니다. 위 몸무게의 예는 <code>Int</code>가 가지는 속성은 똑같이 가지고 있고, 추가적으로 <code>[String]</code>을 갖고 있다고 봅니다. <code>Int</code>를 처리하던 함수들은 모두 그대로 쓰고 싶습니다. 그럴 때 <code>fmap</code>을 추가한 타입들을 펑크터라고 부릅니다. 여기 글에서 주목하는 부분은 바로 몸무게 <code>Weight</code>와 <code>Int</code>의 <em>다른(닮은) 정도</em>입니다.</p>
<p>“<code>Weight</code>와 <code>Int</code>는 다르지만, <code>Int</code> 성질은 둘 다 가지고 있는 <em>닮은 타입</em>이다.”</p>
<p>펑크터는 <code>a</code> 타입과 “닮은” <code>f a</code> 타입을 만들어 냅니다.<br />
모나드는 아무 타입 둘을 다루는 게 아니라, 닮은 타입 둘에 관한 구조입니다.</p>
<h2 id="펑크터-타입이-같이-있는-함수">펑크터 타입이 같이 있는 함수</h2>
<p>이렇게 펑크터를 정의하면 당연히 펑크터로 변환된 타입들을 처리하는 함수들이 필요합니다. 펑크터가 적용되어 있는 타입과 관련된 함수는 3가지 형태가 있을 수 있습니다. (하스켈은 unary 함수만 있으니, 그 것만 보면 됩니다.) 하스켈 함수들은 합성이 가능해야 효용성이 높아집니다. 각 형태들의 합성을 생각해 보면</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>m a <span class="ot">-&gt;</span> m b</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>m a <span class="ot">-&gt;</span> b</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>우선 첫 번째는 입력과 출력 모두 같은 펑크터 적용이 되어 있으니 <code>a -&gt; b</code> , <code>b -&gt; c</code> 함수를 합성하듯 간단히 함수 컴포지션 <code>(.)</code>으로 연결할 수 있습니다.</p>
<figure>
<img src="../images/before_monad_mbmb.png" alt="mb와 mb가 만난다" /><figcaption aria-hidden="true">mb와 mb가 만난다</figcaption>
</figure>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(m a <span class="ot">-&gt;</span> m b) <span class="op">.</span> (m b <span class="ot">-&gt;</span> m c)</span></code></pre></div>
<p>두 번째는 입 출력이 다른 펑크터 타입이라 함수 컴포지션으로 해결할 수 없습니다. 이건 모나드가 익숙해진 후 <a href="../posts/2021-05-06-comonad.html">코모나드</a> 글에서 보도록 하겠습니다.</p>
<p>마지막 세 번째도 입력과 출력이 다른데 어떻게 연결하면 좋을까요?</p>
<figure>
<img src="../images/before_monad_mbb.png" alt="mb와 b가 만난다" /><figcaption aria-hidden="true">mb와 b가 만난다</figcaption>
</figure>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(a <span class="ot">-&gt;</span> m b) <span class="op">???</span> (b <span class="ot">-&gt;</span> m c)</span></code></pre></div>
<p><code>m b</code>와 <code>b</code> 둘이 <em>같은 걸</em>로 볼 수만 있다면, 아무 문제 없을텐데요.</p>
<p>※ 왜 <code>a -&gt; m b</code> 타입이 중요한지 <a href="../posts/2021-05-18-stateless.html">상태 “개념”은 함수형에도 있다</a> 글을 참고하시면 도움이 됩니다.</p>
<blockquote>
<p>Q. <code>m a -&gt; m b</code> 도 <code>a</code>와 <code>b</code>가 다르니 다른 타입 아닌가요?<br />
A. 여기서 같다 다르다의 관심사는 한 함수 내에서가 아니라, 다음 함수와 합성할 때 접점에서 만나게 되는 타입을 말합니다. <code>m a -&gt; m b</code>는 <code>m b -&gt; m c</code> 함수를 <code>(.)</code>으로 연결할 때 <code>m b</code>와 <code>m b</code>가 만납니다.</p>
</blockquote>
<h2 id="서로-다른-정도를-표현하는-방법-함수">서로 다른 정도를 표현하는 방법: 함수</h2>
<p><code>3</code>과 <code>5</code>가 얼마나 다를까요?</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">`3`</span>은 <span class="ot">`0`</span>에서 <span class="ot">`3`</span>만큼 떨어져 있고, (<span class="op">+</span><span class="dv">3</span>)   </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">`5`</span>는 <span class="ot">`0`</span>에서 <span class="ot">`5`</span>만큼 떨어져 있다<span class="op">.</span> (<span class="op">+</span><span class="dv">5</span>)</span></code></pre></div>
<p>기준에서 부터 측정된 값들을 서로 계산해서 둘의 다른 정도를 구합니다.<br />
“(5 - 3) = 2, 또는 (3 - 5) = -2”<br />
“3에서 5는 2만큼 떨어져 있다.”</p>
<p>둘 중 하나를 기준으로 잡을 수도 있습니다. 기준을 만들고 특정 연산(함수)을 이용해서 대상들을 비교하면, 같은지 다른지 좀 더 모호하지 않게 얘기할 수 있게 됩니다.</p>
<figure>
<img src="../images/1mm.png" alt="정확하게 얘기하기" /><figcaption aria-hidden="true">정확하게 얘기하기</figcaption>
</figure>
<p><code>a</code> 와 <code>m a</code>는 다릅니다. “얼마나” 다를까요?<br />
<code>m a</code>를 기준으로 잡고, <code>a</code>가 얼마나 다른지 나타내는 함수가 있으면, <em>함수만큼 다르다</em>고 말할 수 있습니다. (기준을 <code>a</code>가 아닌 <code>m a</code>로 잡은 이유는, 우리가 필요로 하는 정보를 모두 갖고 있는 타입은 <code>m a</code>인데, 함수들이 <code>a</code> 타입을 받아 문제가 생깁니다. <code>a -&gt; m b</code> 함수를 거치고 나서 원하는 결과는 <code>b</code>가 아니라 <code>m b</code>입니다.)</p>
<h2 id="역변환inverse이-없는데-어떻게-같게-볼-수-있을까">역변환Inverse이 없는데, 어떻게 같게 볼 수 있을까?</h2>
<p>아래와 같이 동작하는 함수가 있습니다.</p>
<figure>
<img src="../images/before_monad_iso.png" alt="전단사bijective" /><figcaption aria-hidden="true">전단사bijective</figcaption>
</figure>
<p><code>A</code>와 <code>B</code>는 서로 전사Surjective이며, 단사injective로 연결된 전단사bijective 관계입니다. <code>f: A -&gt; B</code> 함수가 있고, 돌아 오는 <code>g: B -&gt; A</code> 함수(<code>f</code>의 역함수)도 있습니다. <code>A</code>를 넣어줘야 할 곳에 <code>g(B의 원소)</code>를 해서 넣어 줄수도 있고, <code>B</code>를 넣어줘야 할 곳에 <code>f(A의 원소)</code>를 해서 넣어줘도 됩니다. ※ 이런 관계를 Isomorphic 관계라 합니다. 서로 다른 정도를 표현하는 함수를 적용하면 바로 같은 것으로 바뀌고 있습니다.</p>
<figure>
<img src="../images/before_monad_noniso.png" alt="A에서 B로 가며 정보를 잃어버렸습니다." /><figcaption aria-hidden="true">A에서 B로 가며 정보를 잃어버렸습니다.</figcaption>
</figure>
<p>A의 1과 2는 B의 a로 연결되고,<br />
A의 3은 B의 b로 연결되었습니다.</p>
<p><code>f: A -&gt; B</code> 로 갔다가 다시 <code>g: B -&gt; A</code> 으로 돌아올 수 없습니다. <code>a</code>에서 출발하면 <code>1</code>로 가야 하는지 <code>2</code>로 가야 하는지 알 수 없습니다. <code>c</code>에서 출발해도 마찬가지로 어디로 가야할지 알 수 없습니다. 이럴 때는 아무 조치 없이는 둘이 같은 것으로 볼 방법이 없습니다. 하지만, 다음 방법을 통해서 마치 돌아갈 수 있는 것 처럼 할 수 있습니다. 예를 들어, 만일 <code>f</code>로 <code>B</code>의 <code>a</code>에 도착할 때마다 <code>1</code>에서 왔는지, <code>2</code>에서 왔는지 기록하는 보조 함수를 만들고 <code>c</code>가 어떤 수와 연결만 되면 되는 상황일 경우, <code>g</code>를 이용해 바로 올 수는 없지만, 이 보조 함수 만들기에 따라서 마치 전단사 함수처럼 동작할 수도 있습니다. (꼭 전단사로 만들어야 되는 건 아닙니다. 때에 따라 꼭 함수 관계가 아니고, 관계만 있는 걸 아는 것으로 충분할 때도 있습니다.) 어쨌든, 이럴 때는</p>
<p>“(현재 필요한 정도에서는)<code>A</code>는 <code>B</code>와 (g + 보조 함수)를 적용하면 문제 없을 만큼 다르다” 고 말할 수 있습니다.</p>
<p>하지만 <em>항상 보조 함수를 만들 수 있는 건 아닙니다.</em></p>
<h2 id="m-a에서-a로-돌아오기"><code>m a</code>에서 <code>a</code>로 돌아오기?</h2>
<h3 id="maybe-펑크터가-추가한-구조effect"><code>Maybe</code> 펑크터가 추가한 구조effect</h3>
<p>※ 펑크터를 말할 땐 타입 생성자를 <code>f</code>, 모나드를 말할 때는 <code>m</code>으로 표기합니다.<br />
※ <code>m a</code>에서 <code>a</code>로 돌아갈 때 가지고 있을 수 없는 정보를 effect라 합니다. (보통 <code>a</code>에서 <code>m a</code>로 가며 생기는 것들로 정의를 하는데, 여기서는 거꾸로 보는게 이해에 도움이 됩니다.)</p>
<p>펑크터는 오브젝트들만 매핑하는 게 아니라, 모피즘도 매핑해야 합니다. 오브젝트는 타입 생성자로 감싸서 변환하고, 모피즘은 <code>fmap</code>이란 함수를 통해서 변환합니다.</p>
<p><code>f a</code>값에 적용해야 될 함수가 <code>a -&gt; b</code>이면 <code>f a</code>와 <code>a</code>가 달라 적용할 수 없습니다. 마법은 없습니다. <code>f a</code>를 <code>a</code>로 바꾸든, <code>a -&gt; b</code>를 <code>f a -&gt; b</code> 또는 <code>f a -&gt; f b</code>로 바꾸든 해야 합니다. 필요한 정보 구조(effect)를 모두 가지고 있는 타입은 <code>f b</code>이니, 이 정보들을 잃어버리지 않기 위해 <code>f a -&gt; f b</code> 타입으로 만듭니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> <span class="dt">Functor</span> <span class="dt">F</span> <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- tip: 여기서는 (a -&gt; b) -&gt; (f a -&gt; f b) 보다는</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- (a -&gt; b) 와 f a 를 받아 f b를 돌려주는 함수로 읽는게 더 직관적으로 보입니다.</span></span></code></pre></div>
<p><code>Functor</code> 클래스의 <code>fmap</code>을 구현할 때는 단순히 타입만 변경하는게 아닙니다. <code>f</code>를 <em>잠시</em> 벗겨 낼때는, <code>a</code>에서 <code>f a</code>로 만든 이유effect를 반드시 여기서 처리해야 합니다. 펑크터는 감쌀 때는 대부분 편하게 감싸지만, 안쪽 것을 볼 때는 반드시 약속된 절차를 따라야 합니다. 펑크터 타입 생성자는 반드시 약속된 절차를 해야만 한다는 표시입니다.</p>
<p><code>Maybe</code> 타입을 예로 들어 보겠습니다.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span>  <span class="dt">Maybe</span> a  <span class="ot">=</span>  <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a <span class="co">-- 여기선 deriving (Eq, Ord)는 생략하고 볼게요 </span></span></code></pre></div>
<p>그럼 <code>Int</code>와 <code>Maybe Int</code>가 가진 오브젝트의 차이는</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Int</span> <span class="op">:</span> <span class="op">...</span> <span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span> , <span class="dv">2</span> <span class="op">...</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Maybe</span> <span class="dt">Int</span> <span class="op">:</span> <span class="op">...</span> <span class="dt">Just</span> (<span class="op">-</span><span class="dv">2</span>), <span class="dt">Just</span> (<span class="op">-</span><span class="dv">1</span>), <span class="dt">Just</span> <span class="dv">0</span>, <span class="dt">Just</span> <span class="dv">1</span>, <span class="dt">Just</span> <span class="dv">2</span> <span class="op">...|</span> <span class="dt">Nothing</span></span></code></pre></div>
<p><code>Just</code>들이야 <code>Int</code>와 일대일 대응이 되지만, <code>Int</code>에는 없던 <code>Nothing</code>이라는 값생성자를 추가하여 Sum 타입으로 만들어 두었습니다. 하스켈에서 <em>Sum 타입들은 모두 패턴 매칭으로 각 각 처리</em>해야 합니다. 어느 한 값생성자라도 놓치면 런타임에 그 형태의 값이 들어오면 오류가 나기 때문에 모든 값 생성자에 대한 처리를 해두어야 합니다. <code>Nothing</code>처리를 추가하겠다가 <code>Maybe</code>를 벗겨 낼 때 반드시 하기로 한 약속입니다. 이 약속이 <code>Maybe</code>가 가진 effect입니다.</p>
<h3 id="패턴-매칭">패턴 매칭</h3>
<p><code>a -&gt; b</code> 함수는 어차피 effect에 적용하기 위한 함수가 아닙니다. effect는 잠시 다른데로 옮겨 두고, <code>a -&gt; b</code>를 적용할 수 있는 것에만 적용하고, 다시 effect를 합치면 됩니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> _    <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> func (<span class="dt">Just</span> a) <span class="ot">=</span> <span class="dt">Just</span> (func a)</span></code></pre></div>
<p>눈여겨 볼 부분은 함수를 적용한 후의 결과 타입입니다. effect를 버리지 않으려면(<code>Nothing</code>을 잃어버리지 않으려면), <code>b</code>가 아니라 <code>Nothing</code>일 수도 있는 <code>Maybe b</code> 를 리턴해야 됩니다. <code>a -&gt; b</code> 함수를 적용한 후 다시 effect가 있는 <code>f a</code>로 만들고 있습니다.</p>
<p>이제 <code>Maybe a</code>에 <code>func :: a -&gt; b</code> 함수를 적용하려면 <code>fmap func</code>라고 써주면 하스켈이 인자 타입을 보고 알아서 <code>Maybe</code>의 <code>fmap</code>을 찾아와 적용해서 결과값 <code>f b</code>를 리턴하는 함수로 만듭니다. <code>func1 :: a -&gt; b</code>, <code>func2 :: b -&gt; c</code>, <code>func3 :: c -&gt; d</code> 함수를 합성하려면 <code>fmap func1 . fmap func2 . fmap func3</code>으로 합성하면 됩니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>f a <span class="ot">-&gt;</span> f b</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>       f b <span class="ot">-&gt;</span> f c</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>              f c <span class="ot">-&gt;</span> f d</span></code></pre></div>
<p>같은 타입들끼리 만나고 있으니 문제가 없습니다. <code>f a</code>, <code>f b</code>, <code>f c</code> 모두 <code>f</code>를 가지고 있는, 즉 effect를 잃어버리지 않고 갖고 있는 타입들입니다.</p>
<p>여기서 <code>fmap</code>의 내부 동작을 보면 <code>f a</code>에서 <code>a</code>를 꺼내온 것으로 오해할 수 있습니다. 하지만 <code>fmap</code>의 결과는 <code>f b</code>입니다. 내부에서 일시적으로 effect를 분리해서 <code>a</code>를 대상으로 작업하지만, 가지고 있던 effect를 버리지 않는 한 최종 <code>a</code>만 단독으로 받을 수 없습니다.</p>
<p>만일 <code>a -&gt; b</code>의 입력과 <code>f a</code>가 달라 <code>f a</code>를 <code>a</code> 로 만든 다음 <code>a -&gt; b</code> 를 적용하면 결과값은 effect를 잃어버린 <code>b</code>입니다. 결과로 <code>b</code>를 받는다면 effect가 모두 사라진 상태니 <code>f b</code>와 다릅니다. effect가 살아 있는 그냥 <code>b</code>는 있을 수 없습니다. effect가 사라지지 않게 보조 함수가 도와주게 하더라도, 마지막 결과가 effect를 담을 곳이 없으면 어찌할 방법이 없습니다. 결론은, 둘은 같게 볼 방법이 없습니다. 그렇다면 <code>a -&gt; m b</code>와 <code>b -&gt; m c</code>에서 <code>m b</code>를 <code>b</code>로 만들 수 없으니 를 합성할 방법이 없는 것 아닐까요?</p>
<p>※ 같게 볼 수 있는 함수가 아니라 아예 <code>inverseM :: m a -&gt; a</code> 가 존재한다면?<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<br />
<center>
<font size="7em" style="font-style:italic; font-weight: bolder; line-height: 1.2em">“m a와 a는 같게 볼 방법이 없다.”</font>
</center>
<p><br /></p>
<p>지금부터는 <strong>모나드</strong>로 넘어가니 <code>f</code>를 <code>m</code>이라 표기하겠습니다.</p>
<p>물론 <code>m a</code>에 <code>func :: a -&gt; m b</code> 함수를 적용할 때도 <code>fmap func</code>라고 써주면 됩니다. 단, 이 때는 <em>합성에 문제가 생깁니다.</em> <code>func1 :: a -&gt; m b</code>, <code>func2 :: b -&gt; m c</code>, <code>func3 :: c -&gt; m d</code> 함수를 합성하려면 <code>fmap</code>만으로 해결이 되지 않습니다. <code>fmap f</code>의 결과는 <code>m b</code>가 아니라 <code>m (m b)</code>입니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>m a <span class="ot">-&gt;</span> m (m b)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>          m b <span class="ot">-&gt;</span> m (m c)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>                    m c <span class="ot">-&gt;</span> m (m d)</span></code></pre></div>
<p>함수들을 합성할 수가 없습니다. 합성할 일이 없다면 펑크터의 <code>fmap</code>만으로 해결할 수 있지만, 합성을 해야 되면 다른 조치가 필요해졌습니다.</p>
<h2 id="합성composition-특정-작업을-하는-동안만은-같은-걸로-보기">합성Composition : 특정 작업을 하는 동안만은 같은 걸로 보기</h2>
<p>특정 작업을 하는 동안만 다음처럼 제약을 두었다고 생각해 봅시다. ※ “특정 작업을 하는 동안”이란 표현은 함수가 연이어 합성되어 있는 모양이 실행되는 동안을 말합니다. 예) working = act1 . act2 . act3</p>
<p>“함수는 함수와 바로 연결하지 못하고, 반드시 중간에 다른 접착 함수Combinator를 두어 연결 작업을 맡긴다.”</p>
<p>그러면, 위에서 봤던 둘이 달라서 생기는 문제들을 모두 컴비네이터 함수에 떠 넘길 수 있습니다. 뭔가 특별한 것 같지만, 사실 합성 <code>(.)</code> 연산자도 아래와 같이 정의되어 있는 컴비네이터 함수입니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.)    ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">.</span>) f g <span class="ot">=</span> \x <span class="ot">-&gt;</span> f (g x)</span></code></pre></div>
<p>컴비네이터 함수가 여러 함수들을 연결해서 체인을 만드는 동안, 연결할 때마다 반복해서 처리하는 작업을 컨텍스트라 부릅니다. <code>(.)</code>은 컨텍스트가 없는 컴포지션이라고 말할 수 있습니다.</p>
<p>출력과 입력 타입이 같은 함수 합성을 할 때, 보통 <code>(.)</code>을 쓰는데, <code>a -&gt; m b</code> 형태의 합성을 할 때만 쓸 다른 함수를 정의해서 <code>(.)</code>에는 없는 컨텍스트 작업을 추가합니다.</p>
<p>다시 <code>Maybe</code>를 가져와서 예를 들겠습니다. <code>m a</code>에 <code>a -&gt; m b</code>를 적용하려면 두 가지 방법이 있을 수 있습니다.</p>
<ol type="1">
<li><code>m a</code>를 <code>a</code>로 만들고, 다른 함수가 <code>Nothing</code>에 대한 처리를 도와주든지,<br />
</li>
<li><code>a -&gt; m b</code>를 <code>m a -&gt; m b</code>로 만들든지 해야 합니다.</li>
</ol>
<h2 id="이미-fmap을-갖고-있다">이미 <code>fmap</code>을 갖고 있다</h2>
<p>※ <code>fmap</code> “만” 갖고 있다고 해야 맞을 것 같습니다. <code>fmap</code>은 오브젝트만 변환하는게 아닌 모피즘도 변환합니다. 예를 들어 <code>a -&gt; m b</code>를 펑크터 <code>m</code>으로 한 번 더 변환하면 <code>m a -&gt; m (m b)</code>가 되는 걸 알고 있습니다. <code>m a</code>가 가지고 있던 effect를 잃어버리지 않으려면, <code>a -&gt; m b</code>에 <code>m a</code>를 넣기 위해, 일단 <code>m a -&gt; m (m b)</code>로 만드는 수밖에 없습니다.</p>
<p>위에서 봤던 것처럼 <code>Maybe a</code>와 <code>a</code>가 달라서 생기는 문제, 즉 추가된 <code>Nothing</code> 생성자 문제를 위해 또 함수를 만들 필요 없이, 이미 만들어져 있는 <code>fmap</code>을 가져옵니다. <code>fmap</code>의 내부를 들여다 보면<br />
* <code>a -&gt; m b</code> 함수와 <code>m a</code>를 받아,<br />
* <code>m a</code>에서 <code>m</code>을 잠시 떼어내며, <code>m a</code>가 가지고 있던 effect를 따로 두고 (이걸 <strong>effect1</strong>이라 이름 붙이겠습니다.)<br />
* <code>a</code>에 <code>a -&gt; m b</code> 함수를 적용합니다. 그럼 결과 <code>m b</code>는 새로운 effect를 가지고 있게 됩니다. 이걸 <strong>effect2</strong>라 이름 붙이겠습니다.<br />
* 남은 작업은 하나만 남았습니다. <strong>effect1</strong>과 <strong>effect2</strong>를 모두 잃어버리지 않고 다시 <code>m b</code>로 만들 수만 있다면, 또 다시 다른 <code>b -&gt; m c</code> 모양의 함수와 연이어 합성 할 수 있게 됩니다.</p>
<blockquote>
<p>Q. 만일 1번 방법 <code>m a -&gt; a</code> 으로 해결한다면 <code>m (m b)</code>가 나오지 않아도 되는 것 아닐까요?<br />
A. 컴비네이터 안에서 <code>m a</code>에 있던 <strong>effect1</strong>을 떼어낸 후 <code>a</code>에 <code>a -&gt; m b</code>를 적용하면 또 하나의 <strong>effect2</strong>가 생기는 건 마찬가지입니다. <code>fmap</code>을 이용해서 <code>a -&gt; m b</code> 함수를 <code>m a -&gt; m (m b)</code>로 변환한 것과 표현만 다를 뿐이지 같은 절차입니다. (<code>fmap</code> 내부에서 똑 같은 방법으로 진행됩니다.) 결론은 effect 두 개를 모두 살리려면 <code>m (m a) -&gt; m a</code>가 반드시 필요합니다.</p>
</blockquote>
<br />
<center>
<font size="7em" style="font-style:italic; font-weight: bolder; line-height: 1.2em">“m (m a)와 m a는 얼마나 다를까?”</font>
</center>
<p><br /></p>
<h2 id="join"><code>join</code></h2>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- join :: (Monad m) =&gt; m (m a) -&gt; m a</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 여기서는 아래로 단순화 해서 보겠습니다. </span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> m (m a) <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>위와 같은 함수 <code>join</code>이 있다면, <code>fmap</code>으로 나온 결과에 적용하여 다시 <code>m a</code>가 되므로 연이어 합성할 수 있게 됩니다. <code>join</code>이 하는 일은 단순히 <code>m</code> 하나를 떼어내는 것이 아닙니다. <code>join</code>은 <code>m a</code>가 되며 생긴 <strong>effect1</strong>과 <code>m (m a)</code>가 되며 생긴 <strong>effect2</strong> 모두를 잃어버리지 않아야 합니다. 이를 위한 해결책이 바로 effect composition입니다. <strong>effect1</strong>과 <strong>effect2</strong>를 합쳐 <strong>하나의 effect</strong>로 만들어 <code>m a</code>에 다시 담아 둘 수 있으면 됩니다. 그게 불가능하면 모나드로 만들 수 없습니다.</p>
<p>※ effect를 합성할 때 effect의 id의 역할을 할 수 있게 만들어 주는 모나드의 <code>return</code>도 중요한 역할이지만, 반짝이는 센스가 들어가 있는 부분은 바로 여기 <code>join</code>입니다.</p>
<br />
<center>
<font size="7em" style="font-style:italic; font-weight: bolder; line-height: 1.2em"> 두 번의 effect를 하나의 effect에 담기</font>
</center>
<p><br /></p>
<p><code>join</code>이 effect를 잃어버리지 않게 합성해서 <code>fmap</code>의 결과를 다시 <code>m a</code> 형태로 만들어 주면 드디어 아래와 같이 컴포지션이 가능해집니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 실제 코드는 아니고, &gt;&gt;&gt; 는 입출력을 의미합니다. </span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>m a <span class="op">&gt;&gt;&gt;</span> join (<span class="fu">fmap</span> f a) <span class="op">&gt;&gt;&gt;</span> m b</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                            m b <span class="op">&gt;&gt;&gt;</span> join (<span class="fu">fmap</span> g b) <span class="op">&gt;&gt;&gt;</span> m c</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>                                                        m c <span class="op">&gt;&gt;&gt;</span> join (<span class="fu">fmap</span> h c) <span class="op">&gt;&gt;&gt;</span> m d</span></code></pre></div>
<h2 id="m-a와-a가-다른-문제를-m-a---a-아니고-왜-m-m-a---m-a를-볼까">m a와 a가 다른 문제를 m a -&gt; a 아니고, 왜 m (m a) -&gt; m a를 볼까?</h2>
<p><strong><code>a -&gt; m b</code>와 <code>b -&gt; m c</code>를 합성하면 effect는 <code>m b</code>, <code>m c</code> 두 번 생깁니다. <code>m b</code>와 <code>b</code>가 달라서 생기는 문제처럼 보이지만, 한 걸음 뒤에서 넓게 보면 <em>사실 우리가 풀어야 될 문제는, 둘을 같게 보는게 아니라 두 번의 effect가 있는 걸, effect 하나와 같게 만드는 문제</em>입니다.</strong></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>[a <span class="ot">-&gt;</span> m b]  <span class="op">.</span>  [b <span class="ot">-&gt;</span> m c]  <span class="op">-----&gt;</span>  [a <span class="ot">-&gt;</span> m c]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a> a <span class="ot">-&gt;</span>   b   <span class="op">.</span>   b <span class="ot">-&gt;</span>   c   <span class="op">-----&gt;</span>   a <span class="ot">-&gt;</span>   c</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>      m     <span class="op">.</span>        m     <span class="op">-----&gt;</span>        m</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>m <span class="op">.</span> m <span class="ot">-&gt;</span> m</span></code></pre></div>
<p><strong>함수 타입만 봐서는 <code>a -&gt; m b</code>의 출력 <code>m b</code>와 <code>b -&gt; m c</code>의 입력 <code>b</code>를 맞춰야만 될 것 같지만, 함수의 작업 내용으로 보면 <code>m . m</code> 을 <code>m</code> 하나와 같게 보는 문제입니다. 접점에서 <code>m b</code>와 <code>b</code>가 만나는 건 어차피 컴비네이터가 일시적으로 해결하고, 진짜 문제는 작업 내용을 잃어버리지 않는 겁니다.</strong> (<code>b</code>로 가면 effect를 모두 잃어버립니다.)</p>
<p>애초에 이 문제는 <code>m a</code>와 <code>a</code>의 문제가 아니라, effect가 두 번 겹쳐지기 때문에 <code>m (m a)</code>와 <code>m a</code>의 문제입니다.</p>
<p>함수 합성을 바라 보는 조금은 다른 눈이 생긴 것 같지 않나요? <em>만나는 타입이 반드시 같지 않아도 필요한 정보만 유지할 방법만 보인다면 컴비네이터를 이용해 합성</em>이 가능 할 수 있습니다.</p>
<blockquote>
<p>Q. <code>m a -&gt; a</code>는 불가능한데, <code>m (m a)  -&gt; m a</code>는 왜 가능한가요?<br />
A. 최종 결과값이 <code>a</code>가 되면 effect를 담아 둘 곳이 아예 없습니다. 하지만 <code>m a</code>라면 담아 둘 곳은 있는 상태입니다. <code>fmap</code> 내부에는 입력으로 들어온 <code>m a</code>의 effect와 <code>a -&gt; m b</code>에서 새로 만들어낸 effect, 이렇게 두 effect가 같이 있게 됩니다. 두 번의 effect를 어떻게 하나로 만들 방법만 있다면(effect algebra를 정의할 수 있다면) 하나로 만들어진 <code>effect</code>는 다시 <code>m a</code>에 담을 수 있습니다. 다시 말하지만 결과값이 <code>a</code>이면 effect를 담아둘 곳이 없습니다.<br />
effect가 필요 없어서 버린다면 <code>m a -&gt; a</code>도 가능하지만, effect를 잃어버리지 않으려면 <code>m a -&gt; a</code>는 불가능하다고 말합니다.</p>
</blockquote>
<blockquote>
<p>Q. List 모나드의 head 함수는 <code>head :: [a] -&gt; a</code> 타입인데요?<br />
A. 결과 <code>a</code>는 더이상 List 모나드 타입이 아닙니다. 위에서 말한대로 effect를 버리면 가능합니다. 이 경우 List 모나드의 effect를 버렸다고 말합니다.</p>
</blockquote>
<br />
<center>
<font size="7em" style="font-style:italic; font-weight: bolder; line-height: 1.2em">“m (m a)와 m a는 effect 합성만 되면, 특정 상황에선 같게 볼 수 있다.”</font>
</center>
<p><br /></p>
<h2 id="bind">Bind <code>(&gt;&gt;=)</code></h2>
<p>※ 모나드 구조라 하면,<br />
두 번의 effect를 하나로 합치는 <code>join</code>이 있기 때문에<br />
<code>a -&gt; m b</code> 타입의 함수를 합성할 때 만나게 되는 <code>m (m a)</code>를 <code>m a</code>로 만들 수 있게 되어 합성이 가능해집니다.</p>
<p><strong><code>a -&gt; m b</code> 타입을 합성하는 자체를 모나드라 부르는게 아니라</strong>, <code>m a, m (m a), m (m (m a)), m (m (m (m a)))...</code> 처럼 합성해도 effect를 모두 하나로 합쳐 <code>m a</code>로 표현할 수 있게 <code>return</code>, <code>join</code>이 있는 구조를 모나드라 합니다. 처음 공부를 할 때, 모나드의 목표를 합성으로 설명하며 <code>a -&gt; m b</code> 타입의 합성이 같이 나와 혼란스러웠던 부분입니다.</p>
<p>하스켈에선 <code>a -&gt; m b</code> 타입 함수를 합성하는데 <code>join</code>을 좀 더 편리하게 쓰기 위해(모나드를 편리하게 쓰기 위해) 아래와 같은 컴비네이터 함수를 정의합니다.</p>
<figure>
<img src="../images/before_monad_bind.png" alt="Bind = join(fmap…)" /><figcaption aria-hidden="true">Bind = join(fmap…)</figcaption>
</figure>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- a -&gt; m b 모양의 함수를 특별히 모나드(모나딕) action이라 지칭하기도 합니다.</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>ma <span class="op">&gt;&gt;=</span> action <span class="ot">=</span> join (<span class="fu">fmap</span> action ma)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- join을 쓰지 않고 &gt;&gt;= 구현</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;&gt;=</span>) <span class="dt">Nothing</span> g  <span class="ot">=</span> <span class="dt">Nothing</span> </span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;&gt;=</span>) (<span class="dt">Just</span> x) g <span class="ot">=</span> g x</span></code></pre></div>
<blockquote>
<p>Q. 함수 합성은 <code>(.)</code>으로 함수와 함수를 합성해서 결과로 합성을 돌려주는데, <code>bind</code>는 값과 함수를 합성해서 값을 돌려 주고 있습니다.<br />
A. 모나드 바탕에 들어간 생각을 <code>(.)</code>과 비슷한 모양으로 구현할 수도 있는데, 편의상 하스켈 쪽에서는 bind 정의를 더 선호한다고 합니다. 하지만, 둘은 어느 한쪽이 구현되어 있으면 다른 하나를 구현할 수 있습니다. <code>(.)</code>과 비슷한 모양은 아래와 같이 정의되어 있습니다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 이 연산자는 이름이 따로 있습니다. kleisli composition 또는 fish 연산자라고 부릅니다.</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;=&gt;)       ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m c)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> g     <span class="ot">=</span> \x <span class="ot">-&gt;</span> f x <span class="op">&gt;&gt;=</span> g</span></code></pre></div>
</blockquote>
<p>아래 그림에서 흐릿한 부분이 있으면 <code>&gt;=&gt;</code>, 없으면 <code>&gt;&gt;=</code>입니다.</p>
<p><img src="../images/join_v2.png" alt="effect 합성 - 흐릿한 부분이 있으면 &gt;=&gt;, 없으면 &gt;&gt;=" /> <img src="../images/joinjoin_v2.png" alt="effect 합성한 것에 합성 - 흐릿한 부분이 있으면 &gt;=&gt;, 없으면 &gt;&gt;=" /></p>
<blockquote>
<p>Q. <code>(&gt;=&gt;)</code>보다 <code>(&gt;&gt;=)</code>가 왜 더 편리한가요?<br />
A. <code>(&gt;&gt;=)</code>를 쓰면 <code>do</code>구문으로 바꿔서 표현할 수 있습니다.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>m a <span class="op">&gt;&gt;=</span> (\a <span class="ot">-&gt;</span> <span class="op">...</span> m b <span class="op">&gt;&gt;=</span> (\b <span class="ot">-&gt;</span> <span class="op">...</span> m c <span class="op">&gt;&gt;=</span> (\c <span class="ot">-&gt;</span> <span class="op">...</span> m d)))</span></code></pre></div>
<p>※ <code>do</code> 구문은 괄호가 위처럼 들어가 있는 상태입니다.<br />
괄호가 없으면 마지막 액션에서 <code>a, b</code>를 가져오지 못합니다.<br />
단순 <code>act1 &gt;&gt;= act2 &gt;&gt;= act3</code> 을 바꾼게 아니라 위의 괄호와 같은 실행 단위로 묶여 있어야 합니다. 람다 함수는 정의가 괄호를 만나지 않는다면 line 끝까지이기 때문에 액션 정의를 계속 람다 함수를 쓰면 괄호를 쓰지 않아도 같은 효과가 납니다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> m a</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">&lt;-</span> m b</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    c <span class="ot">&lt;-</span> m c</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    m d <span class="co">-- 여기서 a,b,c를 모두 쓸 수 있습니다.</span></span></code></pre></div>
</blockquote>
<blockquote>
<p>Q. Functor의 <code>fmap</code>과 <code>(&gt;&gt;=)</code> 정의가 같지 않나요?<br />
A. 혹시 Functor의 <code>fmap</code>과 같아 보인다면, 둘의 받는 함수의 타입을 확인해 보세요. <code>fmap</code> 은 <code>(a -&gt; b)</code> 함수를, <code>&gt;&gt;=</code> 는 <code>(a -&gt; m b)</code> 함수를 받습니다.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot">  ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre></div>
</blockquote>
<p>이제 Bind 컴비네이터를 이용하면, 아래와 같이 좀 더 편한 모양으로 합성이 됩니다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">act1 ::</span> a <span class="ot">-&gt;</span> m b</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="ot">act2 ::</span> b <span class="ot">-&gt;</span> m c</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="ot">act3 ::</span> c <span class="ot">-&gt;</span> m d</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>(m a <span class="op">&gt;&gt;=</span> act1) 결과 m b  </span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>                   (m b <span class="op">&gt;&gt;=</span> act2) 결과 m c  </span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>                                      (m c <span class="op">&gt;&gt;=</span> act3) 결과 m d  </span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- 간단히 쓰면</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>m a <span class="op">&gt;&gt;=</span> act1 <span class="op">&gt;&gt;=</span> act2 <span class="op">&gt;&gt;=</span> act3</span></code></pre></div>
<p>위와 같이 간단히 쓸 수 있는 이유가 궁금하면? - 연산자 우선 순위<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<figure>
<img src="../images/before_monad_bindGraph.png" alt="목표는 m a -&gt; … -&gt; m c 입니다" /><figcaption aria-hidden="true">목표는 m a -&gt; … -&gt; m c 입니다</figcaption>
</figure>
<p><code>m a</code>를 받아 <code>a</code>를 꺼내고, <code>a -&gt; m b</code>에 넘길수 없는 <strong>진한 파랑 m</strong>은 따로 떼어 내서, 나중에 새로 생성된 <strong>옅은 파랑 m</strong>과 하나의 <strong>진한 파랑 m</strong>으로 합쳐 다시 <code>m b</code>로 만듭니다. 이 값을 다음 <code>bind</code>에 넘깁니다.<br />
※ <code>(&gt;&gt;=)</code>나 <code>(&gt;=&gt;)</code>는 모나드의 <code>join</code>을 편하게 쓰기 위한 컴비네이터입니다.</p>
<h2 id="하스켈에서-join-구현">하스켈에서 <code>join</code> 구현</h2>
<p><code>join</code>, <code>(&gt;&gt;=)</code>, <code>(&gt;=&gt;)</code>는 어느 한 쪽만 구현되어 있으면 다른 쪽을 구현할 수 있습니다. 하스켈에선 먼저 <code>bind (&gt;&gt;=)</code>가 구현되어 있고, 이를 써서 <code>join</code>이 구현되어 있습니다.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">join   ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> m (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>join x <span class="ot">=</span>  x <span class="op">&gt;&gt;=</span> <span class="fu">id</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- bind 없이 join 구현</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>join <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span> <span class="co">-- 왼편 Nothing :: Maybe (Maybe a), 오른편 Nothing :: Maybe a</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>join (<span class="dt">Just</span> x) <span class="ot">=</span> x</span></code></pre></div>
<p>※ 참고 - 어떤 타입의 <code>id</code>가 들어가는지 보는 방법<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<figure>
<img src="../images/maybe_join2.png" alt="Maybe (Maybe a)의 join" /><figcaption aria-hidden="true">Maybe (Maybe a)의 join</figcaption>
</figure>
<figure>
<img src="../images/writer_v2.png" alt="Writer (Writer a)의 join" /><figcaption aria-hidden="true">Writer (Writer a)의 join</figcaption>
</figure>
<h2 id="결론">결론</h2>
<p><code>a -&gt; m b</code>와 <code>b -&gt; m c</code> 합성 방법을 고민하면, <code>m b</code>에서 <code>b</code>로 돌아올 방법이 필요합니다. 하지만, 펑크터 <code>m</code>은 거의 isomorphism이 아닙니다. 구조만 보존하면(homomorphism) 어떻게 변형할지 알 수 없습니다. 거꾸로 돌아오는 길은, effect를 모두 잃어버리니 애시당초 없을 확률이 높습니다. (isomorphic하여 돌아 올 때 잃어버릴 게 없다면 effect가 없다는 말입니다. effect가 없는 모나드로는 Identity 모나드가 있습니다.) 그럼 합성을 포기 했을 것도 같은데, effect만 따로 합칠 수만 있다면 합성할 수 있다는 생각을 어떻게 했을까요? 펑크터에 대한 통찰이 있어 effect가 따로 보였을까요?</p>
<p>카테고리 이론은 현재 카테고리에서 해결책을 찾지 못할 때 펑크터로 변환한 곳에서 해결책을 찾기도 합니다. <code>a -&gt; m b</code>를 펑크터<code>m</code>으로 한 번 더 변환하면 <code>m a -&gt; m (m b)</code>가 됩니다. 둘이 같게 만드는데서 해결책을 찾기 시작한 건 아닐까요?</p>
<figure>
<img src="../images/join_commute.png" alt="join (fmap f (return a)) = f a" /><figcaption aria-hidden="true">join (fmap f (return a)) = f a</figcaption>
</figure>
<p>(<code>a -&gt; m b</code> 모피즘을 펑크터 <code>id</code>로 변환한 것과, 펑크터 <code>m</code>으로 변환한 것의 Naturality condition에서 아래 빨간색 부분만 방향을 바꾼 것)</p>
<p>어떻게 떠올렸을지 모를 천재적 센스에 따라,<br />
1. <code>m a</code>가 가진 effect를 잃어버리지 않고,<br />
2. <code>a -&gt; m b</code>에서 새로 생기는 effect와 합쳐서 <code>m b</code>에 넣어 놓기 위해<br />
3. <code>join :: m (m a) -&gt; m a</code>만 있으면 합성이 가능해집니다.<br />
(그리고 여기 글에서는 제대로 언급하지 않았지만, <code>m a</code>가 아닌 <code>a</code>를 받아 <code>fmap (a -&gt; m b)</code>에 넣으려면, effect의 초기값 역할을 할 <code>return :: a -&gt; m a</code>가 필요합니다. bind를 주로 보다보면 시작이 <code>a</code>가 아니라 <code>m a</code>여서 <code>return</code>이 포커스를 덜 받긴 합니다.)</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- bind는 아래 틀에 위에 있는 것들을 넣어주는 느낌입니다.</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  a     a <span class="ot">-&gt;</span> m b       b</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>m   <span class="ot">-&gt;</span> (        ) <span class="ot">-&gt;</span> m  </span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  b     b <span class="ot">-&gt;</span> m c       c</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>m   <span class="ot">-&gt;</span> (        ) <span class="ot">-&gt;</span> m  </span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>  c     c <span class="ot">-&gt;</span> m d       d</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>m   <span class="ot">-&gt;</span> (        ) <span class="ot">-&gt;</span> m  </span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>위와 같은 함수들의 합성은<br />
값은 값대로 처리하며 진행되고,</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="op">...</span></span></code></pre></div>
<p>합성할 때마다 생기는 모든 effect들도</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="op">...</span></span></code></pre></div>
<p>잃어버리지 않고 합성됩니다.</p>
<p>서로 닮았지만 다른 두 타입 <code>m (m a)</code>와 <code>m a</code>를, bind가 <em>체이닝하는 동안은 join을 이용하여 effect를 관리해서 “다름을 문제없이 처리하고”</em> 있습니다.</p>
<p>모나드 공부는 생각의 시작점도 쉽게 추측되지 않고, 얻어지는 장점도 너무 많아 더 혼란스움을 주는 것 같습니다. 이 글의 목적은 모나드의 완벽한 이해가 아닙니다. <strong>합성을 위해서는 <code>a</code>와 <code>m a</code>가 꼭 같아야 하는게 아니라, 합성을 막고 있는 요소를 해결할 수 있으면 됩니다.</strong> <code>a -&gt; m b</code>와 <code>b -&gt; m c</code>는 effect를 빼고 보면 <code>a -&gt; b</code>와 <code>b -&gt; c</code>로 합성이 가능합니다. <code>m</code>때문에 합성을 못하고 있습니다. 두 개의 정보 <code>m</code>을 합쳐 하나로 만들수만 있으면 합성할 수 있습니다. 이를 해결하기 위해</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>m · m <span class="ot">-&gt;</span> m</span></code></pre></div>
<p>이 필요합니다. 이렇게 펑크터 <code>m</code>의 계속된 합성을 위해 모나드 개념을 도입했다를 이해하는 겁니다. 그래야 타입으로 설계할 때, <em>조금 다른 타입</em>이지만 비슷한 속성을 가지고 있는, 즉 펑크터로 변환한 타입과 변환 전 타입이 서로 만나면 모나드를 떠올릴 수 있습니다.</p>
<p><img align="right" src="../images/before_monad_bindblock.png"></p>
<p>하스켈에서 정확히 코드 모양으로 얘기하면 <code>a -&gt; m b</code>와 <code>b -&gt; m c</code>를 연결하는 게 아니라, <code>bind (&gt;&gt;=)</code>끼리 연결합니다. <code>bind (&gt;&gt;=)</code>는 그림의 비어있는 박스 부분에 적당한 <code>(a -&gt; m b)</code>를 채워 넣으면 합성되게 구조를 만들어 둔다고 볼 수 있습니다.</p>
<h2 id="모나드가-필요함을-눈치-채는-예시">모나드가 필요함을 눈치 채는 예시</h2>
<p>숫자 두개 알파벳 하나를 받는 Parser 함수를 구현한다면, numParser 두 번, alphabetParser 한 번 연결해서 구현하면 좋겠다는 생각을 할 수 있습니다.</p>
<p>그럼, 입력 문자열 “12A”를 파싱하는 동작을 생각해 보면</p>
<ol type="1">
<li><code>numParser &gt;&gt;&gt; numParser &gt;&gt;&gt; alphabetParser</code> 이렇게 붙여서 파서를 만들면 좋겠습니다.</li>
<li><code>numParser</code>가 입력 <code>String</code>에서 숫자 하나외 매칭을 시도하고, 매칭 성공하면 <code>("1", 남은 String)</code>을 리턴합니다.</li>
<li>다음 파서 <code>numParser</code>가 받아야 할 건 <code>String</code>인데, <code>("1", 남은 String)</code>이 들어 오고 있습니다. 바로 <em>같은 정보를 가지고 있지만 조금 다른 모양</em>이 눈에 들어옵니다. <code>String</code>이 <code>a</code>라면 <code>("1", 남은 String)</code> 튜플은 <code>m a</code>입니다.</li>
<li>이것만 보고 바로 모나드를 떠올려도 됩니다. 파서의 타입은 <code>a -&gt; m b</code> 타입이고, 먼저 실행한 파서에서 들어오는 건 <code>m a</code>가 들어올거라 생각할 수 있습니다. 바로 모나드와 딱 맞아 떨어지는 타입 모양입니다.</li>
</ol>
<p>다시 말하지만, 모나드가 필요한 부분을 눈치 채는게 목표입니다.</p>
<h2 id="카테고리-이론으로-가는-힌트">카테고리 이론으로 가는 힌트</h2>
<p>※ 워낙 추상적인 분야라, 여기서 고작 간단히 하는 얘기가 전체 속성이란 말은 아닙니다. 비전공자인 제 시각은 모나드를 위해서만 좁혀져서 카테고리 이론의 다른 막강함은 알지 못합니다.</p>
<p>수학의 카테고리 이론은 무언가가 같은지 다른지 보는데 필요한 정교한 툴들을 가지고 있습니다. 둘이 얼마나 다른지, 다른 정도를 표현하는 함수들을 어떻게 정의하면 좋은지 등을 다루는데 있어 탁월하다고 합니다. 어떤 시스템 둘이 완벽하게 같아서 구별할 수 없을 정도인 경우도 있을 수 있고, 일부 디테일을 가리면 같게 볼 수 있는 경우도 있고, 어떤 조건이나 함수에서만은 같은 경우도 있고, “같음”은 여러가지 “정도”로 나타날 수 있습니다. 세상에 완전히 같은 경우는 드물기 때문에, 완전히 같지는 않지만 “같게 볼 수 있는 경우”가 훨씬 더 많고, 이런 경우에 명확하게 “어느 정도 같다”라는 개념을 표현할 수 있는 툴들은, 컴퓨터 프로그래밍 뿐만 아니라 여러곳에서 굉장히 유용하다고 합니다.</p>
<p>예를 들어 모나드의 경우, <code>m a -&gt; a</code> 로 갈 방법이 없을 때, <code>m</code> 펑크터로 한 번 더 변환한 시스템에서 갈 길을 찾습니다. 펑크터로 변환한 것과 변환 전의 것이 이 만큼은 할 수 있을 정도로 같다는 것을 카테고리 이론이 논리적으로 보증해 줍니다. 이런 식으로 서로 달라 보이는 대상을 같게 볼 수 있는 툴들이 준비 되어 있어, 어느 한 시스템에서 어려움이 있거나 막혔을 때 다른 시스템으로 변환(펑크터)하여 해결책을 찾을 수도 있습니다.</p>
<p>기본이 되는 구조(Category)를 정의해 두고,<br />
Functor 하나를 이용해 구조는 유지한 채 다른 모양으로 매핑하고,<br />
다른 Functor를 이용해 역시 구조는 유지한 채 다른 모양으로 매핑합니다.<br />
그런 후 변환된 두 대상들을 얼마나 다르다고 말할 수 있는지를 Natural Transform (:: Functor -&gt; Functor)으로 표현합니다.<br />
(<code>return</code>과 <code>join</code>은 펑크터T와 펑크터T<sup>2</sup>의 다름을 나타내는 Natural Transform입니다.)</p>
<p>위와 같은 방법을 포함해서 여러가지 방법으로 다른 것과 관계를 찾아, 기존 수학에 있던 개념들을 오로지 이들 관계로만 표현해서 체계를 만들어 갑니다. 이렇게 하면, 대상의 속성들에 의존하지 않게 되어 다른 곳에서도 카테고리로 정의만 되면 기존 개념들을 그대로 적용할 수 있게 됩니다. 그 과정 속에서 위에서 보았던, 모나드 <code>join</code>의 <code>m (m a)</code>를 <code>m a</code>로 바꾸는 동작과 동일하게, <code>m · m</code>과 <code>m</code>의 다름을 처리해서 모노이드로 만드는 경우가 나옵니다. 카테고리에서 이런 동작이 포함되어 있는 구조를 모나드라합니다. 하스켈에 있는 펑크터와 모나드가 나온 곳이라 하여, 딱 모나드까지만 가보려고 하는데 그리 순탄하지는 않습니다.</p>
<p>※ 추측: Monad의 어원은 하나를 뜻하는 Monas에서 왔다고 합니다. 아마도 서로 다른 대상을 “같게” 본다는 의미가 있어 이렇게 이름 붙인게 아닐까요? 카테고리 이론에선 Monad를 Triple, Triad라 부르기도 합니다. 이 때는 3가지(펑크터, return, join)가 있으면 하나로 볼 수 있어서 그런 건 아닐까요?</p>
<figure>
<img src="../images/isomorphic.png" alt="같음" /><figcaption aria-hidden="true">같음</figcaption>
</figure>
<h2 id="도움을-주신-분들">도움을 주신 분들</h2>
<p>모나드의 카테고리 이론쪽 개념과 그동안 엉켜있던 모나드 조각들을 푸는데 도움을 주신 Ailrun님 감사드립니다. 덕분에 혼자서 넘어가기 어려운 산들을 넘어간 것 같습니다.</p>
<h2 id="여기-글은-독일수도-있다">여기 글은 “독”일수도 있다</h2>
<p>모나드 설명 글들은, 보통 “합성”을 시작으로 접근하는 경우가 많은데, 여기 글은 “같음”에 촛점을 두었습니다. 개인 의견은 모나드 설명을 “같음”에서 시작해서 풀어나가는 것이 좀 더 이해하는데 도움이 된다고 생각합니다. 모두 <code>a -&gt; b</code> 나 <code>m a -&gt; m b</code>만 있어, 단순 컴포지션으로 해결할 수 있었다면 모나드를 볼 필요가 없었을 겁니다. <code>m a</code>와 <code>a</code>가 달라서 생기는 절차를 기막히게 이용했다는 생각이 듭니다. 서로 조금씩 다른 수많은 타입들을 어떤 순간에는 같은 것으로 보고 처리할 수 있다는 생각은, 모든 걸 함수로 컴포지션하면서 풀어나가는 함수형에선 대단히 중요한 역할을 합니다.</p>
<p>카테고리 이론은 들여다 볼수록 하스켈과 정말 많이 닮았다는 생각이 들긴 하는데, 글로 정리할 정도로 이해하기가 쉽지 않네요. 국내에도 “프로그래밍 언어”등을 전공으로 하는 분들이 많을텐데, 가볍게 볼 수 있는 글들을 많이 남겨 주면 좋겠습니다.</p>
<p>블로그 글은 출판된 글과 다릅니다. 가장 큰 차이는 정교함, 정확성이란 생각이 듭니다. 출판 글들은 좀 더 자본을 들여 여러 사람들의 감수 절차도 밟고 정확한 내용을 출판하게 되지만(물론 가장 중요한 요소는 저자겠지요), 블로그 글은 글쓴이가 잘 못 이해하거나 해도, 감수라는 절차들이 따로 없어 틀릴 확률이 높아 주의해서 봐야 합니다. 저도 반복해서 검증하기 위해 노력하긴 하지만, 모두 정확하다는 확신을 갖고 올리는 글들은 아닙니다. 읽는이들이 감수자가 되어서 읽어야 합니다. 정말 안좋은 경우도 충분히 생길 수 있을거라 봅니다. 처음 접하는 개념들을 틀린 설명으로 시작한다면 확실히 독이 될 수도 있습니다. 다른 곳에 있는 내용들을 번역하거나 옮기는 글들이 많지 않아, 다시 말해 정확히 근거가 있지 않은 경우가 있어 여기 글들은 독Burrito이 될 수도 있습니다.</p>
<p>그럼에도 글을 올리는 이유는, 모나드에 접근하는 시작점 중에 하나가 “같음”이라 생각하는데, 기존 자료들에서 보지 못해, 적어도 생각의 범위를 넓히는 역할은 할 수 있을것 같아 올립니다.</p>
<p>항상 경계하며 보시고 꼭 다른 분들과 의견을 나누거나 생태계 공식 텍스트로 인정 받는 자료들을 통해 검증하며 보시기 바랍니다.</p>
<h2 id="appendix">Appendix</h2>
<h3 id="effect-합성-예시">effect 합성 예시</h3>
<p><code>(&gt;&gt;=)</code>는 <code>join</code>과 <code>fmap</code>의 동작으로 이루어져 있는데, 여기서 <code>join</code>부분만 떼어내서 보도록 하겠습니다.<br />
<code>join</code>은 아래와 같이 <code>(&gt;&gt;=)</code>로 구현할 수 있습니다.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>join mma <span class="ot">=</span> mma <span class="op">&gt;&gt;=</span> <span class="fu">id</span></span></code></pre></div>
<p><code>(&gt;&gt;=)</code>에 쓰이는 변수명은 <code>m a -&gt; (a -&gt; m b) -&gt; m b</code>에 맞춰 <code>ma</code>, <code>make_mb</code>, <code>mb</code>로 두었습니다.</p>
<h4 id="state">State</h4>
<p>바깥에서 얻은 <code>s</code>를 안에 넣어줍니다.<br />
<code>s</code>를 넣어주는 effect1과 변경된 <code>s</code>를 넣어주는 effect2를 합쳐 변경된<code>s</code>를 넣어주는 effect로 만듭니다.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a,s) }  </span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>(<span class="dt">State</span> ma) <span class="op">&gt;&gt;=</span> make_mb <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \inits <span class="ot">-&gt;</span> <span class="kw">let</span> (a, newState) <span class="ot">=</span> ma inits </span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>                                     <span class="co">-- 최초 바깥에서 들어온 inits를 ma에 넣어주면 newState가 된다. </span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>                                           (<span class="dt">State</span> mb) <span class="ot">=</span> make_mb a <span class="co">--  f :: a -&gt; m b</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>                                           <span class="kw">in</span>  mb newState <span class="co">-- mb에 ma가 갖고 있던 state를 넣어준다.  </span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- 바깥 mma에 있던 state를 안쪽 ma에 넣어준다.</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>join (<span class="dt">State</span> mma) <span class="ot">=</span> (<span class="dt">State</span> mma) <span class="op">&gt;&gt;=</span> <span class="fu">id</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>                 <span class="ot">=</span> \inits <span class="ot">-&gt;</span> <span class="kw">let</span> (ma, newState) <span class="ot">=</span> mma inits</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>                                 (<span class="dt">State</span> mb) <span class="ot">=</span> <span class="fu">id</span> ma <span class="co">--mb = ma</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>                             <span class="kw">in</span>  mb newState</span></code></pre></div>
<h4 id="writer">Writer</h4>
<p>바깥에서 <code>w</code>가 생긴 effect1과 안쪽에서 <code>w</code>생긴 effect를 <code>mappend</code>해서 하나로 만듭니다.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Writer</span> w a <span class="ot">=</span> <span class="dt">Writer</span> {<span class="ot"> runWriter ::</span> (a, w) } </span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Writer</span> (ma_x, ma_v)) <span class="op">&gt;&gt;=</span> make_mb</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>                <span class="ot">=</span> <span class="kw">let</span> (<span class="dt">Writer</span> (mb_y, mb_v')) <span class="ot">=</span> make_mb ma_x <span class="kw">in</span> <span class="dt">Writer</span> (mb_y, ma_v <span class="ot">`mappend`</span> mb_v')</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- 바깥 mma에 있던 mma_v와 안쪽 ma_v'을 mappend해서 하나로 만든다.</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>join (<span class="dt">Writer</span> (mma_x, mma_v)) </span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>                <span class="ot">=</span> (<span class="dt">Writer</span> (mma_x, mma_v)) <span class="op">&gt;&gt;=</span> <span class="fu">id</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>                <span class="ot">=</span> <span class="kw">let</span> (<span class="dt">Writer</span> (ma_y, ma_v')) <span class="ot">=</span> <span class="fu">id</span> mma_x <span class="kw">in</span> <span class="dt">Writer</span> (ma_y, mma_v <span class="ot">`mappend`</span> ma_v')</span></code></pre></div>
<h4 id="reader">Reader</h4>
<p><code>w</code>를 인자로 주는 effect1과 <code>w</code>를 인자로 주는 effect2를 합쳐도 <code>w</code>를 인자로 주는 effect입니다.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>ma <span class="op">&gt;&gt;=</span> make_mb  <span class="ot">=</span> \w <span class="ot">-&gt;</span> make_mb (ma w) w </span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- 바깥mma에 w를 주어 안쪽 ma를 만들고 w를 준다.</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>join ((<span class="ot">-&gt;</span>) mma) <span class="ot">=</span> ((<span class="ot">-&gt;</span>) mma) <span class="op">&gt;&gt;=</span> <span class="fu">id</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>                <span class="ot">=</span> \w <span class="ot">-&gt;</span> <span class="fu">id</span> (((<span class="ot">-&gt;</span>) mma) w) w</span></code></pre></div>
<h3 id="그럼-join의-동작은-마음대로-만들어도-되나">그럼 join의 동작은 마음대로 만들어도 되나?</h3>
<p><span class="citation" data-cites="todo">@todo</span>: Monad law 3가지를 지키면서 만들어야 하고, 또한 Theorem for Free에 따라 유일성unicity이 있다는 내용 추가<br />
<span class="citation" data-cites="todo">@todo</span>: Nothing :: Maybe (Maybe a)를 Just 1 :: Maybe a와 연결했을 때 monad law가 틀어지는 예시 추가</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>그냥 같게 볼 수 있는 함수가 아니라 inverseM :: m a -&gt; a 가 존재한다면?</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">inverseMaybe ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>이렇게 거꾸로 변환할 수 있는 방법이 있다면</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f fa <span class="ot">=</span> f (inverseM fa)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- m으로 추가했던 구조른 모두 버려져도 상관 없다면, 이렇게 해도 됩니다.</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- 만일 구조를 살려야 한다면 a와 다르게 추가된 구조(Nothing)에 관한 처리도 넣어줘야 합니다.</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- 원래 Maybe의 fmap</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- fmap f (Just x) = f x</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- fmap f Nothing = Nothing</span></span></code></pre></div>
<p>바인드에서 <code>action :: a -&gt; Maybe b</code> 타입 함수를 처리하는 모양은</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>ma <span class="op">&gt;&gt;=</span> action <span class="ot">=</span> action (inverseM ma)</span></code></pre></div>
<p>이렇게 간단히 끝날 수 있습니다. <em>문제는 입력으로 들어오는 값에 Maybe가 추가했던 구조는 모두 무시되었습니다.</em><br />
아마도, 대부분의 경우 이런 결과를 원하지 않을 겁니다.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>중위infix 연산자 <code>(&gt;&gt;=)</code>의 우선 순위 지정 덕분에 간단하게 쓸 수 있습니다.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">1</span>  <span class="op">&gt;&gt;</span>, <span class="op">&gt;&gt;=</span></span></code></pre></div>
<p>바인드의 우선 순위는 위와 같이 정의되어 있습니다. <code>infix</code>에 붙어 있는 <code>l</code>이 왼쪽 우선이란 뜻입니다.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Q. id는 어떤 타입이 들어가는지 어떻게 알까요?<br />
A. _ (hole)을 넣어주면 GHC가 어떤 값으로 추론했는지 알 수 있습니다.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span> <span class="dt">Data.Functor</span><span class="op">&gt;</span> join (<span class="dt">Just</span> <span class="dv">1</span>) <span class="op">&gt;&gt;=</span> _</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">9</span><span class="op">:</span><span class="dv">19</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>• <span class="dt">Found</span> hole<span class="op">:</span><span class="ot"> _ ::</span> a0 <span class="ot">-&gt;</span> m b</span></code></pre></div>
<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></li>
</ol>
</section>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <div id="footer">
            © 2021 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
