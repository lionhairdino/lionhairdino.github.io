<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <title>lionhairdino - 하스켈 소스 들여 쓰기</title>

        <meta name="description" content="들여 쓰기 개념은 상식적인 선에서 모두 들어맞을 것 같아 그냥 지나치는 경우가 있는데, 몇 가지 포인트는 짚어두고 가는게 좋습니다." />
        <meta property="og:description" content="들여 쓰기 개념은 상식적인 선에서 모두 들어맞을 것 같아 그냥 지나치는 경우가 있는데, 몇 가지 포인트는 짚어두고 가는게 좋습니다." />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="https://lionhairdino.github.io/favicon.svg" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino24px.png" sizes="24x24" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino48px.png" sizes="48x48" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../favicon.ico" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../images/favicon/Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../images/favicon/Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="https://lionhairdino.github.io/Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/images/favicon/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="하스켈 소스 들여 쓰기" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io/posts/2020-07-12-indentation.html" />

        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />

      <meta name="keywords" content="들여 쓰기, indentation, 하스켈, haskell, 함수형, Functional">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E9WZ6VXGHP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-E9WZ6VXGHP');
</script>
<script src="../script/copycode.js"></script>
<script async src="https://cse.google.com/cse.js?cx=9c53b4915cbb2605c"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.11.1/tocbot.css" />
<meta name="fediverse:creator" content="@lionhairdino@mastodon.social" />
<link rel="alternate" type="application/rss+xml" title="상상 하스켈 - Lionhairdino" href="rss.xml" />
    </head>
    <body>
        <div id="header">
            <div style="display:inline-block;margin-right:5px;padding-top: 5px;" id="logo">
                <a href="../"><img style="width:30px;border:none" src="../images/favicon/Lionhairdino48px.png"></a>
            </div>
            <div style="display:inline-block;vertical-align: top;padding-top:5px;" id="navigation">
                <a href="../">lionhairdino</a>
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
            <div style="display:inline-block;font-size:0.8em;vertical-align: top;">
                <div style="display:inline-block;vertical-align: top;padding-top: 5px"></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 10px;"><a rel="me" href="https://mastodon.social/@lionhairdino"><img style="width:20px;border:none" src="../images/mastodon.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://lionhairdino.bsky.social"><img style="width:18px;border:none" src="../images/bluesky.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://discordapp.com/users/lionhairdino#7687"><img style="width:20px;border:none" src="../images/discord.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://x.com/lionhairdino"><img style="width:15px;border:none" src="../images/X.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://linkedin.com/in/lionhairdino-l-baaa54244"><img style="width:20px;border:none" src="../images/linkedin.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://github.com/lionhairdino"><img style="width:20px;border:none" src="../images/github.svg"></a></div>
                <div style="display:inline-block;vertical-align: top;padding-top: 11px; padding-left: 2px;"><a href="https://www.threads.net/@linohairdino"><img style="width:20px;border:none" src="../images/threads.svg"></a></div>
            </div>

            <div>
                <div style="display:inline-block;width:180px;"> 
                    <div class="gcse-searchbox-only"></div>
                </div>
            </div>
            <div>
                여기 글들은 일종의 질문입니다. 용어 선택도 학계, 업계에서 쓰는 걸로 되어 있지 않고, 틀린 내용이 있을 수도 있습니다. 여기 글을 처음 읽는 분은, 먼저 <a href="warning.html">주의문</a>을 꼭 읽어보세요.
            </div>
        </div>
        <div class="js-toc-content">
            <h1>하스켈 소스 들여 쓰기</h1>
            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on July 12, 2020
    
</div>

<p><a href="https://en.wikibooks.org/wiki/Haskell/Indentation">Haskell Indentation - wikibook</a></p>
<p>※ 에디터들의 탭tab 옵션을 스페이스로 채워 넣는 것으로 바꿔야 합니다. ex) vim의 경우 set expandtab<br />
※ 여기 포스트는 코드 블록의 폰트가 고정폭이 나와야 하는데, 모바일 사파리등에선 제대로 폰트가 나오지 않아 띄어 쓰기 숫자가 정확히 눈에 들어오지 않는 경우가 있습니다. 고정폭monospace 폰트가 나오는 환경에서 봐야합니다. 모바일에서도 강제로 monospace 폰트를 지정하는 방법을 찾고 있는 중입니다.</p>
<p>들여 쓰기가 의미를 가지는 언어를 쓰는게 처음이라 은근히 헤매게 만든 요소였습니다. 내가 작성할 때 복잡하다면, 전통적으로 많이 쓰이는 레이아웃이 의미가 없는 스타일, 즉 <code>{</code>,<code>}</code>,<code>;</code>으로 레이아웃이 필요 없게 할 수도 있지만, 다른 하스켈러들은 대부분 레이아웃을 이용합니다. 상식을 벗어나는 규칙이 없긴 한데, 완전히 직관으로만 알 수 없는 규칙도 있습니다. 한 번쯤은 보고 지나가야 합니다.</p>
<ol type="1">
<li><a href="#위키북스에-나온-풀이">위키북스에 나온 풀이</a>
<ol type="1">
<li><a href="#끝나지-않은-표현식을-줄바꿈-해서-이어-갈-때는-현재-표현식의-시작보다는-들여-쓰기-해야합니다-1">끝나지 않은 표현식을 줄바꿈 해서 이어 갈 때는 현재 표현식의 시작보다는 들여 쓰기 해야합니다 (1)</a></li>
<li><a href="#같은-레벨에-있는-딸린-표현식들은-모두-같은-들여-쓰기값을-가져야-합니다-2">같은 레벨에 있는 딸린 표현식들은 모두 같은 들여 쓰기값을 가져야 합니다 (2)</a></li>
<li><a href="#들여-쓰기는-공백만-보는게-아닙니다-3">들여 쓰기는 공백만 보는게 아닙니다 (3)</a></li>
<li><a href="#표현식의-시작이-라인-시작이-아닐-때-4">표현식의 시작이 라인 시작이 아닐 때 (4)</a></li>
<li><a href="#레이아웃-키워드-let-where-of-do-5">레이아웃 키워드 let, where, of, do (5)</a></li>
<li><a href="#let과-do-where의-동작이-다르다-6">let과 do, where의 동작이 다르다 (6)</a></li>
</ol></li>
<li><a href="#실제-스펙">실제 스펙</a>
<ol type="1">
<li><a href="#l-함수의-첫-번째-인자---토큰-스트림">L 함수의 첫 번째 인자 - 토큰 스트림</a>
<ol type="1">
<li><a href="#n을-스트림에-추가">{n}을 스트림에 추가</a></li>
<li><a href="#n을-스트림에-추가-1">&lt;n&gt;을 스트림에 추가</a></li>
</ol></li>
<li><a href="#l-함수의-두-번째-인자---레이아웃-컨텍스트-스택">L 함수의 두 번째 인자 - 레이아웃 컨텍스트 스택</a></li>
<li><a href="#토큰-스트림에서-n을-만나면">토큰 스트림에서 &lt;n&gt;을 만나면</a></li>
<li><a href="#토큰-스트림에서-n을-만나면-1">토큰 스트림에서 {n}을 만나면</a></li>
<li><a href="#토큰-스트림에서-를-만나면">토큰 스트림에서 {,}를 만나면</a></li>
<li><a href="#다음-토큰이-문법상-이어지는-토큰이-아닐-때">다음 토큰이 문법상 이어지는 토큰이 아닐 때</a></li>
<li><a href="#종료-조건">종료 조건</a></li>
</ol></li>
</ol>
<h2 id="위키북스에-나온-풀이">위키북스에 나온 풀이</h2>
<h3 id="끝나지-않은-표현식을-줄바꿈-해서-이어-갈-때는-현재-표현식의-시작보다는-들여-쓰기-해야합니다-1">끝나지 않은 표현식을 줄바꿈 해서 이어 갈 때는 현재 표현식의 시작보다는 들여 쓰기 해야합니다 (1)</h3>
<h3 id="같은-레벨에-있는-딸린-표현식들은-모두-같은-들여-쓰기값을-가져야-합니다-2">같은 레벨에 있는 딸린 표현식들은 모두 같은 들여 쓰기값을 가져야 합니다 (2)</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- error</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="ot">=</span> a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">=</span> b</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- error</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="ot">=</span> a</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>     y <span class="ot">=</span> b</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="ot">=</span> a</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">=</span> b</span></code></pre></div>
<p>얼핏 보면, 표현식expression의 일부라면 시작보다 몇 칸이든 들여 쓰기만 하면 연결된 표현식이라 판단 해 줄 것 같은데, 그렇지 않습니다. 딸린 표현식은 첫 번째로 나온 딸린 표현식의 들여 쓰기와 나머지 딸린 표현식들이 들여 쓰기가 같아야 합니다. 여기서 첫 번째 딸린 표현식의 들여 쓰기를 보는 방법을 알면 거의 헤매지 않습니다.</p>
<h3 id="들여-쓰기는-공백만-보는게-아닙니다-3">들여 쓰기는 공백만 보는게 아닙니다 (3)</h3>
<p><code>x = a</code> 이전에 공백 하나 있다고 들여 쓰기가 한 칸인게 아니라 <em>(3)let까지 포함해서 들여 쓰기로 판단</em>합니다. <code>let</code> + 공백 하나 해서 총 4칸 들여 쓰기를 한 상태입니다. 그래서 위의 마지막 코드만 ok입니다. 첫 번째 딸린 표현식으로 판단한다 했으니 다음의 경우도 가능합니다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a> x <span class="ot">=</span> a</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a> x <span class="ot">=</span> b</span></code></pre></div>
<p>첫 번째 딸린 표현식은 한 칸 들여 쓰기 했으므로, 두 번째도 한 칸 들여 쓰면 ok입니다.</p>
<p>그 다음, 한 라인에 쓰여 있는 딸린 표현식의 문제입니다. 위 규칙 적용하면 다음처럼 쓸 수 있습니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>func arg1 arg2 <span class="ot">=</span> <span class="kw">do</span> foo</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                    bar</span></code></pre></div>
<p><code>do</code>를 내리면 아래처럼 쓸 수 있습니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>func arg1 arg2 <span class="ot">=</span> </span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> foo</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>       bar </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>func arg1 arg2 <span class="ot">=</span> </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> </span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        foo</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        bar </span></code></pre></div>
<p>아래처럼 <code>do</code>보다는 들여 쓰는 건 되고,</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>func arg1 arg2 <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                    foo</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                    bar</span></code></pre></div>
<h3 id="표현식의-시작이-라인-시작이-아닐-때-4">표현식의 시작이 라인 시작이 아닐 때 (4)</h3>
<p>다음 들여 쓰기는 안 될 것처럼 보입니다. 하지만, <em>(4)표현식의 시작이 라인의 시작에 있지 않을 때</em><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>는, 표현식의 시작을 포함하고 있는 라인보다만 들여 쓰기 하면 됩니다.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>func arg1 arg2 <span class="ot">=</span> <span class="kw">do</span> </span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a> foo</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a> bar</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>func <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">-</span> <span class="dv">10</span></span></code></pre></div>
<blockquote>
<p>Q. func를 표현식의 시작으로 보면 (1)번 규칙 끝나지 않은 수식으로 봐야하지 않을까요?<br />
100을 시작으로 본다면 (4)번 규칙을 적용해야 합니다.<br />
A. 실제 스펙을 보고나면 do 구문은 레이아웃을 새로 시작하는 do의 특별한 동작 때문이고,<br />
100 - 는 끝나지 않은 수식입니다.</p>
</blockquote>
<p>그럼 다음 <code>where</code>절의 들여 쓰기는 어떨까요?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- error</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    myPrint</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> myPrint <span class="ot">=</span> <span class="co">-- 끝나지 않은 표현식 </span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;ok&quot;</span></span></code></pre></div>
<p><code>myPrint</code> 정의가 라인 시작에 있지 않으니, (4)번 규칙에 따라 가능해야 할 것 같은데, 다음처럼 들여 써야만 합니다.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    myPrint</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> myPrint <span class="ot">=</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>         <span class="fu">putStrLn</span> <span class="st">&quot;ok&quot;</span> <span class="co">-- 한 칸이라도 myPrint 함수명보다는 들여 쓰기 해야합니다.</span></span></code></pre></div>
<p>(4)번 규칙이 아닌 (1)번 규칙에 걸려듭니다. <code>where</code>까지도 들여 쓰기에 포함해서 봐야하니, <code>myPrint</code>의 첫 글자 <code>m</code>보다는 들여 쓰기 해야합니다. 하지만, <code>do</code>를 써주면 함수명과 동일한 시작점까진 됩니다.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    myPrint</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> myPrint <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">putStrLn</span> <span class="st">&quot;ok&quot;</span> <span class="co">-- do를 쓰면 함수명과 갈은 위치,</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>                      <span class="co">-- 즉 where로 바뀐 컨텍스트까지는 됩니다. (실제 스펙 참고)</span></span></code></pre></div>
<p>이쯤되면 규칙이 뭘지 혼란스럽습니다.</p>
<h3 id="레이아웃-키워드-let-where-of-do-5">레이아웃 키워드 let, where, of, do (5)</h3>
<p>그냥 직관으론 다 알 수 없는 규칙이 있습니다. 바로 <em>(5) 레이아웃 키워드 let, where, of, do 중에 하나가 오면 현재 레이아웃을 기억해 두고, 새로운 레이아웃을 시작</em>한다는 규칙<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>입니다. 위 예들은 <code>where</code>로 새 레이아웃을 시작하고 첫 딸린 라인이 (3)번 규칙에 따라 <code>공백 2 + where 5글자 + 공백 1</code> 해서 총 8칸 들여 쓰기로 시작했으니, 현재 레이아웃을 8칸으로 바꾸고, 이 후에도 8칸 들여 쓰기 해야합니다. 첫 번째 <code>where</code> 예시는 <code>do</code>가 없는 경우는 새 레이아웃이 시작되는게 아니니, 아직 끝나지 않은 표현식은 (1)번 규칙에 따라 더 들여 써야 합니다. 완전히 왼쪽으로 붙이는 게 아니라 이전 레이아웃까지만 들여 씁니다.</p>
<h3 id="let과-do-where의-동작이-다르다-6">let과 do, where의 동작이 다르다 (6)</h3>
<p>※ 그런데 테스트를 해보니 let과 do의 동작이 다릅니다.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- error</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>func <span class="ot">=</span> <span class="kw">let</span> </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dv">1</span> <span class="co">-- 여기와</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span> a <span class="co">-- 여길 한 칸이라도 들여 쓰면 ok</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  func2 <span class="ot">=</span> </span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>      a</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">=</span> <span class="dv">1</span> <span class="co">-- 이렇게 func2까진 내어 써도 ok</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 이건 func2에 딸린 문장이 아니라, 탑레벨로 정의한 상태가 됩니다.</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 아래 설명 참고</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>func3 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="fu">putStrLn</span> <span class="st">&quot;ok&quot;</span> <span class="co">-- func3까지 내어 써도 ok</span></span></code></pre></div>
<p><code>let</code>에 딸린 식은 함수명(이 전 컨텍스트)보다 반드시 들여 써야하지만, <code>do</code>와 <code>where</code>는 그렇지 않습니다. 스펙에 따르면 같은 동작을 할 것으로 쓰여 있는데 그렇지 않습니다. 바로 이 전 컨텍스트보다는 들여 써야 하니 <code>do</code>, <code>where</code> 구문도 한 칸이상 들여 쓰기 해야 할 것 같은데, 함수명까지 가능합니다. <em>어딘가 놓친 규칙이 있을 것 같은데 아직 찾지 못했습니다.</em></p>
<blockquote>
<p>2022.6.26 추가
GHC와 haskell2010 리포트가 다르게 동작한다는 걸 알게 되었습니다. 특별히 <code>do</code>구문이 <code>let</code>과 다르게 동작하는 이유를 <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#extension-NondecreasingIndentation">NondecreasingIndentation</a>를 보시면 알 수 있습니다.
<code>do</code> 체이닝 할 때를 위해 특이하게 동작하는 걸로 보입니다.
이 뿐만 아니라, GHC와 haskell2010 리포트가 다른 부분이 꽤 있습니다. 링크 페이지에서 확인하실 수 있습니다. (Ailrun님 감사합니다.)</p>
</blockquote>
<p>또 <code>do</code>의 들여 쓰기에 따라 다음 구문이 영향을 받습니다.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>func2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">putStrLn</span> <span class="st">&quot;ok&quot;</span> </span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- error</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- 위 putStrLn을 한 칸이라도 들여 쓰면 ok로 바뀝니다.</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>func3 <span class="ot">=</span> a</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>   a <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<p>새 함수 정의의 시작인 <code>func3 = a</code> 는 <code>func2</code>안에 속하는 구문으로 해석해서 다음 에러가 납니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>test13<span class="op">.</span>hs<span class="op">:</span><span class="dv">9</span><span class="op">:</span><span class="dv">7</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    parse <span class="fu">error</span> on input ‘<span class="ot">=</span>’</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Perhaps</span> you need a 'let' <span class="kw">in</span> a 'do' block<span class="op">?</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    e<span class="op">.</span>g<span class="op">.</span> 'let x <span class="ot">=</span> <span class="dv">5</span>' instead <span class="kw">of</span> 'x <span class="ot">=</span> <span class="dv">5</span>'</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="dv">9</span> <span class="op">|</span> func3 <span class="ot">=</span> a</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span>    </span></code></pre></div>
<p>추측으론, 한 레이아웃이 끝나고 다음 레이아웃이 시작됨을 표시하는 방법이 한 단계 내어 쓰기해야 하는데, <code>func2</code>의 <code>do</code>구문을 들여 쓰기 0칸으로 했기 때문에, 이 보다 더 내어 쓰기를 할 수 없어 <code>func2</code>의 <code>do</code>구문을 끊지 못하는 상황입니다. <em>빈 라인을 두 번, 세 번 써준다고 컨텍스트가 바뀌는 건 아닙니다.</em></p>
<p>여기까지 wikibook 내용을 요약하며 곰곰히 보니, 결국 스펙을 제대로 이해하는 수밖에 없을 것 같습니다. wikibook은 실제 스펙 그대로가 아니라 풀어서 설명한 것입니다. 실제 스펙은 이해하기에 다소 난해하긴 합니다.</p>
<h2 id="실제-스펙">실제 스펙</h2>
<p><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3">haskell.org haskell2010 들여 쓰기</a></p>
<p>※ 입문중이시라면 위 위키북스 풀이만 보는 걸 추천드립니다. 들여 쓰기 하나 이해하는데도 이렇게 길게 이론을 봐야하나 싶은 생각이 듭니다. 저처럼 소스를 작성하다 이해할 수 없는 들여 쓰기 동작을 만났다 싶으면 그 때 가서 봐도 됩니다.</p>
<p>하스켈은 레이아웃으로 의미를 두는 방식과 C언어처럼 <code>{</code>,<code>;</code>,<code>}</code>를 써서 문장의 끝이나 블록을 표시하는 방법(이 때는 모든 토큰을 나누는 공백이 아닌 그외 공백들은 무시됩니다.) 두 가지 모두 쓸 수 있습니다. 스펙 설명을 보니, 내부에서는 레이아웃 방식에 <code>{</code>,<code>;</code>,<code>}</code>를 달아 의미 표시를 하는 방식으로 처리를 하고 있습니다. 어떤 규칙에 따라 어떤 걸 붙이는지 살펴보면 레이아웃의 의미를 알 수 있습니다.</p>
<p>가장 눈여겨 볼 표시가 <code>{</code>가 어떨 때 붙는지 보면 들여 쓰기를 이해할 수 있습니다.</p>
<p>정해진 토큰 규칙에 따라 어휘를 분석해서 어휘 스트림을 만드는데, 여기에 들여 쓰기 컨텍스트가 바뀔때마다 <code>{n}</code>을 넣고, 현재 토큰의 들여 쓰기값을 뜻하는 <code>&lt;n&gt;</code>토큰을 집어 넣습니다.</p>
<p><code>let a = 1[....공백....]b = 1[줄바꿈....공백....]in a + b</code> 소스를<br />
<code>let , {4} , a , = , 1 , &lt;4&gt; , b , = , 1 , &lt;0&gt; , in , {3} , a , + , b</code> 토큰열로 만들고<br />
<code>let , { , a , = , 1 , ; , b , = , 1 , } , in , { , a , + , b , }</code> 으로 바꾼다.</p>
<p>실제 구현은 <code>L</code>이라는 함수를 이용해 레이아웃이 의미가 있는 코드 형태를 <code>{</code>,<code>}</code>,<code>;</code>를 쓰는 코드로 바꿉니다. 일단 <code>L</code>함수가 받는 두 개의 인자를 보면</p>
<h3 id="l-함수의-첫-번째-인자---토큰-스트림">L 함수의 첫 번째 인자 - 토큰 스트림</h3>
<p>첫 번째 인자는 아래 처럼 레이아웃을 <code>{n}</code>,<code>&lt;n&gt;</code>으로 바꾼 토큰 스트림이 들어옵니다.</p>
<h4 id="n을-스트림에-추가">{n}을 스트림에 추가</h4>
<p><code>let</code>, <code>where</code>, <code>of</code>, <code>do</code> 4개 키워드 뒤에 중괄호<code>{</code>가 딸려 들어오지 않으면 <code>{n}</code>이란 토큰을 집어 넣습니다. 여기서 <code>n</code>은 이어지는 다음 구문의 들여 쓰기 칸 수가 들어갑니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="ot">=</span> a <span class="co">-- let뒤에 {가 없으므로, x = a의 들여 쓰기 칸 수 {4}를 토큰열에 넣습니다.</span></span></code></pre></div>
<p>만일, 다음 구문 없이 파일 끝이라면 <code>0</code>이 들어갑니다. 이런 경우가 뭐가 있을까 싶은데, 예를들면 <code>where</code>키워드 뒤에 아무것도 없어도 에러는 나지 않습니다. 이 걸 말하는 걸까요?</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>func3 <span class="ot">=</span> <span class="dv">1</span> <span class="kw">where</span></span></code></pre></div>
<p>module의 첫 번째 어휘가 <code>{</code>나 <code>module</code>이 아니면, 앞에 {n}이 옵니다. n은 첫 번째 어휘의 들여 쓰기 칸 수가 들어갑니다.
아래와 같이 쓰면, {2}를 넣어놔서 컨텍스트를 바꾸니 다음 func2도 바뀐 컨텍스트 2칸에 맞춰야 합니다.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  func1 <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  func2 <span class="ot">=</span> <span class="dv">2</span> </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="op">^^</span></span></code></pre></div>
<p>정리하면, 블록의 시작을 알릴만한 위치에 <code>{</code>가 없으면 <code>{n}</code>을 넣습니다. n칸 들여 써서 블록<code>{}</code>을 나타내겠다는 말입니다.</p>
<h4 id="n을-스트림에-추가-1">&lt;n&gt;을 스트림에 추가</h4>
<p>어휘의 시작 앞에 공백만 있으면, 이 어휘 앞에 <code>&lt;n&gt;</code>을 넣습니다. <code>n</code>은 이 어휘의 들여 쓰기 칸 수입니다. 단 위의 단계로 이미 {n}이 있을 때는 넣지 않습니다. 그리고 또 다음같은 경우도 넣지 않습니다. 아래 예를 보면 <code>\Bill</code>은 완성된 어휘의 첫글자도 아니고, 콤마<code>,</code>도 아니므로 <code>&lt;n&gt;</code>을 넣지 않습니다. 이어지는 문장은 <code>\Bill</code>이 아니라 <code>Some</code>처럼 <code>(</code>와 들여쓰기를 맞춘다는 얘기입니다.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ok</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> (<span class="st">&quot;Hello \</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="st">        \Bill&quot;</span>, <span class="st">&quot;Jake&quot;</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Some</span></span></code></pre></div>
<p><em>{n}이 들어오면 레이아웃 스택에 n을 추가하고(다른 말로 하면, 지금까지의 컨텍스트를 기억하고, 현재 컨텍스트를 n으로 바꾸고), &lt;n&gt;은 현재 구문의 들여쓰기를 나타냅니다.</em></p>
<h3 id="l-함수의-두-번째-인자---레이아웃-컨텍스트-스택">L 함수의 두 번째 인자 - 레이아웃 컨텍스트 스택</h3>
<p>레이아웃을 관리하는 스택을 만들고, <code>{n}</code>을 받을 때, <code>n</code>값을 넣어 뒀다가 하나씩 꺼내거나 넣으면서 들여 쓰기 관리를 합니다. 이 스택의 제일 위에 있는 숫자가 현재 ’레이아웃 컨텍스트’입니다.</p>
<p>레이아웃을 지정하는 “layout context”<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> 스택은<br />
Zero : 명시적으로 중괄호<code>{</code>를 쓴 경우는 0입니다. 가장 안 쪽 컨텍스트가 <code>0</code>이면, 감싸진 컨텍스트가 끝나거나 새로운 컨텍스트가 생기기 전까지 레이아웃 토큰이 들어갈 일은 없습니다. ※ <em>레이아웃을 보고 GHC가 알아서 {를 추가 했을 때도 <code>0</code>으로 리셋된다고 오해했습니다.</em> 프로그래머가 명시적으로 <code>{</code>를 써줄 때만 <code>0</code>이 되고, GHC가 추가 했을 때는 <code>{n}</code>안의 <code>n</code>이 됩니다.</p>
<p>양의 정수 : enclosing 컨텍스트(블록을 의미합니다.)의 들여 쓰기를 뜻합니다.<br />
※ <code>let</code>, <code>where</code>, <code>of</code>, <code>do</code>등은 <code>{</code>으로 감싸고 있습니다. 이 걸 enclosing context라 합니다.</p>
<p>하스켈 일반 문법과 마찬가지로 토큰 스트림을 리스트의 cons<code>(:)</code>로 표시하고, 레이아웃 규칙도 일반 하스켈 함수처럼 설명합니다. 입문을 막 시작했을 때 보기는 썩 편하지 않을 것 같습니다. 저도 역시 편하지 않습니다.</p>
<p>이제 이 두 인자들의 값을 비교해 가면서, 적절한 위치에 <code>{</code>,<code>;</code>,<code>}</code>를 넣어 변환하게 됩니다.<br />
들어 오는 인자 모양에 따른 L함수 정의를 보면</p>
<h3 id="토큰-스트림에서-n을-만나면">토큰 스트림에서 &lt;n&gt;을 만나면</h3>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>(가)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- L은 레이아웃 스트림을 {;}방식 스트림으로 바꿉니다.</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- 토큰열에서 꺼낸 현재 토큰이 &lt;n&gt;이면</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="dt">L</span> (<span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="op">:</span> ts) (레이아웃 스택 m <span class="op">:</span> ms) <span class="ot">=</span>  ;  <span class="op">:</span> (<span class="dt">L</span> ts (m <span class="op">:</span> ms))          만일 m <span class="ot">=</span> n</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>                                    <span class="ot">=</span>  }  <span class="op">:</span> (<span class="dt">L</span> (<span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="op">:</span> ts) ms)        만일 n <span class="op">&lt;</span> m</span></code></pre></div>
<p>토큰열에 <code>&lt;n&gt;</code>이 들어왔다면, 현재 컨텍스트 값이랑 비교해서 같다면, 같은 레벨의 문장이니 <code>;</code>를 결과 스트림에 넣습니다.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a <span class="ot">=</span> <span class="dv">1</span> <span class="co">-- 토큰a 앞에 토큰{4}가 들어있는데,</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">=</span> <span class="dv">1</span> <span class="co">-- 들여 쓰기가 &lt;4&gt;이므로 m = n 입니다. 그럼 앞에 ;를 넣습니다.</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span> a <span class="op">+</span> b <span class="co">-- n은 0인데 현재 컨텍스트 m은 4인 상태입니다. 그럼 앞에 }를 넣습니다. </span></span></code></pre></div>
<p>스펙 페이지에 명확한 예시는 없지만, 위와 같은 코드는 <code>let, {4}, a, =, 1, &lt;4&gt;, b, =, 1, &lt;0&gt;, in, {3}, a, +, b</code> 토큰열이 들어와서 <code>let , { , a , = , 1 , ; , b , = , 1 , } , in , { , a , + , b , }</code> 으로 바뀐다고 보면 됩니다.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>(나)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="dt">L</span> (<span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="op">:</span> ts) ms <span class="ot">=</span> <span class="dt">L</span> ts ms</span></code></pre></div>
<p>토큰열에 <code>&lt;n&gt;</code>이 들어왔을 때, (가)조건에 걸려들지 않으려면 <code>n &gt; m</code> 인 경우 뿐이 없습니다. 현재 컨텍스트보다 더 들여 쓰기 된 경우입니다.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> (<span class="st">&quot;Hello \</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="st">        \Bill&quot;</span>, <span class="st">&quot;Jake&quot;</span>) <span class="co">-- 컨텍스트가 4 &lt; 현재 들여쓰기가 &lt;8&gt;일때는 아무 작업 없이 바로 다음 토큰으로</span></span></code></pre></div>
<p>위 코드의 <code>\Bill</code>은 새로운 구문의 시작이 아닙니다.</p>
<h3 id="토큰-스트림에서-n을-만나면-1">토큰 스트림에서 {n}을 만나면</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>(다)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">L</span> ({n} <span class="op">:</span> ts) (m <span class="op">:</span> ms) <span class="ot">=</span> { <span class="op">:</span> (<span class="dt">L</span> ts (n <span class="op">:</span> m <span class="op">:</span> ms)) 만일 n <span class="op">&gt;</span> m 일때는 <span class="dt">Note</span> <span class="dv">1</span></span></code></pre></div>
<p><code>{n}</code>이 들어오면 블록의 시작이니 <code>{</code>를 넣어 주고, 지금까지의 컨텍스트였던 <code>m</code>을 다시 넣고, 그 다음 <code>n</code>을 넣어 컨텍스트를 바꿔 놓습니다. 그러면 현재는 <code>n</code> 컨텍스트에 있는 상태고, 나중에 <code>}</code>를 명시적, 또는 암시적으로 만나면 <code>m</code> 컨텍스트가 된다는 얘기입니다.</p>
<p>Note 1.<br />
안에 들어 있는nested 컨텍스트(B)는 enclosing 컨텍스트(A)보다 더 들여쓰기 해야 합니다.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- error</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> <span class="kw">let</span> <span class="co">---- (A)</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>         h y <span class="ot">=</span> <span class="kw">let</span> <span class="co">---- (B)</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  p z <span class="ot">=</span> z</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>               <span class="kw">in</span> p</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> h</span></code></pre></div>
<p><code>p</code> 정의 부분이 enclosing 컨텍스트보다 덜 들여 쓰기 되어 있어 에러입니다. <code>h</code>보다는 들여 써야 됩니다.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>(라)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="dt">L</span> ({n} <span class="op">:</span> ts) [] <span class="ot">=</span> {  <span class="op">:</span>  (<span class="dt">L</span> ts [n]) 만약 n <span class="op">&gt;</span> <span class="dv">0</span> (<span class="dt">Note</span> <span class="dv">1</span>) </span></code></pre></div>
<p>스택이 비었고<code>[]</code> <code>n</code>이 <code>0</code>이 아니면 스택에 <code>n</code>을 넣고 다음 토큰으로</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>(마)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a> <span class="dt">L</span> ({n} <span class="op">:</span> ts) ms <span class="ot">=</span> {  <span class="op">:</span>  }  <span class="op">:</span>  (<span class="dt">L</span> (<span class="op">&lt;</span> n <span class="op">&gt;:</span> ts) ms) (<span class="dt">Note</span> <span class="dv">2</span>) </span></code></pre></div>
<p>(다), (라)에 걸려들지 않았다면, <code>{}</code>를 넣어주고, <code>&lt;n&gt;</code>이 들어온것으로 간주하고 진행합니다.</p>
<p>Note 2.<br />
<code>where</code> 뒤의 첫 번째 토큰이 enclosing 컨텍스트보다 덜 들여 쓰여 있다면</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>    func <span class="ot">=</span> some</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<p><code>a = 1</code>은 <code>where</code>에 딸린 구문이 아니고,<code>where</code> 뒤는 빈 블록 <code>{}</code>으로 간주합니다.</p>
<h3 id="토큰-스트림에서-를-만나면">토큰 스트림에서 {,}를 만나면</h3>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>(바)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="dt">L</span> (} <span class="op">:</span> ts) (<span class="dv">0</span> <span class="op">:</span> ms) <span class="ot">=</span> }  <span class="op">:</span>  (<span class="dt">L</span> ts ms) (<span class="dt">Note</span> <span class="dv">3</span>)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="dt">L</span> (} <span class="op">:</span> ts) ms <span class="ot">=</span> parse<span class="op">-</span><span class="fu">error</span> (<span class="dt">Note</span> <span class="dv">3</span>)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="dt">L</span> ({ <span class="op">:</span> ts) ms <span class="ot">=</span> {  <span class="op">:</span>  (<span class="dt">L</span> ts (<span class="dv">0</span> <span class="op">:</span> ms)) (<span class="dt">Note</span> <span class="dv">4</span>) </span></code></pre></div>
<p>Note 3.<br />
닫는 중괄호가 들어 왔다면, 그 전에 명시적으로 여는 중괄호를 써서 레이아웃 컨텍스트에 <code>0</code>을 넣어 놨어야 합니다. 그렇지 않으면 매치되는 중괄호를 연 적이 없다고 판단해서 <code>parse-error</code>입니다.</p>
<p>Note 4.<br />
여는 중괄호가 들어 왔다면, 레이아웃 스택에 <code>0</code>을 넣습니다.</p>
<h3 id="다음-토큰이-문법상-이어지는-토큰이-아닐-때">다음 토큰이 문법상 이어지는 토큰이 아닐 때</h3>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>(사)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="dt">L</span> (t <span class="op">:</span> ts) (m <span class="op">:</span> ms) <span class="ot">=</span> }  <span class="op">:</span>  (<span class="dt">L</span> (t <span class="op">:</span> ts) ms) <span class="kw">if</span> m ∕<span class="ot">=</span> <span class="dv">0</span> <span class="fu">and</span> parse<span class="op">-</span><span class="fu">error</span>(t) (<span class="dt">Note</span> <span class="dv">5</span>) </span></code></pre></div>
<p>Note 5.<br />
위 조건들에 모두 걸리지 않았다면, 그리고 현재 레이아웃 컨텍스트가 <code>0</code>이 아니고, <code>parse-error(t)</code>가 참이면, 레아아웃 컨텍스트를 하나 꺼내서 버리고, <code>}</code>을 결과에 붙이고, 다시 현재 토큰을 가지고 <code>L</code>을 부릅니다.<br />
<code>parse-error(현재 토큰)</code> 해석은 다음과 같습니다. 만일 지금까지 <code>L</code>로 생성한 토큰과 다음 토큰<code>t</code>를 붙인 게 문법에 맞지 않는 prefix를 나타내고, 지금까지 생성한 토큰에 <code>}</code>를 붙인 게 문법에 맞는 prefix라면, <code>parse-error(현재토큰t)</code>는 <code>true</code>입니다. 말이 복잡한데, <em>문법상 다음 토큰이 이어지는게 아니라면 <code>}</code>를 넣고 다음 토큰을 다시 살펴 본다는 말입니다.</em></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>(아)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="dt">L</span> (t <span class="op">:</span> ts) ms <span class="ot">=</span> t  <span class="op">:</span>  (<span class="dt">L</span> ts ms) </span></code></pre></div>
<p>위 조건 모두에 걸리지 않았다면, 현재 토큰을 붙이고, 레이아웃 스택 그대로 다음 토큰으로 진행</p>
<h3 id="종료-조건">종료 조건</h3>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>(자)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="dt">L</span> [] [] <span class="ot">=</span> [] <span class="co">-- 빈 문자열 들어오면 종료</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="dt">L</span> [] (m <span class="op">:</span> ms) <span class="ot">=</span> }  <span class="op">:</span>  <span class="dt">L</span> [] ms <span class="kw">if</span> m≠<span class="dv">0</span> (<span class="dt">Note</span> <span class="dv">6</span>)</span></code></pre></div>
<p>Note 6.<br />
토큰은 끝났는데, 레이아웃 스택이 비어 있지 않으면 <code>}</code>를 붙입니다. 그리고 레이아웃 스택이 비워질 때까지 하나씩 꺼내며 <code>}</code>를 붙입니다. 여기까지 도달했는데, <code>non-layout context (예 m = 0)</code> 라면 에러입니다-보통 다음 구문을 보고 컨텍스트를 끊기 위해 <code>}</code>를 넣는데, <code>}</code>를 넣기 전에 이미 컨텍스트가 0이라면 무언가 잘 못 됐다는 얘기입니다.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">....</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>} <span class="co">-- 이렇게 닫는 괄호를 한 번 더 쓴 것과 같은 상황입니다.</span></span></code></pre></div>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>wikibook엔 (4)번 표현식 시작이 라인 시작에 없을 때의 규칙 설명이 있습니다. 하지만, 없어도 (1)번과 (5)번 규칙으로 정해질 것 같은데, GHC 내부에 구현되어 있는 규칙이 뭔지 궁금합니다.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>wikibook 설명엔 다음과 같이 되어 있습니다.<br />
If you see one of the layout keywords, (<code>let</code>, <code>where</code>, <code>of</code>, <code>do</code>), insert an open <code>curly brace</code> (right before the stuff that follows it)
C언어처럼 <code>let {</code>, <code>where {</code>, <code>of {</code>, <code>do {</code> 중괄호를 넣어서 읽으면 된다고 되어 있는 걸, 동작에 맞춰 말을 바꿨습니다. <code>{</code> 중괄호를 넣는다는 건 새로운 레이아웃을 시작한다는 말입니다.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>들여 쓰기에 따라 코드에 의미가 있기 때문에 layout이란 용어를 씁니다. 코드가 어떻게 배치 되었냐는 말입니다. <code>{}</code>을 써서 블록을 표현하던 걸, <code>{}</code>없이 동일한 들여 쓰기만으로 같은 블록안의 코드임을 나타냅니다. 이 때 한 블록을 나타내는 동일한 들여 쓰기 값을 layout context라 합니다. 문서에 따라 layout이라 표현하는데도 있고, context라 표현하는데도 있고, layout context, 현재 컨텍스트 등등으로 표현합니다.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

<div class="comment">
<script src="https://utteranc.es/client.js" repo="lionhairdino/lionhairdino.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async>
</script>
</div>
<div style="text-align:right">Github 계정이 없는 분은 메일로 보내주세요. lionhairdino at gmail.com </div>
        </div>
        <nav class="toc toc-right js-toc relative z-1 transition--300 absolute pa4 pt5 is-position-fixed"></nav>
        <div id="footer">
            © 2022 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
        <script>
            tocbot.init({
                tocSelector: '.js-toc',
                contentSelector: '.js-toc-content',
                headingSelector: 'h2, h3',
                hasInnerContainers: true,
            });
        </script>
    </body>
</html>
