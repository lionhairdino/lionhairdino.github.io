<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ko" lang="ko">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>lionhairdino - 컴파일 에러 읽기 - Couldn't match type & Could not deduce & No instance</title>

<meta name="description" content="lionhairdino - 컴파일 에러 읽기 - Couldn't match type & Could not deduce & No instance" />
<meta property="og:description" content="하스켈 함수형 프로그래밍" />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="icon" href="favicon.svg" />
        <link rel="icon" type="image/x-icon" href="http://lionhairdino.github.io/favicon.ico" />
        <link rel="icon" type="image/png" href="../Lionhairdino16px.png" sizes="16x16" />
        <link rel="icon" type="image/png" href="../Lionhairdino32px.png" sizes="32x32" />
        <link rel="icon" type="image/png" href="../Lionhairdino57px.png" sizes="57x57" />
        <link rel="icon" type="image/png" href="../Lionhairdino60px.png" sizes="60x60" />
        <link rel="icon" type="image/png" href="../Lionhairdino64px.png" sizes="64x64" />
        <link rel="icon" type="image/png" href="../Lionhairdino72px.png" sizes="72x72" />
        <link rel="icon" type="image/png" href="../Lionhairdino76px.png" sizes="76x76" />
        <link rel="icon" type="image/png" href="../Lionhairdino114px.png" sizes="114x114" />
        <link rel="apple-touch-icon-precomposed" href="../Lionhairdino120px.png" sizes="120x120" />
        <link rel="apple-touch-icon-precomposed" href="../Lionhairdino144px.png" sizes="144x144" />
        <link rel="shortcut icon" href="../Lionhairdino144px.png" />
        <link rel="apple-touch-icon-precomposed" href="../Lionhairdino152px.png" sizes="152x152" />
        <link rel="apple-touch-icon-precomposed" href="../Lionhairdino180px.png" sizes="180x180" />
        <link rel="icon" type="image/png" href="../Lionhairdino192px.png" sizes="192x192" />
        <link rel="manifest" href="../site.webmanifest" />
        <link rel="mask-icon" href="../Lionhairdino_black.svg" color="#ff7500" />
        <meta name="msapplication-TileImage" content="/Lionhairdino144px.png" />
        <meta name="msapplication-TileColor" content="#ff7500" />
        <meta name="theme-color" content="#ffffff" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="컴파일 에러 읽기 - Couldn't match type & Could not deduce & No instance" />
        <meta property="og:site_name" content="Lionhairdino" />
        <meta property="og:url" content="https://lionhairdino.github.io" />
        <meta property="og:image" content="https://lionhairdino.github.io/images/state400px.png" />
<meta name="keywords" content="에러, error, deduce, 타입 추론, match, 타입 매칭, match type, deduce, No instance, constraint, 제약, forall">
    </head>
    <body>
        <div id="header">
            <div id="logo"> </div>
            <div id="navigation">:w3
                <a href="../">lionhairdino</a> 
                <a href="../about.html">about</a>
                <!--<a href="/archive.html">archive</a>-->
            </div>
        </div>

        <div id="content">
            <h1>컴파일 에러 읽기 - Couldn't match type & Could not deduce & No instance</h1>

            <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
<div class="info">
    Posted on June 12, 2020
    
</div>

<p>에러 메시지를 문장 그대로 읽으려면 다음에 익숙해져야 합니다.</p>
<p><em>rising</em> : 타입을 결정해 가는 과정은, 타입 제약을 쌓아가다 한 가지 타입으로 추론 될 수도 있고, 그냥 타입 제약까지만 결정될 수도 있습니다. 전체 진행 과정을 타입 추론이라고 하지만, 하나의 단서로 인해 나온 조건은 추론deduced됐다 표현하지 않고, rising 됐다 표현합니다. (제 생각은 추론deduced된 경우만 있는게 아니라, 지정specified 했을 경우도 있으니 rising이라 표현하지 않았을까 합니다.)</p>
<p><em>rigid</em> : rigid는 융통성이 없다는 뜻인데, 여기선 어떤 형태로 지정됐기 때문에 더 이상 다른 형태로 추론하지 못한다는 뜻에서 <em>지정</em>으로 번역했습니다.</p>
<p><em>forall</em> : 아무 타입이나 와도 된다가 아니라, 반드시 아무 타입이 들어와도 문제가 없어야 한다 입니다. 단어 그대로 어느 한 가지 타입이 아닌 <em>모든 타입</em>입니다. 특정 확장들을 켜지 않으면 서명에 드러나진 않지만, 서명에 아무런 제약없이 써있는 소문자들은 forall a 타입으로 보면 됩니다.</p>
<p><em>(forall ) constraint</em> : constraint를 써주는 것도 사실은 forall이 숨어 있습니다. constraint를 따르는 모든forall 타입을 받아 들여도 문제가 없다는 뜻입니다.</p>
<p>딱 부러지게 나온 구체 타입, 어떤 종류의 타입, 모든 타입… 이들 모두를 타입이라 표현하겠습니다. 무슨말이냐 하면 IO 타입, MonadIO =&gt; 타입, forall 타입 이들이 모두 그냥 같은 수준의 다른 타입들입니다. IO타입과 MonadIO =&gt; 는 서로 다른 타입입니다. MonadIO =&gt; 타입과 forall 타입은 서로 다른 타입입니다. 예를 들어, forall 타입을 받는 함수와, MonadIO =&gt; 타입을 받는 함수는 다른 타입의 함수입니다.</p>
<p>물론, 바이너리가 만들어질 때 IO타입처럼 구체 타입이 아닌 타입들은 언젠가 절차를 거쳐 구체 타입이 될 겁니다. 하지만, 에러를 읽을 때는 특별한 다음 절차를 내포했다는 건 잠시 잊어버리고 그냥 타입으로 바라봅니다. 에러에 등장하는 타입은</p>
<p>Int, Maybe Int, Strin, [], MonadIO =&gt; 타입, forall 타입….</p>
<p>모두 같은 선상에 놓인 타입이란 뜻입니다.</p>
<h2 id="no-instance---인스턴스가-있는-타입으로-바꿔-봐">No instance - 인스턴스가 있는 타입으로 바꿔 봐</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Reader</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">func1 ::</span> m ()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>func1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> ask</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  liftIO <span class="op">$</span> <span class="fu">print</span> a</span></code></pre></div>
<p>컴파일 하면</p>
<pre><code>    • No instance for (Monad m) arising from a do statement
      Possible fix:
        add (Monad m) to the context of
          the type signature for:
            func1 :: forall (m :: * -&gt; *). m ()
|   a &lt;- ask

    • Ambiguous type variable ‘a0’ arising from a use of ‘ask’
      prevents the constraint ‘(MonadReader a0 m)’ from being solved.
      Relevant bindings include func1 :: m () (bound at test.hs:7:1)

|   a &lt;- ask
    • No instance for (MonadIO m) arising from a use of ‘liftIO’
      Possible fix:
        add (MonadIO m) to the context of
          the type signature for:
            func1 :: forall (m :: * -&gt; *). m ()
|   liftIO $ print a

    • Ambiguous type variable ‘a0’ arising from a use of ‘print’
      prevents the constraint ‘(Show a0)’ from being solved.
      Relevant bindings include a :: a0 (bound at test.hs:12:3)
|   liftIO $ print a
...</code></pre>
<p>첫 번째 에레는,<br />
“do구문을 보고 나온 형태 (Monad m) 인스턴스가 없다.”<br />
m은 특별히 결정한 형태가 없습니다. <code>* -&gt; *</code> 카인드의 <em>모든 타입</em>입니다. 모든 <code>m</code>을 위한 Monad 인스턴스는 당연히 없습니다.</p>
<p>두 번째 에러는,<br />
“ask를 보고 나온 타입 변수 a0가 모호해서, 제약constraint (MonadReader a0 m)을 풀 수 없다.”<br />
<code>ask</code>는 <code>MonadReader</code>클래스의 메소드이니, <code>(MonadReader a0 m =&gt; )</code> 타입 형태인데, <code>a0</code>가 뭔지 알 수 없다입니다. 이 것도 아무런 타입 제약이 없으니, 모든 <code>m</code>으로 결정하고, <code>(MonadReader a0 m)</code> 인스턴스가 없다는 No instance 에러가 나면 될 것 같은데, 왜 <code>a0</code>에 먼저 꽂혔을까요? <em>추측</em> 타입 변수 순서대로 풀이resolve를 시도하는게 아닐까 추측합니다.</p>
<p>세 번째 에러는 첫 번째와 같은 종류로 (MonadIO m)이 없다는 에러고,<br />
네 번째 에러는 두 번째와 같은 종류로 (Show a0)의 a0가 모호하다는 에러입니다.</p>
<p>GHC가 <code>a0</code>가 모호하지 않도록, 타입을 지정해 보겠습니다. 패턴 매칭할때 타입을 써주려면 <code>ScopedTypeVariable</code> 확장을 켜야 합니다. 참고 - <a href="../extensions/2020-07-11-ScopedTypeVariables.html">확장 ScopedTypeVariables</a></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  a ::</span> <span class="dt">Int</span> <span class="ot">&lt;-</span> ask <span class="co">-- 패턴에 타입 지정</span></span></code></pre></div>
<pre><code>    • No instance for (MonadReader Int m) arising from a use of ‘ask’
    • In a stmt of a 'do' block: a :: Int &lt;- ask
10 |   a :: Int &lt;- ask</code></pre>
<p><code>a0</code>가 모호하지 않게 <code>Int</code>로 알려주니, 이제 예상했던 No instance 에러가 납니다.</p>
<p>그럼 위의 에러들의 해결책은 뭘까요? No instance라 했으니, 인스턴스를 정의하면 해결될 것 같은 메시지입니다. 하지만, “모든 m”타입의 인스턴스는 정의할 수 없습니다. 애시당초 클래스와 인스턴스는 ad hoc 다형성 스타일 요소로 특정 타입을 위한 동작을 정의할 때 씁니다. 이제 여기서 <em>진짜 타입 추론의 목적</em>이 드러납니다. 사실 <code>ask</code>와 <code>liftIO</code>는 모든 타입에 쓸 수 있는 메소드들이 아닙니다. 그러니, 나중에 <code>m</code>으로 이들을 쓸 수 없는 타입이 들어오게 내버려 두면 당연히 문제가 생깁니다. <em>함수 서명만 보고도 안전하게 조립</em>할 수 있도록 안전 장치를 해두어야 합니다. (모든 타입이란 말이 헛걸리지 않게 forall 타입이라 표현하겠습니다.) <code>forall m</code>타입을 위한 인스턴스가 없다는 말은, <code>forall m</code>을 위한 인스턴스를 만들어서 해결하는게 아니라, <code>forall m</code> 타입을 인스턴스가 있을만한 타입으로 바꾸어서 해결합니다. 해결책은 바로 constraint입니다.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Reader</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="ot">func1 ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">MonadReader</span> c m, <span class="dt">Show</span> c) <span class="ot">=&gt;</span> m ()</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>func1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> ask</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  liftIO <span class="op">$</span> <span class="fu">print</span> a</span></code></pre></div>
<p>do 구문은 bind함수가 가려져 있는데, MonadIO 인스턴스라면 bind함수가 있을테니 지금 당장 구체 타입은 모르더라도 나중에 만나게 될 컨텍스트가 MonadIO m =&gt; 타입이기만 하면 됩니다. forall m 타입을 위한 인스턴스가 없으니, 나중에 구체 타입을 알아야 할 때가 오면 MonadIO m =&gt; 타입의 인스턴스를 꼭 환인해서 조립하란 표시입니다. 마찬가지로, ask를 쓰고 있으니, MonadReader 클래스의 인스턴스여야 하고, print를 쓰고 있으니 Show클래스의 인스턴스여야 합니다. forall m타입을 (MonadIO, MonadReader, Show) =&gt; 타입으로 바꾸어 해결했습니다.</p>
<p>해결책을 정리하면<br />
No instance 에러가 났다면, 진짜 필요한 인스턴스 정의가 없거나, <em>대상 타입이 잘 못 지정됐을 수 있습니다.</em><br />
예) MonadIO =&gt; 타입이어야 하는데 forall 타입으로 되어 있다.</p>
<p>※ mtl 스타일 참고 - <a href="../posts/2020-07-16-MonadTransformer.html">모나드 트랜스포머 그리고 mtl</a></p>
<h2 id="couldnt-match-type---하나의-대상이-두-가지-이상의-형태로-추론-됐다.">Couldn’t match type - 하나의 대상이 두 가지 이상의 형태로 추론 됐다.</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans.Reader</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.IO.Class</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> m ()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>someFunc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> ask</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  liftIO <span class="op">$</span> <span class="fu">print</span> a</span></code></pre></div>
<pre><code>    • Couldn't match type ‘m’ with ‘ReaderT a0 m0’ ---- (1)
      ‘m’ is a rigid type variable bound by ----------- (2)
        the type signature for:
          func1 :: forall (m :: * -&gt; *). m ()
      Expected type: m a0 ------------------------------(3)
        Actual type: ReaderT a0 m0 a0 ------------------(4)
    • In a stmt of a 'do' block: a &lt;- ask          </code></pre>
<pre><code>Couldn't match type ‘m’ with ‘ReaderT a0 m0’</code></pre>
<ol type="1">
<li>“<code>m</code>타입은 서명 <code>forall (m :: * -&gt; *). m ()</code>에 지정된rigid 타입인데, <code>m</code>을 <code>ReaderT</code>와 매치할 수 없다.”</li>
</ol>
<pre><code>      ‘m’ is a rigid type variable bound by
        the type signature for:
          func1 :: forall (m :: * -&gt; *). m ()</code></pre>
<ol start="2" type="1">
<li><code>m</code>의 <em>타입 추론을 못해서</em> <code>m</code>으로 남아 있는게 아니라, 서명 <code>forall (m :: * -&gt; *). m ()</code>에서 모든 타입이 될 수 있다고 <em>지정한rigid</em> 타입이라 따로 더 이상 추론하지 않습니다. 여기서 결정된<code>rising</code> 타입은 “<em>어떤 타입이 들어와도 상관 없다</em>”가 아니라 , 반드시 “<em>모든 타입이 다 가능해야 한다</em>”입니다. 여기선 카인드 조건이 들어가 있습니다. 완전히 모든 타입이 아니라 <code>* -&gt; *</code> 카인드인 모든 타입이란 뜻입니다.</li>
</ol>
<p>※ 카인드는 타입 분류입니다. 타입 변수 없이 자체로 타입으로 쓰일지, 타입 변수 하나를 받아 타입으로 쓰일지… 등에 따라 타입을 분류해 놓은 겁니다. Int는 <code>*</code> 카인드이고, Maybe는 <code>* -&gt; *</code> 카인드입니다.</p>
<pre><code>      Expected type: m a0</code></pre>
<ol start="3" type="1">
<li>그래서 forall m 타입이 와야하는데,</li>
</ol>
<pre><code> Actual type: ReaderT a0 m0 a0
    • In a stmt of a 'do' block: a &lt;- ask</code></pre>
<ol start="4" type="1">
<li><code>ask</code>의 결과 타입은 <code>ReaderT a m</code> 이므로, 여기서 결정된 타입은 <code>ReaderT</code> 입니다.</li>
</ol>
<p>정리하면, 단서들을 통해 찾은 결과가 두 가지인데, 이 두가지 <code>forall m</code>과 <code>ReaderT</code>가 매치되지 않는다는 에러입니다.</p>
<h2 id="could-not-deduce---클래스-제약에-필요한-정보가-없어">Could not deduce - 클래스 제약에 필요한 정보가 없어</h2>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">MonadReader</span> r m) <span class="ot">=&gt;</span> m ()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>someFunc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> ask</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  liftIO <span class="op">$</span> <span class="fu">print</span> a</span></code></pre></div>
<pre><code>    • Could not deduce (Show r) arising from a use of ‘print’
      from the context: (MonadIO m, MonadReader r m)
        bound by the type signature for:
                   someFunc :: forall (m :: * -&gt; *) r.
                               (MonadIO m, MonadReader r m) =&gt;
                               m ()
8 |   liftIO $ print a</code></pre>
<p><code>a</code>타입을 다루는 <code>Show</code> 인스턴스가 있어야 하는데, <code>a</code>타입에 대한 정보가 없습니다.</p>
<p>문장 그대로 읽으면,<br />
<code>Could not deduce (Show r) arising from a use of ‘print’ from the context (MonadIO m, MonadReader r m)</code><br />
<code>print</code> 함수를 쓰려면, <code>r</code>이 <code>Show</code>의 인스턴스여야 하는데, <code>(MonadIO m, MonadReader r m)</code> 컨텍스트만 가지곤 <code>Show</code>를 추론deduce할 수 없다는 뜻입니다.</p>
<ol type="1">
<li>단서로 나온 타입의 인스턴스가 없다. (보통 단서에서 나온 타입이 잘 못 됐다.) - No instance</li>
<li>단서1에서 나온rising 타입 형태와 단서2에서 나온 타입 형태가 맞지 않다. - Couldn’t match</li>
<li>단서에서 나온 클래스의 인스턴스만 쓰겠다는 정보가 Constraint에 없다. - Could not deduce</li>
</ol>
<p>두 번째와 세 번째의 차이는 첫 번째 에러는 <em>m, ReaderT 두 타입의 문제</em>고, 두 번째 에러는 <em>Show 클래스와 r 타입</em>의 문제입니다. Constraint가 없을 때는 deduce 에러는 나지 않고 보통 No Instance 에러가 납니다.</p>

<div id="disqus_thread" style="padding-top:40px"></div>
<script>

var disqus_config = function () {
this.page.url = 'https://lionhairdino.github.io/errors/2020-06-12-couldNotMatch.html';
this.page.identifier = 'errors/2020-06-12-couldNotMatch.markdown';
};
(function() {
var d = document, s = d.createElement('script');
s.src = 'https://lionhairdino.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
        </div>
        <div id="footer">
            © 2021 lionhairdino. All rights reserved. Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
